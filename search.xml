<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>strange_things</title>
      <link href="/2018/11/30/strange-things/"/>
      <url>/2018/11/30/strange-things/</url>
      
        <content type="html"><![CDATA[<h4 id="c语言中将float直接赋值给double再进行一些乘乘除除有问题要加static_castfloat">1. c++语言中，将float直接赋值给double，再进行一些乘乘除除有问题。要加static_cast<doulbe>(float);</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vtable</title>
      <link href="/2017/01/22/vtable/"/>
      <url>/2017/01/22/vtable/</url>
      
        <content type="html"><![CDATA[<h1 id="vtable-notes-on-multiple-inheritance-in-gcc-c-compiler-v4.0.1">VTable Notes on Multiple Inheritance in GCC C++ Compiler v4.0.1</h1><h2 id="the-basics-single-inheritance">1. The Basics: Single Inheritance</h2><p>As we discussed in class, single inheritance leads to an object layout with base class data laid out before derived class data. So if classes A and B are defined thusly:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><p>then objects of type B are laid out like this (where "b" is a pointer to such an object):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b --&gt; +-----------+</span><br><span class="line">      |     a     |</span><br><span class="line">      +-----------+</span><br><span class="line">      |     b     |</span><br><span class="line">      +-----------+</span><br></pre></td></tr></table></figure><p>If you have virtual methods: <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">v</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> then you'll have a vtable pointer as well: <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">                           +-----------------------+</span><br><span class="line">                           |     <span class="number">0</span> (top_offset)    |</span><br><span class="line">                           +-----------------------+</span><br><span class="line">b --&gt; +----------+         | ptr to typeinfo <span class="keyword">for</span> B |</span><br><span class="line">      |  vtable  |-------&gt; +-----------------------+</span><br><span class="line">      +----------+         |         A::v()        |</span><br><span class="line">      |     a    |         +-----------------------+</span><br><span class="line">      +----------+</span><br><span class="line">      |     b    |</span><br><span class="line">      +----------+</span><br></pre></td></tr></table></figure> that is, top_offset and the typeinfo pointer live above the location to which the vtable pointer points.</p><h2 id="simple-multiple-inheritance">2. Simple Multiple Inheritance</h2><p>Now consider multiple inheritance:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">v</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> b;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">w</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A, <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>In this case, objects of type C are laid out like this:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">                           +-----------------------+</span><br><span class="line">                           |     <span class="number">0</span> (top_offset)    |</span><br><span class="line">                           +-----------------------+</span><br><span class="line">c --&gt; +----------+         | ptr to typeinfo <span class="keyword">for</span> C |</span><br><span class="line">      |  vtable  |-------&gt; +-----------------------+</span><br><span class="line">      +----------+         |         A::v()        |</span><br><span class="line">      |     a    |         +-----------------------+</span><br><span class="line">      +----------+         |    <span class="number">-8</span> (top_offset)    |</span><br><span class="line">      |  vtable  |---+     +-----------------------+</span><br><span class="line">      +----------+   |     | ptr to typeinfo <span class="keyword">for</span> C |</span><br><span class="line">      |     b    |   +---&gt; +-----------------------+</span><br><span class="line">      +----------+         |         B::w()        |</span><br><span class="line">      |     c    |         +-----------------------+</span><br><span class="line">      +----------+</span><br></pre></td></tr></table></figure><p>...but why? Why two vtables in one? Well, think about type substitution. If I have a pointer-to-C, I can pass it to a function that expects a pointer-to-A or to a function that expects a pointer-to-B. If a function expects a pointer-to-A and I want to pass it the value of my variable c (of type pointer-to-C), I'm already set. Calls to A::v() can be made through the(first) vtable, and the called function can access the member a through the pointer I pass in the same way as it can through any pointer-to-A.</p><p>However, if I pass the value of my pointer variable c to a function that expects a pointer-to-B, we also need a subobject of type B in our C to refer it to. This is why we have the second vtable pointer. We can pass the pointer value(c + 8 bytes) to the function that expects a pointer-to-B, and it's all set: it can make calls to B::w() through the (second) vtable pointer, and access the member b through the pointer we pass in the same way as it can through any pointer-to-B.</p><p>Note that this "pointer-correction" needs to occur for called methods too. Class C inherits B::w() in this case. When w() is called on through a pointer-to-C, the pointer (which becomes the this pointer inside of w() needs to be adjusted. This is often called this pointer adjustment.</p><p>In some cases, the compiler will generate a thunk to fix up the address. Consider the same code as above but this time C overrides B's member function w():</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">v</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> b;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">w</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A, <span class="keyword">public</span> B &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> c;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">w</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>C's object layout and vtable now look like this:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">                           +-----------------------+</span><br><span class="line">                           |     <span class="number">0</span> (top_offset)    |</span><br><span class="line">                           +-----------------------+</span><br><span class="line">c --&gt; +----------+         | ptr to typeinfo <span class="keyword">for</span> C |</span><br><span class="line">      |  vtable  |-------&gt; +-----------------------+</span><br><span class="line">      +----------+         |         A::v()        |</span><br><span class="line">      |     a    |         +-----------------------+</span><br><span class="line">      +----------+         |         C::w()        |</span><br><span class="line">      |  vtable  |---+     +-----------------------+</span><br><span class="line">      +----------+   |     |    <span class="number">-8</span> (top_offset)    |</span><br><span class="line">      |     b    |   |     +-----------------------+</span><br><span class="line">      +----------+   |     | ptr to typeinfo <span class="keyword">for</span> C |</span><br><span class="line">      |     c    |   +---&gt; +-----------------------+</span><br><span class="line">      +----------+         |    thunk to C::w()    |</span><br><span class="line">                           +-----------------------+</span><br></pre></td></tr></table></figure><p>Now, when w() is called on an instance of C through a pointer-to-B, the thunk is called. What does the thunk do? Let's disassemble it (here, with gdb):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0804860c</span> &lt;_ZThn8_N1C1wEv+<span class="number">0</span>&gt;:  addl   $<span class="number">0xfffffff8</span>,<span class="number">0x4</span>(%esp)</span><br><span class="line"><span class="number">0x08048611</span> &lt;_ZThn8_N1C1wEv+<span class="number">5</span>&gt;:  jmp    <span class="number">0x804853c</span> &lt;_ZN1C1wEv&gt;</span><br></pre></td></tr></table></figure><p>So it merely adjusts the this pointer and jumps to C::w(). All is well.</p><p>But doesn't the above mean that B's vtable always points to this C::w() thunk? I mean, if we have a pointer-to-B that is legitimately a B (not a C), we don't want to invoke the thunk, right?</p><p>Right. The above embedded vtable for B in C is special to the B-in-C case. B's regular vtable is normal and points to B::w() directly.</p><h2 id="the-diamond-multiple-copies-of-base-classes-non-virtual-inheritance">3. The Diamond: Multiple Copies of Base Classes (non-virtual inheritance)</h2><p>Okay. Now to tackle the really hard stuff. Recall the usual problem of multiple copies of base classes when forming an inheritance diamond:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">v</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> b;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">w</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> c;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">x</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> d;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">y</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Note that D inherits from both B and C, and B and C both inherit from A. This means that D has two copies of A in it. The object layout and vtable embedding is what we would expect from the previous sections:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">                           +-----------------------+</span><br><span class="line">                           |     <span class="number">0</span> (top_offset)    |</span><br><span class="line">                           +-----------------------+</span><br><span class="line">d --&gt; +----------+         | ptr to typeinfo <span class="keyword">for</span> D |</span><br><span class="line">      |  vtable  |-------&gt; +-----------------------+</span><br><span class="line">      +----------+         |         A::v()        |</span><br><span class="line">      |     a    |         +-----------------------+</span><br><span class="line">      +----------+         |         B::w()        |</span><br><span class="line">      |     b    |         +-----------------------+</span><br><span class="line">      +----------+         |         D::y()        |</span><br><span class="line">      |  vtable  |---+     +-----------------------+</span><br><span class="line">      +----------+   |     |   <span class="number">-12</span> (top_offset)    |</span><br><span class="line">      |     a    |   |     +-----------------------+</span><br><span class="line">      +----------+   |     | ptr to typeinfo <span class="keyword">for</span> D |</span><br><span class="line">      |     c    |   +---&gt; +-----------------------+</span><br><span class="line">      +----------+         |         A::v()        |</span><br><span class="line">      |     d    |         +-----------------------+</span><br><span class="line">      +----------+         |         C::x()        |</span><br><span class="line">                           +-----------------------+</span><br></pre></td></tr></table></figure><p>Of course, we expect A's data (the member a) to exist twice in D's object layout (and it is), and we expect A's virtual member functions to be represented twice in the vtable (and A::v() is indeed there). Okay, nothing new here.</p><h2 id="the-diamond-single-copies-of-virtual-bases">4. The Diamond: Single Copies of Virtual Bases</h2><p>But what if we apply virtual inheritance? C++ virtual inheritance allows us to specify a diamond hierarchy but be guaranteed only one copy of virtually inherited bases. So let's write our code this way:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">v</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> b;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">w</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> c;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">x</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> d;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">y</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>All of a sudden things get a lot more complicated. If we can only have one copy of A in our representation of D, then we can no longer get away with our "trick" of embedding a C in a D (and embedding a vtable for the C part of D in D's vtable). But how can we handle the usual type substitution if we can't do this?</p><p>Let's try to diagram the layout:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">                                   +-----------------------+</span><br><span class="line">                                   |   <span class="number">20</span> (vbase_offset)   |</span><br><span class="line">                                   +-----------------------+</span><br><span class="line">                                   |     <span class="number">0</span> (top_offset)    |</span><br><span class="line">                                   +-----------------------+</span><br><span class="line">                                   | ptr to typeinfo <span class="keyword">for</span> D |</span><br><span class="line">                      +----------&gt; +-----------------------+</span><br><span class="line">d --&gt; +----------+    |            |         B::w()        |</span><br><span class="line">      |  vtable  |----+            +-----------------------+</span><br><span class="line">      +----------+                 |         D::y()        |</span><br><span class="line">      |     b    |                 +-----------------------+</span><br><span class="line">      +----------+                 |   <span class="number">12</span> (vbase_offset)   |</span><br><span class="line">      |  vtable  |---------+       +-----------------------+</span><br><span class="line">      +----------+         |       |    <span class="number">-8</span> (top_offset)    |</span><br><span class="line">      |     c    |         |       +-----------------------+</span><br><span class="line">      +----------+         |       | ptr to typeinfo <span class="keyword">for</span> D |</span><br><span class="line">      |     d    |         +-----&gt; +-----------------------+</span><br><span class="line">      +----------+                 |         C::x()        |</span><br><span class="line">      |  vtable  |----+            +-----------------------+</span><br><span class="line">      +----------+    |            |    <span class="number">0</span> (vbase_offset)   |</span><br><span class="line">      |     a    |    |            +-----------------------+</span><br><span class="line">      +----------+    |            |   <span class="number">-20</span> (top_offset)    |</span><br><span class="line">                      |            +-----------------------+</span><br><span class="line">                      |            | ptr to typeinfo <span class="keyword">for</span> D |</span><br><span class="line">                      +----------&gt; +-----------------------+</span><br><span class="line">                                   |         A::v()        |</span><br><span class="line">                                   +-----------------------+</span><br></pre></td></tr></table></figure><p>Okay. So you see that A is now embedded in D in essentially the same way that other bases are. But it's embedded in D rather than inits directly-derived classes.</p><h2 id="constructiondestruction-in-the-presence-of-multiple-inheritance">5. Construction/Destruction in the Presence of Multiple Inheritance</h2><p>How is the above object constructed in memory when the object itself is constructed? And how do we ensure that a partially-constructed object (and its vtable) are safe for constructors to operate on?</p><p>Fortunately, it's all handled very carefully for us. Say we're constructing a new object of type D (through, for example, new D). First, the memory for the object is allocated in the heap and a pointer returned. D's constructor is invoked, but before doing any D-specific construction it call's A's constructor on the object (after adjusting the this pointer, of course!). A's constructor fills in the A part of the D object as if it were an instance of A.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">d --&gt; +----------+</span><br><span class="line">      |          |</span><br><span class="line">      +----------+</span><br><span class="line">      |          |</span><br><span class="line">      +----------+</span><br><span class="line">      |          |</span><br><span class="line">      +----------+</span><br><span class="line">      |          |       +-----------------------+</span><br><span class="line">      +----------+       |     <span class="number">0</span> (top_offset)    |</span><br><span class="line">      |          |       +-----------------------+</span><br><span class="line">      +----------+       | ptr to typeinfo <span class="keyword">for</span> A |</span><br><span class="line">      |  vtable  |-----&gt; +-----------------------+</span><br><span class="line">      +----------+       |         A::v()        |</span><br><span class="line">      |    a     |       +-----------------------+</span><br><span class="line">      +----------+</span><br></pre></td></tr></table></figure><p>Control is returned to D's constructor, which invokes B's constructor. (Pointer adjustment isn't needed here.) When B's constructor is done,the object looks like this:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">                                             B-in-D</span><br><span class="line">                          +-----------------------+</span><br><span class="line">                          |   <span class="number">20</span> (vbase_offset)   |</span><br><span class="line">                          +-----------------------+</span><br><span class="line">                          |     <span class="number">0</span> (top_offset)    |</span><br><span class="line">                          +-----------------------+</span><br><span class="line">d --&gt; +----------+        | ptr to typeinfo <span class="keyword">for</span> B |</span><br><span class="line">      |  vtable  |------&gt; +-----------------------+</span><br><span class="line">      +----------+        |         B::w()        |</span><br><span class="line">      |    b     |        +-----------------------+</span><br><span class="line">      +----------+        |    <span class="number">0</span> (vbase_offset)   |</span><br><span class="line">      |          |        +-----------------------+</span><br><span class="line">      +----------+        |   <span class="number">-20</span> (top_offset)    |</span><br><span class="line">      |          |        +-----------------------+</span><br><span class="line">      +----------+        | ptr to typeinfo <span class="keyword">for</span> B |</span><br><span class="line">      |          |   +--&gt; +-----------------------+</span><br><span class="line">      +----------+   |    |         A::v()        |</span><br><span class="line">      |  vtable  |---+    +-----------------------+</span><br><span class="line">      +----------+</span><br><span class="line">      |    a     |</span><br><span class="line">      +----------+</span><br></pre></td></tr></table></figure><p>But wait... B's constructor modified the A part of the object by changing it's vtable pointer! How did it know to distinguish this kind of B-in-D from a B-in-something-else (or a standalone B for that matter)? Simple. The virtual table table told it to do this. This structure, abbreviated VTT, is a table of vtables used in construction. In our case, the VTT for D looks like this: <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">                                                                  B-in-D</span><br><span class="line">                                               +-----------------------+</span><br><span class="line">                                               |   <span class="number">20</span> (vbase_offset)   |</span><br><span class="line">            VTT <span class="keyword">for</span> D                          +-----------------------+</span><br><span class="line">+-------------------+                          |     <span class="number">0</span> (top_offset)    |</span><br><span class="line">|    vtable <span class="keyword">for</span> D   |-------------+            +-----------------------+</span><br><span class="line">+-------------------+             |            | ptr to typeinfo <span class="keyword">for</span> B |</span><br><span class="line">| vtable <span class="keyword">for</span> B-in-D |-------------|----------&gt; +-----------------------+</span><br><span class="line">+-------------------+             |            |         B::w()        |</span><br><span class="line">| vtable <span class="keyword">for</span> B-in-D |-------------|--------+   +-----------------------+</span><br><span class="line">+-------------------+             |        |   |    <span class="number">0</span> (vbase_offset)   |</span><br><span class="line">| vtable <span class="keyword">for</span> C-in-D |-------------|-----+  |   +-----------------------+</span><br><span class="line">+-------------------+             |     |  |   |   <span class="number">-20</span> (top_offset)    |</span><br><span class="line">| vtable <span class="keyword">for</span> C-in-D |-------------|--+  |  |   +-----------------------+</span><br><span class="line">+-------------------+             |  |  |  |   | ptr to typeinfo <span class="keyword">for</span> B |</span><br><span class="line">|    vtable <span class="keyword">for</span> D   |----------+  |  |  |  +-&gt; +-----------------------+</span><br><span class="line">+-------------------+          |  |  |  |      |         A::v()        |</span><br><span class="line">|    vtable <span class="keyword">for</span> D   |-------+  |  |  |  |      +-----------------------+</span><br><span class="line">+-------------------+       |  |  |  |  |</span><br><span class="line">                            |  |  |  |  |                         C-in-D</span><br><span class="line">                            |  |  |  |  |      +-----------------------+</span><br><span class="line">                            |  |  |  |  |      |   <span class="number">12</span> (vbase_offset)   |</span><br><span class="line">                            |  |  |  |  |      +-----------------------+</span><br><span class="line">                            |  |  |  |  |      |     <span class="number">0</span> (top_offset)    |</span><br><span class="line">                            |  |  |  |  |      +-----------------------+</span><br><span class="line">                            |  |  |  |  |      | ptr to typeinfo <span class="keyword">for</span> C |</span><br><span class="line">                            |  |  |  |  +----&gt; +-----------------------+</span><br><span class="line">                            |  |  |  |         |         C::x()        |</span><br><span class="line">                            |  |  |  |         +-----------------------+</span><br><span class="line">                            |  |  |  |         |    <span class="number">0</span> (vbase_offset)   |</span><br><span class="line">                            |  |  |  |         +-----------------------+</span><br><span class="line">                            |  |  |  |         |   <span class="number">-12</span> (top_offset)    |</span><br><span class="line">                            |  |  |  |         +-----------------------+</span><br><span class="line">                            |  |  |  |         | ptr to typeinfo <span class="keyword">for</span> C |</span><br><span class="line">                            |  |  |  +-------&gt; +-----------------------+</span><br><span class="line">                            |  |  |            |         A::v()        |</span><br><span class="line">                            |  |  |            +-----------------------+</span><br><span class="line">                            |  |  |</span><br><span class="line">                            |  |  |                                    D</span><br><span class="line">                            |  |  |            +-----------------------+</span><br><span class="line">                            |  |  |            |   <span class="number">20</span> (vbase_offset)   |</span><br><span class="line">                            |  |  |            +-----------------------+</span><br><span class="line">                            |  |  |            |     <span class="number">0</span> (top_offset)    |</span><br><span class="line">                            |  |  |            +-----------------------+</span><br><span class="line">                            |  |  |            | ptr to typeinfo <span class="keyword">for</span> D |</span><br><span class="line">                            |  |  +----------&gt; +-----------------------+</span><br><span class="line">                            |  |               |         B::w()        |</span><br><span class="line">                            |  |               +-----------------------+</span><br><span class="line">                            |  |               |         D::y()        |</span><br><span class="line">                            |  |               +-----------------------+</span><br><span class="line">                            |  |               |   <span class="number">12</span> (vbase_offset)   |</span><br><span class="line">                            |  |               +-----------------------+</span><br><span class="line">                            |  |               |    <span class="number">-8</span> (top_offset)    |</span><br><span class="line">                            |  |               +-----------------------+</span><br><span class="line">                            |  |               | ptr to typeinfo <span class="keyword">for</span> D |</span><br><span class="line">                            +----------------&gt; +-----------------------+</span><br><span class="line">                               |               |         C::x()        |</span><br><span class="line">                               |               +-----------------------+</span><br><span class="line">                               |               |    <span class="number">0</span> (vbase_offset)   |</span><br><span class="line">                               |               +-----------------------+</span><br><span class="line">                               |               |   <span class="number">-20</span> (top_offset)    |</span><br><span class="line">                               |               +-----------------------+</span><br><span class="line">                               |               | ptr to typeinfo <span class="keyword">for</span> D |</span><br><span class="line">                               +-------------&gt; +-----------------------+</span><br><span class="line">                                               |         A::v()        |</span><br><span class="line">                                               +-----------------------+</span><br></pre></td></tr></table></figure></p><p>D's constructor passes a pointer into D's VTT to B's constructor (in this case, it passes in the address of the first B-in-D entry). And, indeed,the vtable that was used for the object layout above is a special vtable used just for the construction of B-in-D.</p><p>Control is returned to the D constructor, and it calls the C constructor(with a VTT address parameter pointing to the "C-in-D+12" entry). When C's constructor is done with the object it looks like this: <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">                                                                           B-in-D</span><br><span class="line">                                                        +-----------------------+</span><br><span class="line">                                                        |   <span class="number">20</span> (vbase_offset)   |</span><br><span class="line">                                                        +-----------------------+</span><br><span class="line">                                                        |     <span class="number">0</span> (top_offset)    |</span><br><span class="line">                                                        +-----------------------+</span><br><span class="line">                                                        | ptr to typeinfo <span class="keyword">for</span> B |</span><br><span class="line">                    +---------------------------------&gt; +-----------------------+</span><br><span class="line">                    |                                   |         B::w()        |</span><br><span class="line">                    |                                   +-----------------------+</span><br><span class="line">                    |                          C-in-D   |    <span class="number">0</span> (vbase_offset)   |</span><br><span class="line">                    |       +-----------------------+   +-----------------------+</span><br><span class="line">d --&gt; +----------+  |       |   <span class="number">12</span> (vbase_offset)   |   |   <span class="number">-20</span> (top_offset)    |</span><br><span class="line">      |  vtable  |--+       +-----------------------+   +-----------------------+</span><br><span class="line">      +----------+          |     <span class="number">0</span> (top_offset)    |   | ptr to typeinfo <span class="keyword">for</span> B |</span><br><span class="line">      |    b     |          +-----------------------+   +-----------------------+</span><br><span class="line">      +----------+          | ptr to typeinfo <span class="keyword">for</span> C |   |         A::v()        |</span><br><span class="line">      |  vtable  |--------&gt; +-----------------------+   +-----------------------+</span><br><span class="line">      +----------+          |         C::x()        |</span><br><span class="line">      |    c     |          +-----------------------+</span><br><span class="line">      +----------+          |    <span class="number">0</span> (vbase_offset)   |</span><br><span class="line">      |          |          +-----------------------+</span><br><span class="line">      +----------+          |   <span class="number">-12</span> (top_offset)    |</span><br><span class="line">      |  vtable  |--+       +-----------------------+</span><br><span class="line">      +----------+  |       | ptr to typeinfo <span class="keyword">for</span> C |</span><br><span class="line">      |    a     |  +-----&gt; +-----------------------+</span><br><span class="line">      +----------+          |         A::v()        |</span><br><span class="line">                            +-----------------------+</span><br></pre></td></tr></table></figure> As you see, C's constructor again modified the embedded A's vtable pointer.The embedded C and A objects are now using the special construction C-in-D vtable, and the embedded B object is using the special construction B-in-D vtable. Finally, D's constructor finishes the job and we end up with the same diagram as before: <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">                                   +-----------------------+</span><br><span class="line">                                   |   <span class="number">20</span> (vbase_offset)   |</span><br><span class="line">                                   +-----------------------+</span><br><span class="line">                                   |     <span class="number">0</span> (top_offset)    |</span><br><span class="line">                                   +-----------------------+</span><br><span class="line">                                   | ptr to typeinfo <span class="keyword">for</span> D |</span><br><span class="line">                      +----------&gt; +-----------------------+</span><br><span class="line">d --&gt; +----------+    |            |         B::w()        |</span><br><span class="line">      |  vtable  |----+            +-----------------------+</span><br><span class="line">      +----------+                 |         D::y()        |</span><br><span class="line">      |     b    |                 +-----------------------+</span><br><span class="line">      +----------+                 |   <span class="number">12</span> (vbase_offset)   |</span><br><span class="line">      |  vtable  |---------+       +-----------------------+</span><br><span class="line">      +----------+         |       |    <span class="number">-8</span> (top_offset)    |</span><br><span class="line">      |     c    |         |       +-----------------------+</span><br><span class="line">      +----------+         |       | ptr to typeinfo <span class="keyword">for</span> D |</span><br><span class="line">      |     d    |         +-----&gt; +-----------------------+</span><br><span class="line">      +----------+                 |         C::x()        |</span><br><span class="line">      |  vtable  |----+            +-----------------------+</span><br><span class="line">      +----------+    |            |    <span class="number">0</span> (vbase_offset)   |</span><br><span class="line">      |     a    |    |            +-----------------------+</span><br><span class="line">      +----------+    |            |   <span class="number">-20</span> (top_offset)    |</span><br><span class="line">                      |            +-----------------------+</span><br><span class="line">                      |            | ptr to typeinfo <span class="keyword">for</span> D |</span><br><span class="line">                      +----------&gt; +-----------------------+</span><br><span class="line">                                   |         A::v()        |</span><br><span class="line">                                   +-----------------------+</span><br></pre></td></tr></table></figure></p><p>Destruction occurs in the same fashion but in reverse. D's destructor is invoked. After the user's destruction code runs, the destructor calls C's destructor and directs it to use the relevant portion of D's VTT. C's destructor manipulates the vtable pointers in the same way it did during construction; that is, the relevant vtable pointers now point into the C-in-D construction vtable. Then it runs the user's destruction code for C and returns control to D's destructor, which next invokes B's destructor with a reference into D's VTT. B's destructor sets up the relevant portions of the object to refer into the B-in-D construction vtable. It runs the user's destruction code for B and returns control to D's destructor, which finally invokes A's destructor. A's destructor changes the vtable for the A portion of the object to refer into the vtable for A. Finally, control returns to D's destructor and destruction of the object is complete. The memory once used by the object is returned to the system.</p><p>Now, in fact, the story is somewhat more complicated. Have you ever seen those "in-charge" and "not-in-charge" constructor and destructor specifications in GCC-produced warning and error messages or in GCC-produced binaries? Well, the fact is that there can be two constructor implementations and up to three destructor implementations.</p><p>An "in-charge" (or complete object) constructor is one that constructs virtual bases, and a "not-in-charge" (or base object) constructor is one that does not. Consider our above example. If a B is constructed, its constructor needs to call A's constructor to construct it. Similarly, C's constructor needs to construct A. However, if B and C are constructed as part of a construction of a D, their constructors should not construct A, because A is a virtual base and D's constructor will take care of constructing it exactly once for the instance of D. Consider the cases:</p><p>If you do a new A, A's "in-charge" constructor is invoked to construct A. When you do a new B, B's "in-charge" constructor is invoked. It will call the "not-in-charge" constructor for A.</p><p>new C is similar to new B.</p><p>A new D invokes D's "in-charge" constructor. We walked through this example. D's "in-charge" constructor calls the"not-in-charge" versions of A's, B's, and C's constructors (in thatorder).</p><p>An "in-charge" destructor is the analogue of an "in-charge"constructor---it takes charge of destructing virtual bases. Similarly,a "not-in-charge" destructor is generated. But there's a third one as well. An "in-charge deleting" destructor is one that deallocates the storage as well as destructing the object. So when is one called in preference to the other?</p><p>Well, there are two kinds of objects that can be destructed---those allocated on the stack, and those allocated in the heap. Consider this code (given our diamond hierarchy with virtual-inheritance from before): <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">D d;            <span class="comment">// allocates a D on the stack and constructs it</span></span><br><span class="line">D *pd = <span class="keyword">new</span> D;  <span class="comment">// allocates a D in the heap and constructs it</span></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="keyword">delete</span> pd;      <span class="comment">// calls "in-charge deleting" destructor for D</span></span><br><span class="line"><span class="keyword">return</span>;         <span class="comment">// calls "in-charge" destructor for stack-allocated D</span></span><br></pre></td></tr></table></figure> We see that the actual delete operator isn't invoked by the code doing the delete, but rather by the in-charge deleting destructor for the object being deleted. Why do it this way? Why not have the caller call the in-charge destructor, then delete the object? Then you'd have only two copies of destructor implementations instead of three...</p><p>Well, the compiler could do such a thing, but it would be morecomplicated for other reasons. Consider this code (assuming a virtual destructor,which you always use, right?...right?!?): <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">D *pd = <span class="keyword">new</span> D;  <span class="comment">// allocates a D in the heap and constructs it</span></span><br><span class="line">C *pc = d;      <span class="comment">// we have a pointer-to-C that points to our heap-allocated D</span></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="keyword">delete</span> pc;      <span class="comment">// call destructor thunk through vtable, but what about delete?</span></span><br></pre></td></tr></table></figure> If you didn't have an "in-charge deleting" variety of D's destructor, then the delete operation would need to adjust the pointer just like the destructor thunk does. Remember, the C object is embedded in a D, and so our pointer-to-C above is adjusted to point into the middle of our D object.We can't just delete this pointer, since it isn't the pointer that was returned by malloc() when we constructed it.</p><p>So, if we didn't have an in-charge deleting destructor, we'd have to have thunks to the delete operator (and represent them in our vtables), or something else similar.</p><h2 id="thunks-virtual-and-non-virtual">6. Thunks, Virtual and Non-Virtual</h2><p>This section not written yet.</p><h2 id="multiple-inheritance-with-virtual-methods-on-one-side">7. Multiple Inheritance with Virtual Methods on One Side</h2><p>Okay. One last exercise. What if we have a diamond inheritance hierarchy with virtual inheritance, as before, but only have virtual methods along one side of it? So: <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> b;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">w</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">int</span> d;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">y</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> In this case the object layout is the following: <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">                                   +-----------------------+</span><br><span class="line">                                   |   <span class="number">20</span> (vbase_offset)   |</span><br><span class="line">                                   +-----------------------+</span><br><span class="line">                                   |     <span class="number">0</span> (top_offset)    |</span><br><span class="line">                                   +-----------------------+</span><br><span class="line">                                   | ptr to typeinfo <span class="keyword">for</span> D |</span><br><span class="line">                      +----------&gt; +-----------------------+</span><br><span class="line">d --&gt; +----------+    |            |         B::w()        |</span><br><span class="line">      |  vtable  |----+            +-----------------------+</span><br><span class="line">      +----------+                 |         D::y()        |</span><br><span class="line">      |     b    |                 +-----------------------+</span><br><span class="line">      +----------+                 |   <span class="number">12</span> (vbase_offset)   |</span><br><span class="line">      |  vtable  |---------+       +-----------------------+</span><br><span class="line">      +----------+         |       |    <span class="number">-8</span> (top_offset)    |</span><br><span class="line">      |     c    |         |       +-----------------------+</span><br><span class="line">      +----------+         |       | ptr to typeinfo <span class="keyword">for</span> D |</span><br><span class="line">      |     d    |         +-----&gt; +-----------------------+</span><br><span class="line">      +----------+</span><br><span class="line">      |     a    |</span><br><span class="line">      +----------+</span><br></pre></td></tr></table></figure> So you can see the C subobject, which has no virtual methods, still has a vtable (albeit empty). Indeed, all instances of C have an empty vtable.</p><h2 id="reference">8. reference</h2><p>http://stackoverflow.com/questions/6258559/what-is-the-vtt-for-a-class http://web.archive.org/web/20120517021435/http://tinydrblog.appspot.com/?p=89001</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vtable </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>algorithm problems 20161202</title>
      <link href="/2016/12/02/algorithm-problems-20161202/"/>
      <url>/2016/12/02/algorithm-problems-20161202/</url>
      
        <content type="html"><![CDATA[<p>1.已知n个人（以编号1，2，3，...，n分别表示）围坐在一张圆桌周围，从编号为k的人开始报数，数到m的那个人出列，他的下一个人又从1开始报数，数到m的那个人出列，依次重复下去，直到圆桌的人全部出列。试用C++编写实现。 <a id="more"></a> 解析：本题就是约瑟夫环问题的实际场景，要通过输入n、m、k三个正整数，求出列的序列。这个问题采用的是典型的循环链表的数据结构，就是将一个链表的尾元素指针指向队首元素：<code>p-&gt;link=head;</code></p><p>解决问题的核心步骤如下：<br />（1）建立一个具有n个链节点、无头节点的循环链表。<br />（2）确定第一个报数人的位置。<br />（3）不断的从链表中删除链节点，直到链表为空。</p><p>code:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">josephus_circle</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//establish circle list</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    ListNode *head = <span class="keyword">new</span> ListNode;</span><br><span class="line">    head-&gt;val = i;</span><br><span class="line">    ++i;</span><br><span class="line">    ListNode *q = head;</span><br><span class="line">    ListNode *tmp;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        tmp = <span class="keyword">new</span> ListNode;</span><br><span class="line">        tmp-&gt;val = i;</span><br><span class="line">        q-&gt;next = tmp;</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    q-&gt;next = head;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;"establish list done!"&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">//determine the kth node</span></span><br><span class="line">    ListNode *kth = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;=k<span class="number">-1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        kth = kth-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//remove nodes</span></span><br><span class="line">    ListNode *delpos = kth;</span><br><span class="line">    ListNode *delpospre = kth;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;"find kth done!"&lt;&lt;endl;</span></span><br><span class="line">    <span class="comment">//cout&lt;&lt;"kth val"&lt;&lt;kth-&gt;val&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;"n="&lt;&lt;n&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m<span class="number">-1</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            delpospre = delpos;</span><br><span class="line">            delpos = delpos-&gt;next;</span><br><span class="line">            <span class="comment">//cout&lt;&lt;"delpospre val"&lt;&lt;delpospre-&gt;val&lt;&lt;endl;</span></span><br><span class="line">            <span class="comment">//cout&lt;&lt;"delpos val"&lt;&lt;delpos-&gt;val&lt;&lt;endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;"for done!"&lt;&lt;endl;</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;delpos-&gt;val&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">        delpospre-&gt;next = delpos-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> delpos;</span><br><span class="line">        delpos = delpos-&gt;next;</span><br><span class="line">        --n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    josephus_circle(<span class="number">9</span>,<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>http://blog.csdn.net/adminabcd/article/details/46664423(校对答案)<br />出自：http://www.cnblogs.com/iuices/archive/2011/11/07/2240325.html</p><p>2.编程实现队列的入队/出队操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    node *next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">front</span>=<span class="title">NULL</span>, *<span class="title">rear</span>=<span class="title">NULL</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    node *tmp = <span class="keyword">new</span> node;</span><br><span class="line">    tmp-&gt;val = val;</span><br><span class="line">    tmp-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(front==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        front = rear = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        rear-&gt;next = tmp;</span><br><span class="line">        rear = rear-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dequeue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(front == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"no elements in the queue!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node *tmp = front;</span><br><span class="line">    <span class="keyword">int</span> retval = tmp-&gt;val;</span><br><span class="line">    <span class="keyword">delete</span> tmp;</span><br><span class="line">    front = front-&gt;next;</span><br><span class="line">    <span class="keyword">if</span>(front==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        front = rear = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        enqueue(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; dequeue()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.用两个栈实现一个队列的功能，请用C++实现。</p><p>思路： 用stack p保存输入的数据，当stack q为空时，则把p中的所有数据都压入q中，然后输出q中top的值。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Type int</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Type val)</span></span>;</span><br><span class="line">    <span class="function">Type <span class="title">dequeue</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;Type&gt; p, q;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="built_in">queue</span>::enqueue(Type val)</span><br><span class="line">&#123;</span><br><span class="line">    p.push(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Type <span class="built_in">queue</span>::dequeue()</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"no elements!"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!p.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            q.push(p.top());</span><br><span class="line">            p.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Type retval = q.top();</span><br><span class="line">    q.pop();</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span> q;</span><br><span class="line">    q.dequeue();</span><br><span class="line">    q.enqueue(<span class="number">1</span>);</span><br><span class="line">    q.enqueue(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;q.dequeue()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    q.enqueue(<span class="number">3</span>);</span><br><span class="line">    q.enqueue(<span class="number">4</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;q.dequeue()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;q.dequeue()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;q.dequeue()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>4.给定方法签名：<br />MoveSubArrayToTheEnd(int array[], int numberOfElements, int lengthOfArray)<br />传入一个数组如{1,2,3,4,5,6,7}，将数组前面head的一个子集移到数组末尾end<br />如：input numberOfElements=3，则{1,2,3,4,5,6,7}=&gt;{4,5,6,7,1,2,3}<br />input numberOfElements=5，则{1,2,3,4,5,6,7}=&gt;{6,7,1,2,3,4,5}<br />请不要使用类库函数.</p><p>思路:</p><ol type="1"><li>reverse数组[0, numberOfElements-1]区间的元素</li><li>reverse数组[numberOfElements, length-1]区间的元素</li><li>reverse数组[0,length-1]区间的元素</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(a[low++],a[high--]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MoveSubArrayToTheEnd</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[], <span class="keyword">int</span> numberOfElements, <span class="keyword">int</span> lengthOfArray)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    reverse(<span class="built_in">array</span>,<span class="number">0</span>,numberOfElements<span class="number">-1</span>);</span><br><span class="line">    reverse(<span class="built_in">array</span>,numberOfElements,lengthOfArray<span class="number">-1</span>);</span><br><span class="line">    reverse(<span class="built_in">array</span>,<span class="number">0</span>,lengthOfArray<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_array</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;length;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    print_array(a,<span class="number">7</span>);</span><br><span class="line">    MoveSubArrayToTheEnd(a,<span class="number">5</span>,<span class="number">7</span>);</span><br><span class="line">    print_array(a,<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> data structures and algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stack </tag>
            
            <tag> queue </tag>
            
            <tag> circular linked list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排列与组合</title>
      <link href="/2016/11/24/%E6%8E%92%E5%88%97%E4%B8%8E%E7%BB%84%E5%90%88/"/>
      <url>/2016/11/24/%E6%8E%92%E5%88%97%E4%B8%8E%E7%BB%84%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="排列与组合">排列与组合</h1><h2 id="全排列">1. 全排列</h2><p>求一个全排列函数：<br />如p([a,b,c])输出：[abc],[acb],[bac],[bca],[cba],[cab].</p><a id="more"></a><h3 id="思路1递归">1.1 思路1：递归</h3><ol type="1"><li>以a,b,c为例来说，所有的全排列组合为：<ul><li>以a开头再加上{b,c}的全排列；</li><li>以b开头再加上{a,c}的全排列；</li><li>以c开头再加上{a,b}的全排列；</li></ul></li><li>单个元素的全排列为它本身</li></ol><p>code: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void swap(char *a, char *b)</span><br><span class="line">&#123;</span><br><span class="line">    char temp &#x3D; *b;</span><br><span class="line">    *b &#x3D; *a;</span><br><span class="line">    *a &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void permutation(char *str, int start, int end)</span><br><span class="line">&#123;</span><br><span class="line">    if(start &#x3D;&#x3D; end)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%s\n&quot;, str);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int i;</span><br><span class="line">    for(i &#x3D; start; i&lt;&#x3D; end; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(&amp;str[i],&amp;str[start]);</span><br><span class="line">        permutation(str,start+1,end);</span><br><span class="line">        swap(&amp;str[i],&amp;str[start]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;char *str &#x3D; &quot;abc&quot;;</span><br><span class="line">    char str[] &#x3D; &quot;abc&quot;;</span><br><span class="line">    permutation(str,0,2);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">abc</span><br><span class="line">acb</span><br><span class="line">bac</span><br><span class="line">bca</span><br><span class="line">cba</span><br><span class="line">cab</span><br></pre></td></tr></table></figure></p><p>编写过程中遇到的坑：</p><ol type="1"><li><code>char *str = "abc";</code>与<code>char str[]</code>的区别：<br />它们最根本的区别是在内存中的存储区域不一样，字符数组<code>(char str[])</code>存储在全局数据区或栈区，第二种形式<code>(char *)</code>的字符串存储在常量区。全局数据区和栈区的字符串（也包括其他数据）有读取和写入的权限，而常量区的字符串（也包括其他数据）只有读取权限，没有写入权限。内存权限的不同导致的一个明显结果就是，字符数组在定义后可以读取和修改每个字符，而对于第二种形式的字符串，一旦被定义后就只能读取不能修改，任何对它的赋值都是错误的。在编程过程中如果只涉及到对字符串的读取，那么字符数组和字符串常量都能够满足要求；如果有写入（修改）操作，那么只能使用字符数组，不能使用字符串常量。如果使用<code>char *str</code>会出现"段错误（Segment Fault）"</li><li>交换字符:<br />不能使用^来交换,得转int，转了还得转回来麻烦。</li></ol><p>time complexity:O(N!)</p><h3 id="思路2采用字典序的排序的方法">1.2 思路2：采用字典序的排序的方法</h3><p>思想:<br />对给定的字符集中的字符规定了一个先后关系，在此基础上规定两个全排列的先后是从左到右逐个比较对应的字符的先后。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[例]字符集&#123;1,2,3&#125;,较小的数字较先,这样按字典序生成的全排列是:   </span><br><span class="line">123,132,213,231,312,321</span><br></pre></td></tr></table></figure> 一个全排列可看做一个字符串，字符串可有前缀、后缀。<br />生成给定全排列的下一个排列.所谓一个的下一个就是这一个与下一个之间没有其他的。这就要求这一个与下一个有尽可能长的共同前缀，也即变化限制在尽可能短的后缀上。<br /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[例]839647521是1--9的排列。1—9的排列最前面的是123456789，最后面的987654321，从右向左扫描若都是增的，就到了987654321，也就没有下一个了。否则找出第一次出现下降的位置。</span><br></pre></td></tr></table></figure> 思路：</p><p>一般而言，设P是[1,n]的一个全排列。<br /><span class="math display">\[P=P_1 P_2 \dots P_n=P_1 P_2 \dots P_{j-1} P_j P_{j+1} \dots P_{k-1}P_kP_{k+1} \dots P_n\]</span><br />find: <span class="math display">\[j=max\{i-1|P_{i-1}&lt;P_{i}\}\]</span> <span class="math display">\[k=max\{i|P_i&gt;P_j\}\]</span></p><ol type="1"><li>对换<span class="math inline">\(P_j\)</span>，<span class="math inline">\(P_k\)</span>，</li><li>将<span class="math inline">\(P_{j+1} \dots P_{k-1}P_{j}P_{k+1} \dots P_n\)</span>翻转</li></ol><p><span class="math inline">\(P’= P_1P_2 \dots P_{j-1}P_k P_n \dots P_{k+1} P_j P_{k-1}\dots P_{j+1}\)</span>即P的下一个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">如何得到346987521的下一个</span><br><span class="line">1. 从尾部往前找第一个P(i-1) &lt; P(i)的位置</span><br><span class="line">    4 6 &lt;- 9 &lt;- 8 &lt;- 7 &lt;- 5 &lt;- 2 &lt;- 1</span><br><span class="line">最终找到6是第一个变小的数字，记录下6的位置i-1</span><br><span class="line">2.从i位置往后找到最后一个大于6的数</span><br><span class="line">    4 6 -&gt; 9 -&gt; 8 -&gt; 7 5 2 1</span><br><span class="line">最终找到7的位置，记录位置为k</span><br><span class="line">3.交换位置i-1和k的值</span><br><span class="line">    4 7 9 8 6 5 2 1</span><br><span class="line">4. 倒序i位置后的所有数据</span><br><span class="line">    4 7 1 2 5 6 8 9</span><br><span class="line">则347125689为346987521的下一个排列</span><br></pre></td></tr></table></figure><p>code <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">void swap(char *a, char *b)</span><br><span class="line">&#123;</span><br><span class="line">    char temp &#x3D; *b;</span><br><span class="line">    *b &#x3D; *a;</span><br><span class="line">    *a &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void permutation(char *str, int start, int end)</span><br><span class="line">&#123;</span><br><span class="line">    if(start &#x3D;&#x3D; end)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%s\n&quot;, str);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    int i;</span><br><span class="line">    for(i &#x3D; start; i&lt;&#x3D; end; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(&amp;str[i],&amp;str[start]);</span><br><span class="line">        permutation(str,start+1,end);</span><br><span class="line">        swap(&amp;str[i],&amp;str[start]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void reverse(char *str, int start, int end)</span><br><span class="line">&#123;</span><br><span class="line">    while(start&lt;&#x3D;end)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(&amp;str[start],&amp;str[end]);</span><br><span class="line">        ++start;</span><br><span class="line">        --end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void permutation_dict(char *str)</span><br><span class="line">&#123;</span><br><span class="line">    int end &#x3D; strlen(str)-1;</span><br><span class="line">    int i,j,m;</span><br><span class="line">    while(1)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%s\n&quot;,str);</span><br><span class="line">        for(i &#x3D; end; i&gt;0; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            if(str[i-1]&lt;str[i])</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i&#x3D;&#x3D;0)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;全部都已经找完</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        for(j &#x3D; end; j &gt;&#x3D; i; --j)</span><br><span class="line">        &#123;</span><br><span class="line">            if(str[j]&gt;str[i-1])</span><br><span class="line">            &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(&amp;str[i-1],&amp;str[j]);</span><br><span class="line">        reverse(str,i,end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;char *str &#x3D; &quot;abc&quot;;</span><br><span class="line">    char str[] &#x3D; &quot;abc&quot;;</span><br><span class="line">    &#x2F;&#x2F;permutation(str,0,2);</span><br><span class="line">    permutation_dict(str);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">abc</span><br><span class="line">acb</span><br><span class="line">bac</span><br><span class="line">bca</span><br><span class="line">cab</span><br><span class="line">cba</span><br></pre></td></tr></table></figure></p><h2 id="n个元素选择m个进行排列">2. n个元素选择m个进行排列</h2><p>abc-&gt; ab,ba,bc,cb,ac,ca 相比于全排列，递归边界是已经排列到m个元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">void swap(char *a, char *b)</span><br><span class="line">&#123;</span><br><span class="line">    char temp &#x3D; *b;</span><br><span class="line">    *b &#x3D; *a;</span><br><span class="line">    *a &#x3D; temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void permutation(char *str, int start, int end,int m)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 排列到m个字符时</span><br><span class="line">    if(start &#x3D;&#x3D; m)</span><br><span class="line">    &#123;</span><br><span class="line">        int j;</span><br><span class="line">        for(j &#x3D; 0;j &lt; m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;%c&quot;, *(str+j));</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\n&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    int i;</span><br><span class="line">    for(i &#x3D; start; i&lt;&#x3D; end; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(&amp;str[i],&amp;str[start]);</span><br><span class="line">        permutation(str,start+1,end,m);</span><br><span class="line">        swap(&amp;str[i],&amp;str[start]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;char *str &#x3D; &quot;abc&quot;;</span><br><span class="line">    char str[] &#x3D; &quot;abcd&quot;;</span><br><span class="line">    permutation(str,0,3,2);</span><br><span class="line">    &#x2F;&#x2F;permutation_dict(str);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">ab</span><br><span class="line">ac</span><br><span class="line">ad</span><br><span class="line">ba</span><br><span class="line">bc</span><br><span class="line">bd</span><br><span class="line">cb</span><br><span class="line">ca</span><br><span class="line">cd</span><br><span class="line">db</span><br><span class="line">dc</span><br><span class="line">da</span><br></pre></td></tr></table></figure><h2 id="全组合">3. 全组合</h2><p>求一个全排列函数：<br />如p([a,b,c])输出：[a],[b],[c],[ab],[ac],[bc].</p><h3 id="思路">3.1 思路</h3><p>全组合是一个集合的非空子集，有<span class="math inline">\(2^n-1\)</span>个，可以用二进制映射。 比如1-&gt;001-&gt;c; 2-&gt;010-&gt;b;3-&gt;011-&gt;bc;4-&gt;100-&gt;a;5-&gt;101-&gt;ac;6-&gt;110-&gt;ab;7-&gt;111-&gt;abc;</p><p>code: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void combination(char *str)</span><br><span class="line">&#123;</span><br><span class="line">    int len &#x3D; strlen(str);</span><br><span class="line">    int num &#x3D; 1&lt;&lt;len;</span><br><span class="line">    for(int i &#x3D; 1; i&lt;num; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        int k&#x3D;i;</span><br><span class="line">        int j&#x3D;0;</span><br><span class="line">        while(k!&#x3D;0)</span><br><span class="line">        &#123;</span><br><span class="line">            int flag &#x3D; k &amp; 1;</span><br><span class="line">            if(flag)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;str[j];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            k &#x3D; k&gt;&gt;1;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    char str[]&#x3D; &quot;abc&quot;;</span><br><span class="line">    combination(str);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">ab</span><br><span class="line">c</span><br><span class="line">ac</span><br><span class="line">bc</span><br><span class="line">abc</span><br></pre></td></tr></table></figure> ### 3.2 递归法</p><h2 id="n个元素选择m个进行组合">4. n个元素选择m个进行组合</h2><p>reference:<br />http://www.cnblogs.com/biyeymyhjob/archive/2012/07/13/2589738.html<br />https://segmentfault.com/a/1190000002710424#articleHeader5<br />http://wuchong.me/blog/2014/07/28/permutation-and-combination-realize/<br />http://www.cnblogs.com/pmars/p/3458289.html http://www.aichengxu.com/view/24579702 http://blog.csdn.net/w57w57w57/article/details/6657547 http://www.cnblogs.com/TenosDoIt/p/3451902.html</p>]]></content>
      
      
      <categories>
          
          <category> data structures and algorithms </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>zombie process</title>
      <link href="/2016/11/23/zombie-process/"/>
      <url>/2016/11/23/zombie-process/</url>
      
        <content type="html"><![CDATA[<h2 id="僵尸进程">僵尸进程</h2><p>子进程已结束，但父进程未调用wait()函数等待</p><ul><li>子进程已终止，但没有被正确清除，成为僵尸进程</li></ul><p>清除子进程的手段</p><ul><li>父进程调用wait()函数可确保子进程被清除</li><li>即使子进程在父进程调用wait()函数前已死亡（成为僵尸），其退出状态也可以被抽取出来，然后被清除</li><li>未清除的子进程自动被init进程收养</li><li>SIGCHLD信号: 子进程终止时，向父进程自动发送，编写此信号处理例程，异步清除子进程</li></ul><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;wait.h&gt;</span><br><span class="line">sig_atomic_t child_exit_status;</span><br><span class="line">extern &quot;C&quot;</span><br><span class="line">&#123;</span><br><span class="line">    void CleanUp( int sig_num )</span><br><span class="line">    &#123;</span><br><span class="line">        int status;</span><br><span class="line">        wait( &amp;status ); &#x2F;&#x2F; 清除子进程</span><br><span class="line">        child_exit_status &#x3D; status; &#x2F;&#x2F; 存储子进程的状态</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 处理SIGCHLD信号</span><br><span class="line">    struct sigaction sa;</span><br><span class="line">    memset(&amp;sa, 0, sizeof(sa));</span><br><span class="line">    sa.sa_handler &#x3D; &amp;CleanUp;</span><br><span class="line">    sigaction(SIGCHLD, &amp;sa, NULL);</span><br><span class="line">    &#x2F;&#x2F; 正常处理代码在此，例如调用fork()创建子进程</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## fork</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    pid_t child_pid;</span><br><span class="line">    child_pid &#x3D; fork();</span><br><span class="line">    </span><br><span class="line">    printf(&quot;in main:%d\n&quot;, getpid());</span><br><span class="line">    if(child_pid &#x3D;&#x3D; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;child_pid:%d\n&quot;,child_pid);</span><br><span class="line">        printf(&quot;in child, getpid:%d\n&quot;,getpid());</span><br><span class="line">        printf(&quot;in child, getppid:%d\n&quot;,getppid());</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    else if(child_pid&gt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        printf(&quot;in parent, getpid:%d\n&quot;,getpid());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">in main:3659</span><br><span class="line">in parent, getpid:3659</span><br><span class="line">in main:3660</span><br><span class="line">child_pid:0</span><br><span class="line">in child, getpid:3660</span><br><span class="line">in child, getppid:3964</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yanruibo@yanruibo-PC:~&#x2F;self-learning&#x2F;hexo-blog&#x2F;blog-code$ ps -e|grep 3964</span><br><span class="line"> 3964 ?        00:00:00 init</span><br></pre></td></tr></table></figure><p>父进程没有调用wait，子进程被init进程收养了。<br />下面是调用wait的情况:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    pid_t child_pid;</span><br><span class="line">    child_pid &#x3D; fork();</span><br><span class="line">    </span><br><span class="line">    printf(&quot;in main:%d\n&quot;, getpid());</span><br><span class="line">    if(child_pid &#x3D;&#x3D; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;child_pid:%d\n&quot;,child_pid);</span><br><span class="line">        printf(&quot;in child, getpid:%d\n&quot;,getpid());</span><br><span class="line">        printf(&quot;in child, getppid:%d\n&quot;,getppid());</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    else if(child_pid&gt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        printf(&quot;in parent, getpid:%d\n&quot;,getpid());</span><br><span class="line">        int status;</span><br><span class="line">        wait(&amp;status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">in main:5336</span><br><span class="line">in parent, getpid:5336</span><br><span class="line">in main:5337</span><br><span class="line">child_pid:0</span><br><span class="line">in child, getpid:5337</span><br><span class="line">in child, getppid:5336</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zombie process </tag>
            
            <tag> fork </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>inter-process-communication</title>
      <link href="/2016/11/22/inter-process-communication/"/>
      <url>/2016/11/22/inter-process-communication/</url>
      
        <content type="html"><![CDATA[<h1 id="进程间通信">进程间通信</h1><h2 id="进程间通信的所有方式">1. 进程间通信的所有方式</h2><ol type="1"><li><font color="#FF7F50">管道(pipe)及有名管道(named pipe, FIFO)</font>:管道可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；</li><li><font color="#FF7F50">信号(signal)</font>:信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身。</li><li><font color="#FF7F50">进程信号量</font>:进程间通信的同步控制机制，主要作为进程间以及同一进程不同线程之间的同步手段。</li><li><font color="#FF7F50">共享内存以及映射内存</font>:共享内存是允许多个进程读写同一片内存区域，使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥；映射内存与共享内存的意义相同，但与文件相关联。</li><li><font color="#FF7F50">消息队列</font>:在进程间传递二进制块数据，消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。</li><li><font color="#FF7F50">套接字</font>:支持无关进程，甚至不同的计算机进行通信(网络进程间通讯，network IPC)</li></ol><a id="more"></a><p>Unix系统所提供的经典的进程间的通讯机制(IPC)有:管道，FIFO，消息队列，信号量，以及共享储存。这些机制允许在同一台计算机上运行的进程可以相互通讯，量外还有不同计算机(通过网络相连)上的进程相互通信的机制:网络进程间通信(network IPC).</p><h2 id="管道">2. 管道</h2><p>管道分为匿名管道和命名管道(named pipe, FIFO).</p><h3 id="匿名管道">2.1 匿名管道</h3><p>一般说管道就是指的匿名管道。</p><h4 id="管道的性质与意义">管道的性质与意义</h4><ul><li>管道是允许单向通信的自动同步设备(半双工)</li><li>数据在写入端写入，在读取端读取</li><li>管道为串行设备，数据的读取顺序与写入顺序完全相同</li></ul><h4 id="管道的用途">管道的用途</h4><ul><li>只能用于有亲缘关系的进程，例如父进程与子进程之间的通信</li></ul><p>注意事项</p><ul><li>管道的数据容量有限，一般为一个内存页面</li><li>如果写入速度超过读取速度，写入进程将阻塞，直到容量有空闲</li><li>如果读取速度超过写入速度，读取进程将阻塞，直到逛到有数据</li></ul><h4 id="pip函数创建管道">pip函数:创建管道</h4><ul><li>头文件:"unistd.h"和"fcntl.h"</li><li>原型:<code>int pipe(int pipefd[2]);</code></li><li>参数:一个包含两个元素的整数数组，元素类型为文件描述符，0号元为读取文件描述符，1号元为写入文件描述符</li><li>返回值:成功时返回0，不成功时返回-1，并设置errno值。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int pipe_fds[2];</span><br><span class="line">int read_fd;</span><br><span class="line">int write_fd;</span><br><span class="line">pip(pipe_fds);</span><br><span class="line">read_fd &#x3D; pipe_fds[0];</span><br><span class="line">write_df &#x3D; pipe_fds[1];</span><br></pre></td></tr></table></figure></li></ul><h4 id="从管道中读取数据">从管道中读取数据</h4><ul><li>如果管道的写端不存在，则认为已经读到了数据的末尾，读函数返回的读出字节数为0</li><li>当管道的写端存在时，如果请求的字节数目大于PIPE_BUF，则返回管道中现有的字节数；如果请求的字节数目不大于PIPE_BUF，则返回管道中现有的字节数(管道中数据量小于请求的数据量)或者返回请求的字节数(管道中数据量不小于请求的数据量)。</li></ul><h4 id="向管道中写入数据">向管道中写入数据</h4><ul><li>向管道中写入数据时，linux将不保证写入的原子性，管道缓冲区一有空闲区域，写进程就会试图向管道写入数据。如果读进程不读走管道缓冲区中的数据，那么写操作将一直阻塞。</li></ul><p>注:只有在管道的读端存在时，向管道中写入数据才有意义。否则，向管道中写入数据的进程将收到内核传来的SIFPIPE信号，应用程序可以处理该信号，也可以忽略（默认动作则是应用程序终止）。</p><h4 id="管道通信example">管道通信example</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;pipe.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">const int buf_size &#x3D; 4096;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;向stream中写入count次msg</span><br><span class="line">void write_stream(const char *msg, int count, FILE *stream)</span><br><span class="line">&#123;</span><br><span class="line">    for(;count&gt;0;--count)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stream,&quot;%s\n&quot;,msg);</span><br><span class="line">        fflush(stream);</span><br><span class="line">        sleep(1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;从stream中读取数据</span><br><span class="line">void read_stream(FILE *stream)</span><br><span class="line">&#123;</span><br><span class="line">    char buf[buf_size];</span><br><span class="line">    &#x2F;&#x2F;一直读取到流的尾部</span><br><span class="line">    while(!feof(stream) &amp;&amp; !ferror(stream) &amp;&amp; fgets(buf,sizeof(buf),stream)!&#x3D;NULL)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stdout,&quot;Data received:\n&quot;);</span><br><span class="line">        fputs(buf,stdout);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int fds[2];</span><br><span class="line">    pipe(fds);&#x2F;&#x2F;创建管道</span><br><span class="line">    pid_t pid &#x3D; fork();&#x2F;&#x2F;创建子进程</span><br><span class="line">    if(pid&#x3D;&#x3D;0)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;child process</span><br><span class="line">        close(fds[1]);&#x2F;&#x2F;只读取，关闭管道写入端</span><br><span class="line">        &#x2F;&#x2F;将文件描述符转换为FILE *，以便C&#x2F;C++标准库函数处理</span><br><span class="line">        FILE *stream &#x3D; fdopen(fds[0],&quot;r&quot;);</span><br><span class="line">        read_stream(stream);</span><br><span class="line">    &#125;</span><br><span class="line">    else if(pid&gt;0)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;parent process</span><br><span class="line">        char buf[buf_size];</span><br><span class="line">        &#x2F;&#x2F;数据缓冲区末尾封装两个&#39;\0&#39;</span><br><span class="line">        int i;</span><br><span class="line">        for(i &#x3D; 0; i&lt;26;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            buf[i]&#x3D;&#39;A&#39;+i;</span><br><span class="line">        &#125;</span><br><span class="line">        buf[i] &#x3D; buf[i] &#x3D; &#39;\0&#39;;</span><br><span class="line">        close(fds[0]);&#x2F;&#x2F;只写入关闭管道读取端</span><br><span class="line">        FILE *stream &#x3D; fdopen(fds[1],&quot;w&quot;);</span><br><span class="line">        write_stream(buf,3,stream);</span><br><span class="line">        close(fds[1]);&#x2F;&#x2F;关闭管道写入端</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">yanruibo@yanruibo-PC:~&#x2F;self-learning&#x2F;hexo-blog&#x2F;blog-code$ gcc pipe.c</span><br><span class="line">yanruibo@yanruibo-PC:~&#x2F;self-learning&#x2F;hexo-blog&#x2F;blog-code$ .&#x2F;a.out</span><br><span class="line">Data received:</span><br><span class="line">ABCDEFGHIJKLMNOPQRSTUVWXYZ</span><br><span class="line">Data received:</span><br><span class="line">ABCDEFGHIJKLMNOPQRSTUVWXYZ</span><br><span class="line">Data received:</span><br><span class="line">ABCDEFGHIJKLMNOPQRSTUVWXYZ</span><br></pre></td></tr></table></figure><h4 id="管道重定向">管道重定向</h4><ul><li>共享相同的文件位置和状态标志设置</li></ul><p>dup()函数:将两个文件描述符等位处理</p><ul><li>原型:<code>int dup(int oldfd); int dup2(int oldfd, int newfd);</code></li><li>参数:创建oldfd的一份拷贝，单参数版本选择数值最小的未用文件描述符作为新的文件描述符；双参数版本使用newfd作为新的文件描述符，拷贝前尝试关闭newfd。</li><li>返回值:成功时返回新文件描述符，失败时返回-1，并设errno值</li><li>示例:dup2(fd,STDIN_FILENO),关闭标准输入流，然后作为fd的副本重新打开。dup2函数成功返回时，目标描述符(dup2函数的第二个参数)将变成源描述符(dup2函数的第一个参数)的复制品。换句话说两个文件描述符现在都指向同一个文件，而且是函数的第一个参数指向的文件。</li></ul><p>管道重定向example <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;wait.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line"></span><br><span class="line">const int buf_size &#x3D; 4096;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int fds[2];</span><br><span class="line">    pipe(fds);&#x2F;&#x2F;创建管道</span><br><span class="line">    pid_t pid &#x3D; fork();</span><br><span class="line">    if(pid &#x3D;&#x3D; 0)&#x2F;&#x2F;子进程</span><br><span class="line">    &#123;</span><br><span class="line">        close(fds[0]);&#x2F;&#x2F;关闭管道读取端</span><br><span class="line">        dup2(fds[1],STDOUT_FILENO);&#x2F;&#x2F;管道挂接到标准输出流</span><br><span class="line">        char *args[] &#x3D; &#123;&quot;ls&quot;,&quot;-l&quot;,&quot;&#x2F;&quot;,NULL&#125;;</span><br><span class="line">        execvp(args[0],args);</span><br><span class="line">    &#125;</span><br><span class="line">    else if(pid&gt;0)&#x2F;&#x2F;父进程</span><br><span class="line">    &#123;</span><br><span class="line">        close(fds[1]);&#x2F;&#x2F;关闭管道写入端</span><br><span class="line">        char buf[buf_size];</span><br><span class="line">        FILE *stream &#x3D; fdopen(fds[0],&quot;r&quot;);&#x2F;&#x2F;以读模式打开管道读取端，返回文件指针</span><br><span class="line">        fprintf(stdout, &quot;Data received\n&quot;);</span><br><span class="line">        &#x2F;&#x2F;在流未结束，未发生读取错误，且能从流中正常读取字符串时，输出读取到的字符串</span><br><span class="line">        while (!feof(stream) &amp;&amp; !ferror(stream) &amp;&amp; fgets(buf,sizeof(buf),stream)!&#x3D;NULL) &#123;</span><br><span class="line">            fputs(buf,stdout);</span><br><span class="line">        &#125;</span><br><span class="line">        close(fds[0]);&#x2F;&#x2F;关闭管道读取端</span><br><span class="line">        waitpid(pid,NULL,0);&#x2F;&#x2F;等待子进程结束</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">Data received</span><br><span class="line">total 104</span><br><span class="line">drwxr-xr-x   2 root root  4096 Nov 22 09:36 bin</span><br><span class="line">drwxr-xr-x   4 root root  4096 Sep 20 19:10 boot</span><br><span class="line">drwxrwxr-x   2 root root  4096 Sep 25  2015 cdrom</span><br><span class="line">drwxr-xr-x  18 root root  4740 Nov 22 15:15 dev</span><br><span class="line">drwxr-xr-x 155 root root 12288 Nov 22 15:15 etc</span><br><span class="line">drwxr-xr-x   4 root root  4096 Aug  5 11:21 home</span><br></pre></td></tr></table></figure></p><p>管道是Unix系统IPC的最古老的形式，所有Unix系统都提供此种通讯机制。管道有以下两种局限性。</p><ul><li>历史上它们是半双工的，即数据只能在一个方向上流动。现在，某些系统提供全双工管道，但是为了可移植性，我们决不应该预先假定系统支持全双工管道。</li><li>管道只能在具有公共祖先的两个进程之间使用。通常，一个管道由一个进程创建，在进程调用fork之后，这个管道就能在父进程和子进程之间使用了。</li><li>没有名字</li><li>管道的缓冲区是有限的(管道存在于内存中，在管道创建时，为缓存区分配一个页面大小)</li><li>管道传送的是无格式的字节流，这就要求管道的读取方和写入方必须事先约定好格式，比如多少个字节算作一个消息(命令或记录等)。</li></ul><h3 id="fifo">2.2 FIFO</h3><p>管道应用的一个重大限制是它没有名字，因此，只能用于具有亲缘关系的进程间通信，在有名管道（named pipe或FIFO）提出后，该限制得到了克服。FIFO不同于管道之处在于它提供一个路径名与之关联，以FIFO的文件形式存在于文件系统中。这样，即使与FIFO的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过FIFO相互通信（能够访问该路径的进程以及FIFO的创建进程之间），因此，通过FIFO不相关的进程也能交换数据。值得注意的是，FIFO严格遵循先进先出（first in first out），对管道及FIFO的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。</p><h4 id="有名管道的创建">有名管道的创建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line">int mkfifo(const char * pathname, mode_t mode)</span><br></pre></td></tr></table></figure><p>该函数的第一个参数是一个普通的路径名，也就是创建后FIFO的名字。第二个参数与打开普通文件的open()函数中的mode 参数相同。 如果mkfifo的第一个参数是一个已经存在的路径名时，会返回EEXIST错误，所以一般典型的调用代码首先会检查是否返回该错误，如果确实返回该错误，那么只要调用打开FIFO的函数就可以了。一般文件的I/O函数都可以用于FIFO，如close、read、write等等。</p><h4 id="有名管道的打开规则">有名管道的打开规则</h4><p>有名管道比管道多了一个打开操作:open。 FIFO的打开规则:</p><ul><li>如果当前打开操作是为读而打开FIFO时，若已经有相应进程为写而打开该FIFO，则当前打开操作将成功返回；否则，可能阻塞直到有相应进程为写而打开该FIFO（当前打开操作设置了阻塞标志）；或者，成功返回（当前打开操作没有设置阻塞标志）。</li><li>如果当前打开操作是为写而打开FIFO时，如果已经有相应进程为读而打开该FIFO，则当前打开操作将成功返回；否则，可能阻塞直到有相应进程为读而打开该FIFO（当前打开操作设置了阻塞标志）；或者，返回ENXIO错误（当前打开操作没有设置阻塞标志）。</li></ul><h4 id="有名管道的读写规则">有名管道的读写规则</h4><p>从FIFO中读取数据 约定:如果一个进程为了从FIFO中读取数据而阻塞打开FIFO，那么称该进程内的读操作为设置了阻塞标志的读操作。 - 如果有进程写打开FIFO，且当前FIFO内没有数据，则对于设置了阻塞标志的读操作来说，将一直阻塞。对于没有设置阻塞标志读操作来说则返回-1，当前errno值为EAGAIN，提醒以后再试。 - 对于设置了阻塞标志的读操作说，造成阻塞的原因有两种：当前FIFO内有数据，但有其它进程在读这些数据；另外就是FIFO内没有数据。解阻塞的原因则是FIFO中有新的数据写入，不论信写入数据量的大小，也不论读操作请求多少数据量。 - 读打开的阻塞标志只对本进程第一个读操作施加作用，如果本进程内有多个读操作序列，则在第一个读操作被唤醒并完成读操作后，其它将要执行的读操作将不再阻塞，即使在执行读操作时，FIFO中没有数据也一样（此时，读操作返回0）。 - 如果没有进程写打开FIFO，则设置了阻塞标志的读操作会阻塞。</p><p>注:如果FIFO中有数据，则设置了阻塞标志的读操作不会因为FIFO中的字节数小于请求读的字节数而阻塞，此时，读操作会返回FIFO中现有的数据量。</p><p>向FIFO中写入数据:</p><p>约定:如果一个进程为了向FIFO中写入数据而阻塞打开FIFO，那么称该进程内的写操作为设置了阻塞标志的写操作。</p><p>对于设置了阻塞标志的写操作:</p><ul><li>当要写入的数据量不大于PIPE_BUF时，linux将保证写入的原子性。如果此时管道空闲缓冲区不足以容纳要写入的字节数，则进入睡眠，直到当缓冲区中能够容纳要写入的字节数时，才开始进行一次性写操作。</li><li>当要写入的数据量大于PIPE_BUF时，linux将不再保证写入的原子性。FIFO缓冲区一有空闲区域，写进程就会试图向管道写入数据，写操作在写完所有请求写的数据后返回。</li></ul><p>对于没有设置阻塞标志的写操作:</p><ul><li>当要写入的数据量大于PIPE_BUF时，linux将不再保证写入的原子性。在写满所有FIFO空闲缓冲区后，写操作返回。</li><li>当要写入的数据量不大于PIPE_BUF时，linux将保证写入的原子性。如果当前FIFO空闲缓冲区能够容纳请求写入的字节数，写完后成功返回；如果当前FIFO空闲缓冲区不能够容纳请求写入的字节数，则返回EAGAIN错误，提醒以后再写。</li></ul><p>不管写打开的阻塞标志是否设置，在请求写入的字节数大于PIPE_BUF时，都不保证写入的原子性。但二者有本质区别:<br />对于阻塞写来说，写操作在写满FIFO的空闲区域后，会一直等待，直到写完所有数据为止，请求写入的数据最终都会写入FIFO；而非阻塞写则在写满FIFO的空闲区域后，就返回(实际写入的字节数)，所以有些数据最终不能够写入。</p><h2 id="信号">3. 信号</h2><p>信号:进程通讯机制</p><ul><li>信号是发给进程的特殊异步消息</li><li>当进程接受到信息时立即处理，此时并不需要完成当前函数调用甚至代码行</li></ul><p>系统信号</p><ul><li>缺省处理逻辑:终止进程，生成内核转储文件</li><li>使用<code>kill -l</code>可查看操作系统支持的信号列表，不同的系统可能有所不同</li></ul><p>信号处理</p><ul><li>SIGTERM，SIGKILL:终止进程信号，前者是请求（接收信号的进程可以忽略之），后者是强制</li><li>SIGUSR1，SIGUSR2:用户自定义信号，可用于向进程发送命令。</li></ul><p>处理信号时的注意事项</p><ul><li>信号是异步操作，当处理信号时，主程序非常脆弱</li><li>信号处理例程应尽可能短小，它甚至有可能会被新信号所中断</li><li>尽量不要在信号处理例程中实施IO操作，也不要频繁的调用系统函数或库函数</li><li>在信号处理例程中进行复杂的赋值操作也是危险的，它可能不是原子操作，因而有可能在执行期间被中断</li><li>如果需要赋值，使用sig_atomic_t类型的全局变量（在Linux中等价于int，亦即允许整数或者指针赋值，不允许更大尺寸数据赋值）</li></ul><h2 id="进程信号量">4. 进程信号量</h2><p>进程信号量: System V信号量</p><ul><li>可以使用同步机制确定进程的先后执行关系</li><li>头文件:<code>sys/types.h, sys/ipc.h, sys/sem.h</code></li></ul><p>信号量的定义:</p><ul><li>信号量是一类特殊的计数器，其值为非负整数，用于进程或线程同步</li></ul><p>信号量的操作</p><ul><li>等待(wait)操作(P): 信号量的值递减1后返回，如果值为0，则为阻塞操作，直到信号量值为正（其他进程或线程释放了信号量），然后递减1后返回</li><li>发布(post)操作(V): 信号量的值递增1后返回；如果信号量的值为0，则其中一个等待该信号量的进程或线程将取消阻塞。</li></ul><p>Linux信号量实现: 两个版本</p><ul><li>进程信号量多用于进程同步，POSIX标准实现多用于线程同步</li></ul><p>使用进程信号量时的注意事项</p><ul><li>每次创建和管理的进程信号量不是一个，而是一个集合（数组），该集合包含多个进程信号量</li><li>使用键值key关联进程信号量集，但进程信号量集本身由进程信号量的标识符semid标识，函数调用时几乎总是使用semid——可以这么理解: semid对内，key对外。</li></ul><p>semget()函数：创建或获取进程信号量集</p><ul><li>原型：<code>int semget(key_t key, int nsems, int semflg);</code></li><li>参数：key为键值，多个进程可以通过此键值访问同一进程信号量；nsems为需要创建的进程信号量集的进程信号量元素个数（不是进程信号量的信号数）， semflg为访问标志</li><li>返回值：成功时返回进程信号量集的标识符，失败时返回-1，并设置errno值</li><li>要获取已分配的进程信号量集，使用原先键值查询，此时进程信号量集的元素个数可设置为0</li><li>键值IPC_PRIVATE用于创建当前进程的私有进程信号量集</li><li>使用IPC_CREAT和IPC_EXCL创建进程信号量集，后者要求创建新的唯一的进程信号量集，若其已存在，则出错</li></ul><p>控制和管理进程信号量集</p><ul><li>原型：int semctl( int semid, int semnum, int cmd, … );</li><li>参数：semid为进程信号量集的标识符，semnum为进程信号量集的元素下标，cmd为指定操作，第四个参数arg可有可 无，与cmd有关</li><li>返回值：成功时与cmd有关，失败时返回-1，并设置errno值</li><li>调用semctl()函数的进程的有效用户ID必须与分配进程信号量集的用户权限匹配</li></ul><p>释放（删除）进程信号量集：IPC_RMID</p><ul><li>最后一个使用进程信号量的进程负责清除进程信号量集</li><li>进程信号量集释放后，内存自动释放</li><li>调用说明：cmd为IPC_RMID，semnum被忽略，arg不需要；如果需要arg，定义union semun类型的变量并作为参数，部分系统可能未定义union semun类型，需按如下格式补充定义： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">union semun</span><br><span class="line">&#123;</span><br><span class="line">    int val; &#x2F;&#x2F; 供SETVAL使用的值</span><br><span class="line">    struct semid_ds *buf; &#x2F;&#x2F; 供IPC_STAT、 IPC_SET使用的缓冲区</span><br><span class="line">    unsigned short int *array; &#x2F;&#x2F; 供GETALL、 SETALL使用的数组</span><br><span class="line">    struct seminfo *__buf; &#x2F;&#x2F; 供IPC_INFO使用的缓冲区</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>初始化进程信号量集：SETALL</p><ul><li>第一个参数semid为进程信号量集的标识符，第二个参数semnum为0，第三个参数cmd为SETALL，第四个参数arg 必须为union semun类型的数据对象</li><li>union semun的array字段：指向无符号短整型数组首元素的指针，该数组保存进程信号量集的所有信号量的信号数 其他常用命令参数</li><li>IPC_STAT/IPC_SET（获取或设置进程信号量信息）、GETALL（获取全部信号量的信号数）、 GETVAL/SETVAL （获取或设置单个信号量的信号数）等</li></ul><p>获取与释放 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取与key关联的二元信号量集，必要时会分配之</span><br><span class="line">int AcquireBinarySemaphore(key_t key, int sem_flags)</span><br><span class="line">&#123;</span><br><span class="line">    return semget(key, 1, sem_flags);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 释放二元信号量集，单一元素</span><br><span class="line">int ReleaseBinarySemaphore(int semid)</span><br><span class="line">&#123;</span><br><span class="line">    union semun ignored;</span><br><span class="line">    return semctl(semid, 1, IPC_RMID, ignored);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 初始化二元信号量集，单一元素，信号量初始值为1</span><br><span class="line">int InitializeBinarySemaphore(int semid)</span><br><span class="line">&#123;</span><br><span class="line">    unsigned short int values[1] &#x3D; &#123; 1 &#125;;</span><br><span class="line">    union semun needed &#x3D; &#123; .array &#x3D; values &#125;;</span><br><span class="line">    return semctl(semid, 0, SETALL, needed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>等待与发布进程信号量函数semop()</p><ul><li>原型：int semop(int semid, struct sembuf *sops, size_t nsops);</li><li>参数：semid为待操作的进程信号量集的标识符；sops为操作数组，nsops为操作数组的元素个数</li><li>返回值：成功时为进程信号量集的标识符，失败时返回-1，并设置errno值</li></ul><p>struct sembuf类型的成员</p><ul><li>sem_num：需要操作的进程信号量集中的信号量元素下标</li><li>sem_op：指定信号量操作的整数（递增或递减信号量的信号数）<ul><li>如果sem_op为正数，则立即加到信号量上（V操作）</li><li>如果sem_op为负数，则从信号量上减去（P操作）</li><li>如果会使结果为负数，则阻塞进程，直到信号量的信号数不小于sem_op的绝对值</li><li>如果sem_op为0，则阻塞进程，直到信号量的信号数为0</li></ul></li><li>sem_flg：指定IPC_NOWAIT则不阻塞进程，指定SEM_UNDO则在进程退出时取消操作</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; P原语：等待二元信号量，信号数非正时阻塞</span><br><span class="line">int WaitBinarySemaphore(int semid)</span><br><span class="line">&#123;</span><br><span class="line">    struct sembuf ops[1];</span><br><span class="line">    ops[0].sem_num &#x3D; 0;</span><br><span class="line">    ops[0].sem_op &#x3D; -1;</span><br><span class="line">    ops[0].sem_flg &#x3D; SEM_UNDO;</span><br><span class="line">    return semop(semid, ops, 1);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; V原语：发布二元信号量，增加信号数后立即返回</span><br><span class="line">int PostBinarySemaphore(int semid)</span><br><span class="line">&#123;</span><br><span class="line">    struct sembuf ops[1];</span><br><span class="line">    ops[0].sem_num &#x3D; 0;</span><br><span class="line">    ops[0].sem_op &#x3D; 1;</span><br><span class="line">    ops[0].sem_flg &#x3D; SEM_UNDO;</span><br><span class="line">    return semop(semid, ops, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="共享内存以及映射内存">5. 共享内存以及映射内存</h2><h3 id="共享内存">共享内存</h3><p>共享内存的意义: 快捷方便的本地通信机制</p><ul><li>头文件: <code>sys/ipc.h, sys/shm.h</code></li></ul><p>共享内存编程原则</p><ul><li>系统没有对共享内存操作提供任何缺省同步行为</li><li>如果需要，程序员自主设计同步策略:使用进程信号量</li></ul><p>共享内存使用过程</p><ul><li>某个进程分配一个内存段，其他需要访问该内存段的进程连接（attach）该内存段</li><li>完成访问后，进程拆卸（detach）该内存段</li><li>某个时刻，一个进程释放该内存段</li></ul><p>Linux内存模型</p><ul><li>每个进程的虚拟地址空间按页编址，页缺省为4096字节（不同硬件架构和操作系统可能不同，使用getpagesize()函数获取系统值）</li><li>每个进程维持从内存地址到虚拟页面地址的映射</li><li>多个进程可能使用同一虚拟页面，同样的数据在不同进程中的地址并不需要相同</li><li>分配新的共享内存段将创建虚拟内存页面，其他进程连接该共享内存段即可访问。</li><li>共享内存段的分配只有由一个进程负责，释放也同样</li></ul><p>获取共享内存<br />shmget()函数:获取或分配一段共享内存 - 原型: <code>int shmget(key_t key, size_t size, nt shmflg);</code> - 参数: key为内存段整数键值，size为内存段分配的字节数，shmflg为创建共享内存段的位标志</p><p>键值参数key</p><ul><li>其他进程通过键值key访问该内存段，任意设定的键值可能和其他进程的共享内存段键值冲突，使用IPC_PRIVATE以确保无冲突。</li></ul><p>创建标志: IPC_CREAT（创建），IPC_EXCL（独占）</p><ul><li>后者与前者合并使用，如果键值已使用，则创建失败</li><li>如果未设IPC_EXCL，则在键值已经存在时，返回其代表的共享内存段，而不是创建一个新的共享内存段。</li></ul><p>位标志参数</p><ul><li>模式标志: 以9位数字表示宿主，组用户，和其他人的访问控制权</li><li>常数位于头文件<code>sys/stat.h</code></li></ul><p>返回值: 共享内存段的标识符<br />常用模式参数</p><ul><li>S_IRUSR和S_IWUSR分别表示共享内存段宿主的读写权限</li><li>S_IRGRP和S_IWGRP分别表示共享内存段组用户的读写权限</li><li>S_IROTH和S_IWOTH分别表示共享内存段其他人的读写权限</li></ul><p>调用示例</p><ul><li>int seg_id = shmget( shm_key, getpagesize(), IPC_CREAT | S_IRUSR | S_IWUSER );</li></ul><p>shmat()函数: 连接共享内存</p><ul><li>原型: <code>void *shmat(int shmid, const void *shmaddr, int shmflg);</code></li><li>参数: shmid为共享内存段标识符（shmget()的返回值）， shmaddr为指针，指向共享内存段的映射地址，如果传递NULL，Linux自动选择合适地址， shmflg为连接标志</li><li>返回值: 成功时返回所连接的共享内存段的地址</li></ul><p>连接标志</p><ul><li>SHM_RND: shmaddr指定的映射地址向下圆整到页面尺寸的整数倍；如果未指定，则传递shmaddr时必须手工对齐页面地址</li><li>SHM_RDONLY: 共享内存段组只读</li></ul><p>shmdt()函数: 拆卸共享内存段 - 原型: <code>int shmdt(const void *shmaddr);</code></p><p>共享内存example <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;shm.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">    struct shmid_ds shmbuf;</span><br><span class="line">    int seg_size;</span><br><span class="line">    const int shared_size &#x3D; 0x6400;</span><br><span class="line">    &#x2F;&#x2F; 分配共享内存段</span><br><span class="line">    int seg_id &#x3D; shmget(IPC_PRIVATE, shared_size, IPC_CREAT|IPC_EXCL|S_IRUSR|S_IWUSR );</span><br><span class="line">    &#x2F;&#x2F; 连接共享内存段</span><br><span class="line">    char *shared_mem &#x3D; (char *)shmat(seg_id, 0, 0);</span><br><span class="line">    printf(&quot;Shared memory attached at %p\n&quot;, shared_mem);</span><br><span class="line">    &#x2F;&#x2F; 获取段尺寸信息</span><br><span class="line">    shmctl(seg_id, IPC_STAT, &amp;shmbuf);</span><br><span class="line">    seg_size &#x3D; shmbuf.shm_segsz;</span><br><span class="line">    printf(&quot;Segment size: %d\n&quot;, seg_size);</span><br><span class="line">    &#x2F;&#x2F; 向共享内存区段写入字符串</span><br><span class="line">    sprintf(shared_mem, &quot;Hello, world.&quot;);</span><br><span class="line">    &#x2F;&#x2F; 拆卸共享内存区段</span><br><span class="line">    shmdt(shared_mem);</span><br><span class="line">    &#x2F;&#x2F; 在不同的地址处重新连接共享内存区段</span><br><span class="line">    shared_mem &#x3D; (char *)shmat(seg_id, (void *)0x5000000, 0 );</span><br><span class="line">    printf(&quot;Shared memory reattached at %p\n&quot;, shared_mem);</span><br><span class="line">    &#x2F;&#x2F; 获取共享内存区段中的信息并打印</span><br><span class="line">    printf(&quot;%s\n&quot;, shared_mem);</span><br><span class="line">    &#x2F;&#x2F; 拆卸共享内存区段</span><br><span class="line">    shmdt(shared_mem);</span><br><span class="line">    &#x2F;&#x2F; 释放共享内存区段，与semctl类似</span><br><span class="line">    shmctl(seg_id, IPC_RMID, 0);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 映射内存</p><p>mmap()函数：头文件<code>sys/mman.h</code></p><ul><li>映射共享文件到内存；文件被分割成页面大小装载；使用内存读写操作访问文件，速度更快；对映射内存的写入自动反映到文件中</li><li>原型：void <em>mmap(void </em>addr, size_t length, int prot, int　flags, int fd, off_t offset);</li></ul><p>函数参数</p><ul><li>addr：映射目的地的内存地址，NULL表示由Linux自动选择合适的内存地址</li><li>length：映射内存的大小，以字节为单位</li><li>prot：指定映射内存的保护权限，为PROT_READ（允许读取）、PROT_WRITE（允许写入）、 PROT_EXEC（允许执行）或以上三者的组合</li><li>flags：附加选项标志；为MAP_FIXED（如果指定此标志，则Linux使用用户指定的地址映射文件，地址本身必须页对齐）、MAP_PRIVATE（内存写入不回写至外部文件，本进程保留写入的文件副本），MAP_SHARED（内存写入立即反映到映射文件中）；MAP_PRIVATE与MAP_SHARED不能混用</li><li>fd：待映射文件的文件描述符</li><li>offset：指定映射数据在文件中的偏移量</li></ul><p>函数返回值</p><ul><li>成功调用时返回映射内存的基地址，失败时返回MAP_FAILED</li></ul><p>munmap()函数：释放映射内存 - 原型：<code>int *munmap(void *addr, size_t length);</code> - 参数：addr为映射内存的基地址；length为映射内存的大小 - 返回值：成功时返回0，失败时返回-1并设errno值</p><p>msync()函数：映射内存同步</p><ul><li>原型：<code>int msync( void * addr, size_t length, int flags);</code></li><li>参数：addr为映射内存基地址，length为映射内存大小，flags为同步标志，MS_ASYNC（数据更新被调度，但函数返回前并不一定会被执行）；MS_SYNC（数据更新立即执行，在完成前调用进程被阻塞）；MS_INVALIDATE（通知其他进程数据已无效，并自动提供新数据）；MS_ASYNC与MS_SYNC不能混用</li><li>返回值：成功时返回0，失败时返回-1并设errno值</li></ul><p>映射内存example <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;mman.h&gt;</span><br><span class="line">#include &lt;wait.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;iomanip&gt;</span><br><span class="line">const int mapped_size &#x3D; 4096;</span><br><span class="line">const int mapped_count &#x3D; mapped_size &#x2F; sizeof(int);</span><br><span class="line">int main(int argc, char *const argv[])</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 打开文件作为内存映射的对象，确保文件尺寸足够存储1024个整数</span><br><span class="line">    int fd &#x3D; open(argv[1],O_RDWR|O_CREAT,S_IRUSR|S_IWUSR);</span><br><span class="line">    lseek(fd, mapped_size - 1, SEEK_SET );</span><br><span class="line">    write(fd, &quot;&quot;, 1 );</span><br><span class="line">    lseek(fd, 0, SEEK_SET );</span><br><span class="line">    int *base &#x3D; (int *)mmap(0, mapped_size, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, fd, 0);</span><br><span class="line">    close(fd); &#x2F;&#x2F; 创建映射内存后，关闭文件的文件描述符</span><br><span class="line">    pid_t pid &#x3D; fork();</span><br><span class="line">    if(pid &#x3D;&#x3D; (pid_t)0) &#x2F;&#x2F; 子进程写入数据</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; 写入数据0～1023</span><br><span class="line">        for(int i &#x3D; 0, *p &#x3D; base; i &lt; mapped_count; *p++ &#x3D; i++);</span><br><span class="line">        munmap(base, mapped_size);</span><br><span class="line">    &#125;</span><br><span class="line">    else if(pid &gt; (pid_t)0) &#x2F;&#x2F; 父进程读取数据</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(10); &#x2F;&#x2F; 等待10秒</span><br><span class="line">        for(int i &#x3D; 0, *p &#x3D; base; i &lt; mapped_count; i++, p++)</span><br><span class="line">        std::cout &lt;&lt; std::setw(5) &lt;&lt; *p &lt;&lt; &quot; &quot;;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">        munmap(base, mapped_size);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## 6. 消息队列</p><p>消息队列：在两个进程间传递二进制块数据</p><ul><li>数据块具有类别信息，接收方可根据消息类别有选择地接收</li><li>头文件：“ sys/type.h”、“ sys/ipc.h”和“ sys/msg.h”</li></ul><p>msgget()函数：创建或获取消息队列</p><ul><li>原型：<code>int msgget(ket_t key, int msgflg);</code></li><li>参数：key为键值，标识全局唯一的消息队列；msgflg为创建标志，与semget()的标志相同</li><li>返回值：成功时返回正整数作为消息队列的标识符，失败时返回-1，并设errno值</li><li>如果用于创建消息队列，相关内核数据结构struct msqid_ds将被创建并初始化</li></ul><p>msgsnd()函数：将消息添加到消息队列中</p><ul><li>原型：<code>int msgsnd(int msqid, const void * msg_ptr, size_t msg_sz, int msgflg);</code></li><li>参数： msqid为msgget()返回的消息队列标识符；msg_ptr指向准备发送的消息； msg_sz为消息数据长度；msgflg控制消息发送行为，一般仅支持IPC_NOWAIT标志，即以非阻塞的方式发送消息</li><li>返回值：成功时返回0，失败时返回-1，并设errno值</li></ul><p>消息缓冲区结构</p><ul><li>msg_ptr指向的数据结构如右</li><li>mtype为消息类别，必须为正整数</li><li>mtext为消息数据，msg_sz为其实际长度</li></ul><p>struct msgbuf { long int mtype; char mtext[512]; };</p><p>msgrcv()函数：从消息队列中获取消息</p><ul><li>原型：<code>int msgrcv(int msqid, void *msg_ptr, size_t msg_sz, long int msgtype, int msgflg);</code></li><li>参数： msqid为msgget()返回的消息队列标识符；msg_ptr用于存储接收的消息；msg_sz为消息数据长度；msgtype为消息类别；msgflg控制消息发送行为，可以为IPC_NOWAIT、MSG_EXCEPT（msgtype大于0时，读取第一个非msgtype类别的消息）和MSG_NOERROR的位或</li><li>返回值：成功时返回0，失败时返回-1，并设errno值</li><li>消息类别msgtype说明：为0则读取队列第一条消息，大于0则读取队列中第一条类别为msgtype的消息，小于0则读取队列中第一个类别比msgtype绝对值小的消息</li></ul><p>参考:<br /><a href="http://www.ibm.com/developerworks/cn/linux/l-ipc/index.html" target="_blank" rel="noopener">深刻理解Linux进程间通信（IPC）</a><br /><a href="http://www.ibm.com/developerworks/cn/linux/l-ipc/part1/index.html" target="_blank" rel="noopener">Linux环境进程间通信（一）管道</a><br /><a href="https://www.ibm.com/developerworks/cn/linux/l-ipc/part2/index1.html" target="_blank" rel="noopener">Linux环境进程间通信（二）: 信号（上）</a><br /><a href="https://www.ibm.com/developerworks/cn/linux/l-ipc/part2/index2.html" target="_blank" rel="noopener">Linux环境进程间通信（二）: 信号（下）</a><br /><a href="http://www.ibm.com/developerworks/cn/linux/l-ipc/part3/index.html" target="_blank" rel="noopener">Linux环境进程间通信（三）消息队列</a><br /><a href="http://www.ibm.com/developerworks/cn/linux/l-ipc/part4/index.html" target="_blank" rel="noopener">Linux环境进程间通信（四）信号量</a><br /><a href="http://www.ibm.com/developerworks/cn/linux/l-ipc/part5/index1.html" target="_blank" rel="noopener">Linux环境进程间通信（五）: 共享内存（上）</a><br /><a href="http://www.ibm.com/developerworks/cn/linux/l-ipc/part5/index2.html" target="_blank" rel="noopener">Linux环境进程间通信（五）: 共享内存（下）</a><br /><a href="https://www.ibm.com/developerworks/cn/linux/l-ipc/part6/" target="_blank" rel="noopener">Linux 环境进程间通信（六）套接口</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IPC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>infix to postfix</title>
      <link href="/2016/11/21/infix-to-postfix/"/>
      <url>/2016/11/21/infix-to-postfix/</url>
      
        <content type="html"><![CDATA[<p>如题，中缀表达式转后缀表达式。 求表达式<code>x=a+b*(c-d)/e</code>的后缀表达式。</p>]]></content>
      
      
      <categories>
          
          <category> data structures and algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> infix </tag>
            
            <tag> postfix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dynamic programming part3</title>
      <link href="/2016/11/20/dynamic-programming-part-3/"/>
      <url>/2016/11/20/dynamic-programming-part-3/</url>
      
        <content type="html"><![CDATA[<p>Ebay 面试题 | 把数组分成和大小一样的集合</p><p><strong>题目描述</strong></p><p>给定一个只包含正整数的非空数组，判断该数组能否分成两个和相等的子数组。</p><p><strong>样例输入</strong></p><p>输入[1,5,11,5] 返回 true . 可以分为[1,5,5]和[11]<br />输入[1,2,3,5] 返回false. 无法分为相等的两个子数组<br /><a id="more"></a> <strong>算法分析</strong></p><p>本题需要判断数组能否分为两个和想等的子数组，等价于在数组中选取一定数目的元素，能否使得选择的元素之和为<span class="math inline">\(sum/2\)</span>(sum为数组中所有元素的和)。而等价的问题就是经典的0-1背包问题，即给定一个正整数数组，能否从数组中选取一定数量的元素，使得这些元素的和恰好为<span class="math inline">\(sum/2\)</span>。</p><p>为了解决这个问题，直观的想法是我们可以枚举原数组的所有子集，计算每个子集的元素之和能否等于sum/2,但是含有n个元素的数组的子集数目为2^n个，这样算法的复杂度是指数级别的，在n比较大的时候并不可行。</p><p>我们假设数组中存在子集num1,num2,...,numk满足和为<span class="math inline">\(sum/2\)</span>,那么，从该子集中去掉最后一个元素numk,其和一定为<span class="math inline">\(sum/2-numk\)</span>。也就是说子问题：是否存在一个子集，其和为sum/2-numk,该问题一定是有解的（可以用反证法证明）。</p><p>这样，我们可以确定，原问题有解当且仅当子问题有解。这样，我们就把一个规模比较大的问题归结成了规模比较小的子问题。这就是动态规划的思想。那么，我们如何确定子问题是否有解呢？可以这样考虑，假设<span class="math inline">\(dp[i][j]\)</span>表示数组中前i个元素能否得到和为j的子数组，<span class="math inline">\(dp[i][j] = 1\)</span>表示前i个元素能够得到和为j的子数组，<span class="math inline">\(dp[i][j] = 0\)</span>表示不能得到。那么对于第i个元素来说，有两种情况，一种是第i个元素在和为j的子数组中，那么对于前i-1个元素来讲，应该得到和为j-nums[i]的子数组；另一种情况是第i个元素不在和为j的子数组中，那么对于前i-1个元素来讲，应该得到和为j的子数组。上述两种情况成立其一就可以保证能够得到合法解。因此我们有以下关系：</p><p><span class="math display">\[dp[i][j] = dp[i-1][j] | dp[i-1]][j-nums[i]]\]</span></p><p>上述解法的时间复杂度和空间复杂度均为<code>O（n*sum）</code>的，由于问题中，<code>n*sum = 200 * 100  * 200 = 4*10^6</code>,我们需要优化空间复杂度。进一步思考我们发现，第i次迭代的过程只与第i-1次迭代过程有关系，而与前i-2次迭代过程无关。因此我我们首先可以考虑使用2×sum的滚动数组来解决此题。此时可以把空间复杂度压缩到<code>O(sum)</code>。</p><p>另一种解法是一维动态规划，我们假设dp[j]表示第i轮迭代能否得到和为j的子数组，那么只要保证此时数组中存储的是上一轮（i-1轮）迭代的结果，我们就可以去掉一个维度。因此我们有如下关系：</p><p><span class="math display">\[dp[j] = dp[j] | dp[j - nums[i]]\]</span></p><p>但是这种情况下，内层循环必须从大往小循环（思考为什么）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> choose[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">bool</span> ans = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> idx, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> own, <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (idx&lt;<span class="number">0</span> || own == sum)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (own == sum)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"own: "</span> &lt;&lt; own &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"sum: "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; nums[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; choose[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">ans = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if (idx &lt; 0)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">return;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line">choose[idx] = <span class="number">1</span>;</span><br><span class="line">search(idx - <span class="number">1</span>, nums, own + nums[idx], sum);</span><br><span class="line">choose[idx] = <span class="number">-1</span>;</span><br><span class="line">search(idx - <span class="number">1</span>, nums, own, sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = nums.size();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">choose[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">sum += nums[i];</span><br><span class="line">&#125;</span><br><span class="line">sum = sum/<span class="number">2</span>;</span><br><span class="line">search(n - <span class="number">1</span>, nums, <span class="number">0</span>, sum);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums&#123; <span class="number">1</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="comment">//vector&lt;int&gt; nums&#123; 1, 2, 3, 5 &#125;;</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; solve(nums) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的解法是暴力算法，时间复杂度为O(2^n);<br />上面的程序还有问题，待修正。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> choose[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> idx, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> own, <span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (idx&lt;<span class="number">0</span> || own == sum)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (own == sum)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"own: "</span> &lt;&lt; own &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"sum: "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; nums[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; choose[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">ans = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">if (idx &lt; 0)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">return;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line">choose[idx] = <span class="number">1</span>;</span><br><span class="line">search(idx - <span class="number">1</span>, nums, own + nums[idx], sum);</span><br><span class="line">choose[idx] = <span class="number">-1</span>;</span><br><span class="line">search(idx - <span class="number">1</span>, nums, own, sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = nums.size();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">choose[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">sum += nums[i];</span><br><span class="line">&#125;</span><br><span class="line">sum = sum/<span class="number">2</span>;</span><br><span class="line">search(n - <span class="number">1</span>, nums, <span class="number">0</span>, sum);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums&#123; <span class="number">1</span>,<span class="number">5</span>,<span class="number">11</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="comment">//vector&lt;int&gt; nums&#123; 1, 2, 3, 5 &#125;;</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; solve(nums) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> data structures and algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bit operation</title>
      <link href="/2016/11/20/bit-operation/"/>
      <url>/2016/11/20/bit-operation/</url>
      
        <content type="html"><![CDATA[<h1 id="位操作">位操作</h1><h2 id="循环左移">1. 循环左移</h2><p>今天看邓俊辉的数据结构，在276页发现了一个循环左移五位的一小段代码是<code>(h&lt;&lt;5)|h&gt;&gt;27</code>，其中h是一个32 bit的整数。感觉很精妙。 <a id="more"></a></p><h2 id="求整数的二进制表示中有多少个1">2. 求整数的二进制表示中有多少个1</h2><p>应用了<code>n&amp;=(n-1)</code>能将n的二进制表示中的最右边的1翻转为0的事实。只需要不停地执行 <code>n&amp;=(n-1)</code>，直到n变成0为止，那么翻转的次数就是原来的n的二进制表示中1的个数，其代码如下： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int count1Bits(int n)&#123;</span><br><span class="line">    int count &#x3D; 0;</span><br><span class="line">    while(n!&#x3D;0)</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        n &#x3D; n &amp; (n-1);</span><br><span class="line">    &#125;</span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>http://blog.csdn.net/w57w57w57/article/details/6634654</p>]]></content>
      
      
      <categories>
          
          <category> data structures and algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bit operation </tag>
            
            <tag> crol </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dynamic programming part2</title>
      <link href="/2016/11/19/dynamic-programming-part-2/"/>
      <url>/2016/11/19/dynamic-programming-part-2/</url>
      
        <content type="html"><![CDATA[<h1 id="dynamic-programming">Dynamic Programming</h1><p>动态规划的本质是递归，一切动态规划问题一定能写成递归的形式。递归的本质是原问题能拆解成子问题，子问题再推导出原问题。<br />最优子结构：用递归式处理掉后效性，使子问题不具有后效性。<br />重叠子问题：用空间换取时间，将中间结果记录下来，去除冗余。<br />问题共性： 套路：最大，最小，最优，最长，计数。<br />离散问题：用动态规划来解决，容易设计状态。<br />最优子结构：子问题的解能推导出原问题的解。N-1可以推导出N。<br /><a id="more"></a> 基本步骤：</p><ol type="1"><li>设计暴力算法也就是递归算法，找到冗余。</li><li>找到冗余之后，把冗余存储下来，把计算过的东西怎么存储下来，可以用一维二维三维数组或者是Map。</li><li>用递归式写成状态转移方程。</li><li>用自底向上或者自顶向下的编程方式来把问题解决。</li></ol><h2 id="整数01背包问题">1. 整数01背包问题</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> w[n], v[n], W;</span><br><span class="line">S &lt;= W</span><br><span class="line">S已经占用了多少的重量，已经选择的物品的总重量。</span><br><span class="line"></span><br><span class="line">暴力回溯法</span><br><span class="line"><span class="keyword">int</span> search(<span class="keyword">int</span> idx, <span class="keyword">int</span> S)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//选的物品重量超过了背包的容量W</span></span><br><span class="line">    <span class="keyword">if</span>(S &gt; W)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//边界条件</span></span><br><span class="line">    <span class="comment">//选到最后一个了</span></span><br><span class="line">    <span class="keyword">if</span>(idx &gt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//search(idx + 1, S + w[idx]) + v[idx]</span></span><br><span class="line">    <span class="comment">//search(idx + 1, S)</span></span><br><span class="line">    <span class="comment">//返回价值较大的那一个</span></span><br><span class="line">    <span class="keyword">return</span> max(search(idx + <span class="number">1</span>, S + w[idx]) + v[idx], search(idx + <span class="number">1</span>, S));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暴力算法时间复杂度是<code>O(2^n)</code>，递归一共有n层，每一层有两种决策。父亲问题可以分解为两个子问题，因为父亲问题的时间是每一个子问题的2倍。search(idx,S)和search(idx + 1, S + w[idx])，search(idx + 1, S)有关。<br />最简单的是<code>O(1)</code>，父亲的时间复杂度是<code>O(1)*2</code>，父亲的父亲是<code>O(1)*2*2</code>，一直到目标一共有n个父亲所以是<code>O(2^n)</code>。</p><p>代码里面有很多很多的冗余，构成S的方法有很多很多种方法，对于每一种加和都要算一遍。对于当前的状态我只知道当前的S是多少就行了，不必关心S是怎么计算的，即只关心背包容量用掉了多少，不关心怎么用的。<br /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">S = <span class="number">4</span></span><br><span class="line"><span class="number">2</span>,<span class="number">2</span></span><br><span class="line"><span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span></span><br><span class="line"><span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span></span><br></pre></td></tr></table></figure> 有多种的方法可以构成S，每一种构成方法都要算一遍。<br />找冗余，明白冗余在哪里<br />自顶向下：记忆化搜索。<br />加了记忆化搜索<br /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用search(0,0);</span></span><br><span class="line"><span class="comment">//S已经占用</span></span><br><span class="line"><span class="comment">//剩余可用= W-已经占用</span></span><br><span class="line"><span class="comment">//search(0,W);</span></span><br><span class="line"><span class="comment">//search(n-1,0);</span></span><br><span class="line"><span class="comment">//search(n-1,W)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span> S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S &gt; W)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//边界条件</span></span><br><span class="line">    <span class="keyword">if</span>(idx &gt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(f[idx][S] &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> f[idx][S];</span><br><span class="line">    &#125;</span><br><span class="line">    f[idx][S] = max(search(idx + <span class="number">1</span>, S + w[idx]) + v[idx], search(idx + <span class="number">1</span>, S));</span><br><span class="line">    <span class="keyword">return</span> f[idx][S];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 每一个(参数的组合)是一个状态。将计算过的状态的结果存储下来保存在f[idx][S]中。<br />自底向上的方式：先算小的，再算大的。<br />递归式就是状态转移方程。<br /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[idx][S] &#x3D; max(search(idx + 1, S + w[idx]) + v[idx], search(idx + 1, S));</span><br></pre></td></tr></table></figure> 将后面的search改成f数组。<br />正着写就是从第一个开始往后搜，倒着写是从最后一个往前搜。<br /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">f[<span class="number">0</span>][<span class="number">0</span>]= <span class="number">0</span>;</span><br><span class="line"><span class="comment">//f[0][1]...f[0][W]没初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; W; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    f[<span class="number">0</span>][i] = -maxValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第一维状态idx，第二维状态j是S，已经选取物品的重量。</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> idx = <span class="number">1</span>; idx &lt;= n; ++idx)</span><br><span class="line">&#123;   </span><br><span class="line">    f[idx][<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//一个都不选，已有容量为0，就是不选，价值为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;= W; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//idx没算过，设一个默认值</span></span><br><span class="line">        f[idx][j] = f[idx<span class="number">-1</span>][j];</span><br><span class="line">        <span class="keyword">if</span>(j &gt;= w[idx])</span><br><span class="line">        &#123;</span><br><span class="line">            f[idx][j] = max(f[idx - <span class="number">1</span>][j - w[idx]] + v[idx], f[idx][j]);</span><br><span class="line">            <span class="comment">//此处f[idx][j] = f[idx-1][j];</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 动态规划问题是一个有向无环图。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(idx,s) (idx&#39;,s&#39;)</span><br><span class="line">O    O  O   O</span><br><span class="line"> \  &#x2F;    \  &#x2F;</span><br><span class="line">   O(1)    O</span><br><span class="line">    \      &#x2F;</span><br><span class="line">        O</span><br></pre></td></tr></table></figure><p>任务之间是没有环来连接，每个O表示一个状态，每个状态就是一个(参数的组合),因此参数的计算顺序对完成整个任务没有影响，所以先for循环j[0,W]再for循环idx(0,n)也是可以的,只要前导任务完成了，后续的任务就可以解决，计算顺序可以任意。因为参数之间是离散的。先for idx或者先for j都是可以的，不管(idx,s)或者(idx',s')哪个先计算，最后只要这两个先导任务(idx,s),(idx',s')做完了，后续的任务(1)就可以继续做下去。</p><p>动态规划的性质：有向无环图性质，所有的状态可以构成一幅有向无环图。这是从图论的角度看动态规划。</p><p>自顶向下：从目标递归向下，递归到边界条件，计算出最底层的结果，然后返回向上，返回到目标。 递归有一个从上到下拆解的过程，因此效率要比自底向上低一些。</p><p>自底向上：先算出边界条件的值，然后向上计算，一直计算到目标。</p><p>空间复杂度：<br />动态规划都是用空间来换时间的，所以有时候是空间先受不了。<br /><code>f[idx][S], O(n*W)</code> 时间复杂度：<br />递归：每一个状态计算了一次，每次是<code>O(1)</code>的，共有<code>n*W</code>个状态，所以时间复杂度为<code>O(n*W)</code><br />递推：两个for循环，很容易<code>O(n*W)</code>。</p><p>为什么要写成递推的形式？可以省空间。<br />空间是可以反复用的。</p><p>f[idx]只和idx-1有关。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">---------------------</span><br><span class="line">|    |    |    |    | idx&#x3D;1 (0)</span><br><span class="line">---------------------</span><br><span class="line">|    |    |    |    | idx&#x3D;2 (1)</span><br><span class="line">---------------------</span><br><span class="line">|    |    |    |    | idx&#x3D;3 (0)</span><br><span class="line">---------------------</span><br><span class="line">|    |    |    |    | idx&#x3D;4 (1)</span><br><span class="line">---------------------</span><br><span class="line"> s&#x3D;1   s&#x3D;2  s&#x3D;3  s&#x3D;4</span><br></pre></td></tr></table></figure><p>计算idx的时候只和上一层有关。比如计算idx=2的时候只和idx=1有关，计算idx=3的时候idx=1那一层就不需要了，因此只需保存相邻的两层。</p><ol type="1"><li>最直观的解决方案是delete，但是new和delete是很消耗时间的。</li><li>滚动数组版：</li></ol><p>把f里有关下标计算的地方都<code>mod 2</code><br /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">f[<span class="number">0</span>][<span class="number">0</span>]= <span class="number">0</span>;</span><br><span class="line"><span class="comment">//f[0][1]...f[0][W]没初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; W; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    f[<span class="number">0</span>][i] = -maxValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第一维状态idx，第二维状态j是S，已经选取物品的重量。</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> idx = <span class="number">1</span>; idx &lt;= n; ++idx)</span><br><span class="line">&#123;   </span><br><span class="line">    f[idx%<span class="number">2</span>][<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//一个都不选，已有容量为0，就是不选，价值为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j&lt;= W; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//idx没算过，设一个默认值</span></span><br><span class="line">        f[idx%<span class="number">2</span>][j] = f[(idx<span class="number">-1</span>)%<span class="number">2</span>][j];</span><br><span class="line">        <span class="keyword">if</span>(j &gt;= w[idx])</span><br><span class="line">        &#123;</span><br><span class="line">            f[idx%<span class="number">2</span>][j] = max(f[(idx - <span class="number">1</span>)%<span class="number">2</span>][j - w[idx]] + v[idx], f[idx%<span class="number">2</span>][j]);       </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>空间复杂度变成：<code>O(2W)</code>即<code>O(W)</code></p><p>如果W很大怎么办？W的很大没有办法。</p><h2 id="leetcode-322">2. LeetCode 322</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> maxValue = INT_MAX<span class="number">-1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span> amount, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; coins)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//完美结束，要找的钱刚好都找到了</span></span><br><span class="line">        <span class="keyword">if</span>(amount == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不合法的状态</span></span><br><span class="line">        <span class="keyword">if</span>(amount &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> maxValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(idx &gt;= coins.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> maxValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//用idx或者不用idx</span></span><br><span class="line">        <span class="comment">//search(idx, amount-coins[idx],coins)+1</span></span><br><span class="line">        <span class="comment">//硬币不限量供应，取了idx并没有加1，所以是可以重复选取的。而上面的背包问题，不管你选没选，都是idx+1</span></span><br><span class="line">        <span class="comment">//search(idx+1,amount,coins)</span></span><br><span class="line">        <span class="keyword">return</span> min(search(idx, amount-coins[idx],coins)+<span class="number">1</span>,search(idx+<span class="number">1</span>,amount,coins));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = search(<span class="number">0</span>, amount, coins);</span><br><span class="line">        <span class="keyword">if</span>(res &lt; maxValue)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//非法值的选取，要是求最小，就选择最大值，要是求最大，就选择最小值。同时要保证非法值不参与运算。</span></span><br></pre></td></tr></table></figure><h2 id="最长公共子序列">3. 最长公共子序列</h2><p>空序列也是子序列。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">X[n] 取哪些</span><br><span class="line">Y[m] 取哪些</span><br><span class="line"></span><br><span class="line">xi取到了哪个位置，yi取到了哪个位置。</span><br><span class="line">从前往后搜</span><br><span class="line"></span><br><span class="line">int search(int xi, int yi)</span><br><span class="line">&#123;</span><br><span class="line">    if(xi &gt;&#x3D; n || yi &gt;&#x3D; m)</span><br><span class="line">    &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    if(xi &#x3D;&#x3D; n &amp;&amp; yi &#x3D;&#x3D; m)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;xi取，yi也取</span><br><span class="line">    int a,b,c</span><br><span class="line">    if(X[xi] &#x3D;&#x3D; Y[yi])</span><br><span class="line">    &#123;</span><br><span class="line">        a &#x3D; search(xi+1,yi+1) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        b &#x3D; search(xi,yi+1)</span><br><span class="line">        c &#x3D; search(xi+1,yi)</span><br><span class="line">    &#125;</span><br><span class="line">    return max(a,b,c);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">从后往前搜</span><br><span class="line">int search(int xi, int yi)</span><br><span class="line">&#123;</span><br><span class="line">    if(xi &lt; 0 || yi &lt; m)</span><br><span class="line">    &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    if(xi &#x3D;&#x3D; 0 &amp;&amp; yi &#x3D;&#x3D; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;xi取，yi也取</span><br><span class="line">    int a,b,c</span><br><span class="line">    if(X[xi] &#x3D;&#x3D; Y[yi])</span><br><span class="line">    &#123;</span><br><span class="line">        a &#x3D; search(xi-1,yi-1) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        b &#x3D; search(xi,yi-1)</span><br><span class="line">        c &#x3D; search(xi-1,yi)</span><br><span class="line">    &#125;</span><br><span class="line">    return max(a,b,c);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">记忆化搜索</span><br><span class="line">f[n][m]</span><br><span class="line">int search(int xi, int yi)</span><br><span class="line">&#123;</span><br><span class="line">    if(xi &gt;&#x3D; n || yi &gt;&#x3D; m)</span><br><span class="line">    &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">    if(xi &#x3D;&#x3D; n &amp;&amp; yi &#x3D;&#x3D; m)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    if(f[xi][yi]&gt;&#x3D;0)</span><br><span class="line">    &#123;</span><br><span class="line">        return f[xi][yi];</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;xi取，yi也取</span><br><span class="line">    int a,b,c</span><br><span class="line">    if(X[xi] &#x3D;&#x3D; Y[yi])</span><br><span class="line">    &#123;</span><br><span class="line">        a &#x3D; search(xi+1,yi+1) + 1;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        b &#x3D; search(xi,yi+1)</span><br><span class="line">        c &#x3D; search(xi+1,yi)</span><br><span class="line">    &#125;</span><br><span class="line">    return max(a,b,c);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">减一比较好写，xi，yi只是下标，但是减一有一个特别的东西。</span><br><span class="line">X长度为n，Y的长度为m的最长公共子序列的长度f(n,m)</span><br><span class="line">当X[n]&#x3D;&#x3D;Y[m]时，f(n,m) &#x3D; f(n-1,m-1)+1;</span><br></pre></td></tr></table></figure></p><h2 id="旅行商问题">4. 旅行商问题</h2><p>一个商人要不重复的访问N个城市，允许从任意城市出发，在任意城市结束。<br />现已知任意两个城市之间的道路长度</p><ul><li>求城市的访问序列，使得商人走过的路程最短</li><li>例：N=4，访问序列3，4，1，2</li><li>NP问题，最优解无多项式时间算法</li><li>时间复杂度？空间复杂度？</li><li>状态压缩</li><li>时间复杂度</li><li>空间复杂度</li></ul><p>NP问题，最优解无多项式时间算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>[n][n]</span><br><span class="line"><span class="built_in">map</span>[i][j] -&gt; i-j的距离</span><br><span class="line">visit[n] 该城市是否访问过</span><br><span class="line">count访问了多少个城市</span><br><span class="line"><span class="comment">//商人</span></span><br><span class="line"><span class="keyword">int</span> visit[n];</span><br><span class="line">visit数组也是其中的一个参数。</span><br><span class="line">所有随着递归的进展会变化的东西都必须是参数，除非是开了全局变量。</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span> count, <span class="keyword">int</span> visit[])</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(count == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> min = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visit[i])</span><br><span class="line">        &#123;</span><br><span class="line">            visit[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> t = search(i, count+<span class="number">1</span>) + <span class="built_in">map</span>[idx][i];</span><br><span class="line">            <span class="keyword">if</span>(t &lt; min)</span><br><span class="line">            &#123;</span><br><span class="line">                min = t;</span><br><span class="line">            &#125;</span><br><span class="line">            visit[i] = <span class="number">0</span>; <span class="comment">//复原，假装你没有访问过i，还原现场，回溯。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>旅行商问题：<br />时间复杂度(O(N!))，和全排列问题相同。</p><p>版本二： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span> count, <span class="keyword">int</span> visit[])</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span> visit[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//不要count</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    if(count == n)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        return 0;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(sum(visit) == n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    //加以下的代码不会增加时间复杂度</span></span><br><span class="line"><span class="comment">    if(f[idx][count][visit] is calculated)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        return f[idx][count][visit];</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(f[idx][visit] is calculated)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> f[idx][visit];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//visit的状态有2^n个</span></span><br><span class="line">    <span class="comment">//count代表visit中有多少个1，因此count可以去掉</span></span><br><span class="line">    <span class="built_in">map</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>[]&gt;, <span class="keyword">int</span>&gt;;</span><br><span class="line">    <span class="comment">//这种方法叫做状态压缩，也叫做位压DP，为什么叫做位压DP，visit是01表示的。</span></span><br><span class="line">    <span class="keyword">int</span> visit[n];</span><br><span class="line">    [<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>] -&gt; (<span class="number">1010</span>)<span class="number">2</span> -&gt; <span class="number">10</span></span><br><span class="line">    把一个布尔数组转化为一个整数，布尔数组毕竟是一个数组，对它进行状态表达很麻烦，需要用到一个<span class="built_in">map</span>，很麻烦，效率也很低。转换为<span class="keyword">int</span>之后，直接就是一个二维数组了。</span><br><span class="line">    因此代码变为</span><br><span class="line">    <span class="keyword">if</span>(f[idx][<span class="keyword">int</span>] is calculated)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> f[idx][<span class="keyword">int</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//本质上就是自己做了一个映射，数组变成了一个下标了，把一个数组压缩成了一个整数，所以叫做位压DP。</span></span><br><span class="line">    <span class="comment">//bloom filter用一个int来表示一个长度为32的visit数组。</span></span><br><span class="line">    <span class="keyword">int</span> min = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visit[i])</span><br><span class="line">        &#123;</span><br><span class="line">            visit[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> t = search(i, visit) + <span class="built_in">map</span>[idx][i];</span><br><span class="line">            <span class="keyword">if</span>(t &lt; min)</span><br><span class="line">            &#123;</span><br><span class="line">                min = t;</span><br><span class="line">            &#125;</span><br><span class="line">            visit[i] = <span class="number">0</span>; <span class="comment">//复原，假装你没有访问过i，还原现场，回溯。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>原时间 <code>O(N!)</code><br />现空间 <code>O(N*2^N)</code><br />idx是n个，visit的取值有<code>2^n</code>个，所以总共有<code>N*2^N</code>个状态。所以总共的空间复杂度为<code>O(N*2^N)</code>;</p><p>现时间复杂度变为 <code>O(n^2*2^n)</code>,为什么在空间复杂度的基础上乘了一个n呢？是因为总共有<code>N*2^N</code>个状态，而在每个状态里面有一个for循环，是从0到N的，每一个状态的计算量为n,先算有多少个状态，然后计算每个状态的计算量，最后乘起来，之前的每个状态的计算量为1，所以时间复杂度乘以一个N。</p><p>上面的算法就是动态规划了。动态规划就是在递归暴力算法的基础上去掉冗余。</p><p>动态规划的本质：先暴力，找冗余，去冗余。</p><p>一个是找冗余，哈希表，缓存。另一个是二分法很好用。<br />memcached，如果一个query访问比较多，就放入缓存中，这就是动态规划的思想。</p>]]></content>
      
      
      <categories>
          
          <category> data structures and algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dynamic programming part1</title>
      <link href="/2016/11/19/dynamic-programming-part-1/"/>
      <url>/2016/11/19/dynamic-programming-part-1/</url>
      
        <content type="html"><![CDATA[<h1 id="dynamic-programming">Dynamic Programming</h1><p>递归，暴力搜索，写出暴力搜索之后可以找出冗余。<br />本质：递归<br />原问题（N）-&gt;子问题（N-1）-&gt;原问题（N）<br /><a id="more"></a> 最优子结构</p><ul><li>子问题最优决策可导出原问题最优决策</li><li>无后效性</li></ul><p>重叠子问题</p><ul><li>去冗余</li><li>空间换时间（注意分析时空复杂度）</li></ul><p>vector/string的index或者size返回值是<code>vector::size_type</code>, <code>string::size_type</code>，是unsigned类型的，<code>unsighed int, unsigned long</code>。 bitset.size(),sizeof返回类型是size_t;<br />size_t不是容器概念。<br />size_type是容器概念，没有容器不能使用。<br />vector库也可以定义<code>size_type</code>类型，在vector库中还有一个<code>difference_type</code>类型，该类型用来存储任何两个迭代器对象间的距离，所以是<code>signed</code>类型的。</p><p>只要题目中有最优，最大，最小，最长，计数的字眼，就有可能用动态规划来解决。<br />离散问题：容易设计状态。<br />最优子结构：N-1可以推导出N。N可以拆解成N-1。</p><p>解题的基本步骤：</p><ol type="1"><li>设计暴力算法（递归算法）枚举每一步的决策，找到冗余。</li><li>设计并存储状态（一维，二维，三维数组，甚至用Map），存储重复计算的结果。</li><li>递归式（状态转移方程）。</li><li>自底向上计算最优解（编程方式）。</li></ol><p>自底向上（先计算小的，先计算idx=0,idx=1,最后计算得到idx=n），自顶向下（大问题分解为小问题，），一个是for循环（递推）一个是递归。</p><h2 id="leetcode-198-house-robber">1. LeetCode 198: House Robber</h2><p>暴力算法，枚举每个房子的决策。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//从后往前</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> idx, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(idx&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(idx==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(idx == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//选择idx,则得nums[idx]+solve(idx-2),不选择idx，则得solve(idx-1)</span></span><br><span class="line">        <span class="keyword">return</span> max(nums[idx]+solve(idx<span class="number">-2</span>,nums),solve(idx<span class="number">-1</span>,nums));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> solve(nums.size()<span class="number">-1</span>,nums);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 递归是把问题拆解成小问题。<br />递归要特别注意边界条件，要细致考虑边界条件。<br />时间复杂度<br />时间复杂度为<span class="math inline">\(O(2^n)\)</span>，递归的时间复杂度分析是递归的每一层的计算量相乘。每一次递归有两种决策，抢或者不抢，一共递归了n层，所以时间复杂度为<span class="math inline">\(O(2^n)\)</span>。<br />找到冗余： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">            s(5)</span><br><span class="line">        &#x2F;        \</span><br><span class="line">    s(3)           s(4)</span><br><span class="line">   &#x2F;      \       &#x2F;     \</span><br><span class="line">s(1)     s(2)    s(2)      s(3)</span><br><span class="line">        &#x2F;   \     &#x2F;   \     &#x2F;      \</span><br><span class="line">     s(0)  s(1)  s(0) s(1)  s(1)    s(2)</span><br><span class="line">                                    &#x2F;  \</span><br><span class="line">                                 s(0)   s(1)</span><br></pre></td></tr></table></figure> 上面以六个房子为例，发现solve(0), solve(1), solve(2), solve(3)重复计算了好多次。 所以采用记忆化搜索的方式进行改进，就是将算过的值记录下来，下次要用到的时候就不计算了，直接使用该值。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//从后往前</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> idx, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; result)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(idx&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(result[idx]&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> result[idx];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(idx==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(idx == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//选择idx,则得nums[idx]+solve(idx-2),不选择idx，则得solve(idx-1)</span></span><br><span class="line">        result[idx] = max(nums[idx]+solve(idx<span class="number">-2</span>,nums,result),solve(idx<span class="number">-1</span>,nums,result));</span><br><span class="line">        <span class="keyword">return</span> result[idx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result(nums.size(),<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> solve(nums.size()<span class="number">-1</span>,nums,result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 时间复杂度：<br />每个状态只计算了一次，一共有n个状态，所以这个问题的解就是O(N)的。</p><p>以上算法是自顶向下的编程方式，现在改写为自底向上的写法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//从后往前</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; result)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result[<span class="number">0</span>]=nums[<span class="number">0</span>];<span class="comment">//有一个房子</span></span><br><span class="line">        result[<span class="number">1</span>]=max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);<span class="comment">//有两个房子，选其中最大的</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.size(); ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            result[i] = max(nums[i]+result[i<span class="number">-2</span>],result[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result(nums.size(),<span class="number">-1</span>);</span><br><span class="line">        solve(nums,result);</span><br><span class="line">        <span class="keyword">return</span> result[nums.size()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="裴波那切数列">2. 裴波那切数列</h2><ul><li>暴力递归</li><li>F(n)表示斐波那契第n个</li><li>F(n) = F(n-1) + F(n-2), if n&gt;=2, otherwise F(n) = 1</li><li>for i &lt;- 2 to n</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int f(int n)</span><br><span class="line">&#123;</span><br><span class="line">if (n &#x3D;&#x3D; 0)</span><br><span class="line">&#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">if (n &#x3D;&#x3D; 1)</span><br><span class="line">&#123;</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line">return f(n - 1) + f(n - 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; 10; ++i)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; f(i) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>找冗余的情况和上面非常相似，这里就不画图了。<br />时间复杂度接近<span class="math inline">\(O(2^n)\)</span><br />去冗余（记忆化搜索）得到如下的代码：<br /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int result[100];</span><br><span class="line">int f(int n)</span><br><span class="line">&#123;</span><br><span class="line">if (n &#x3D;&#x3D; 0)</span><br><span class="line">&#123;</span><br><span class="line">result[0] &#x3D; 0;</span><br><span class="line">return result[0];</span><br><span class="line">&#125;</span><br><span class="line">if (n &#x3D;&#x3D; 1)</span><br><span class="line">&#123;</span><br><span class="line">result[1] &#x3D; 1;</span><br><span class="line">return result[1];</span><br><span class="line">&#125;</span><br><span class="line">if (result[n] &gt;&#x3D; 0)</span><br><span class="line">&#123;</span><br><span class="line">return result[n];</span><br><span class="line">&#125;</span><br><span class="line">result[n] &#x3D; f(n - 1) + f(n - 2);</span><br><span class="line">return result[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; 50; ++i)</span><br><span class="line">&#123;</span><br><span class="line">result[i] &#x3D; -1;</span><br><span class="line">&#125;</span><br><span class="line">for (int i &#x3D; 0; i &lt; 30; ++i)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; f(i) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 递推法，自底向上解法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int result[100];</span><br><span class="line">int f(int n)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">result[0] &#x3D; 0;</span><br><span class="line">result[1] &#x3D; 1;</span><br><span class="line">for (int i &#x3D; 2; i &lt;&#x3D; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">result[n] &#x3D; result[n - 1] + result[n - 2];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return result[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; 30; ++i)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; f(i) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以进一步优化空间复杂度 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int f(int n)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">int f &#x3D; 0;</span><br><span class="line"></span><br><span class="line">int g &#x3D; 1;</span><br><span class="line">for (int i &#x3D; 2; i &lt;&#x3D; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">g &#x3D; f + g;</span><br><span class="line">f &#x3D; g - f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return g;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">for (int i &#x3D; 0; i &lt; 30; ++i)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; f(i) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <font color="red">由这里思考，House Robber问题中，可不可以将O(n)的空间复杂度降低为O(1)呢？</font></p><h2 id="n阶乘">3. N阶乘</h2><p>F(n)= F(n-1)*n;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int f(int n)</span><br><span class="line">&#123;</span><br><span class="line">    if(n&lt;&#x3D;1)</span><br><span class="line">    &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return n*f(n-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f[0]&#x3D;1;</span><br><span class="line">f[1]&#x3D;1;</span><br><span class="line">for(int i &#x3D; 2; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    f[i] &#x3D; f[i-1]*i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小兵向前冲">4. 小兵向前冲</h2><p>N*M的棋盘上，小兵要从左下角走到右上角，只能向上或者向右走，问有多少种走法？</p><p>套路：计数问题</p><ul><li>暴搜索（回溯法）</li><li>F(n,m)表示棋盘大小为n*m时走法数量</li><li>F(n,m) = F(n-1,m) + F(n,m-1) if n*m &gt; 0, otherwise F(n,m) = 1</li><li>for i &lt;- 1 to n<ul><li>for j &lt;- 1 to m</li></ul></li></ul><p>扩展</p><ul><li>空间复杂度？</li><li>时间复杂度？</li><li>组合数递推公式C(n,m) ？</li><li>如果某些格子禁止小兵进入？</li><li>小兵一次某方向上可以走一步或者两步？</li></ul><p>2*2棋盘的最终状态： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-----------</span><br><span class="line">|    |  -&gt;|</span><br><span class="line">-----------</span><br><span class="line">|    |    |</span><br><span class="line">-----------</span><br></pre></td></tr></table></figure></p><p>2*3棋盘的最终状态： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">----------------</span><br><span class="line">|    |  &gt; |  -&gt;|</span><br><span class="line">----------------</span><br><span class="line">|    |    |  ^ |</span><br><span class="line">----------------</span><br></pre></td></tr></table></figure></p><p>只能向右和向上<br /><span class="math inline">\(f(2,3) = f(2,2) \cdot 1 + f(1,3) \cdot 1\)</span><br />从左下角(1,1)到(2,3)这个点的走法等于[从左下角(1,1)到(2,2)的走法乘以从(2,2)走到(2,3)的走法]再加上[从左下角(1,1)到(1,3)这个点的走法乘以从(1,3)走到(2,3)的走法]。从(2,2)到(2,3)就一种走法。从(1,3)到(2,3)也是一种走法。这也就是为什么乘以1的原因。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;return value:N*M棋盘有多少种走法</span><br><span class="line">int f(int n, int m)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;边界条件</span><br><span class="line">    &#x2F;&#x2F;棋盘都没有</span><br><span class="line">    if(n&#x3D;&#x3D;0||m&#x3D;&#x3D;0)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;条状棋盘</span><br><span class="line">    if(n&#x3D;&#x3D;1 || m&#x3D;&#x3D;1)</span><br><span class="line">    &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return f(n-1,m)+f(n,m-1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f[0][0] &#x3D; 0;</span><br><span class="line">for(int i &#x3D; 1; i &lt;&#x3D; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    for(int j &#x3D; 1; j &lt;&#x3D; m; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        f[i][j] &#x3D; f[i-1][j]+f[i][j-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组合数递推公式<br /><span class="math inline">\(C(n,r) = C(n-1,r)+C(n-1,r-1)\)</span><br />从n中取一个特殊的元素，根据取或者不取这个元素，得出计算公式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nCr</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//确定边界条件</span></span><br><span class="line">    <span class="keyword">if</span>(n &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    nCr(n<span class="number">-1</span>,r<span class="number">-1</span>)+nCr(n<span class="number">-1</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组合问题的物理意义是一个棋盘的走法，每次只能向上或者斜上方走一步。</p><p>某些格子小兵不能进入的情况。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---------------------</span><br><span class="line">|    |    |  * |    |</span><br><span class="line">---------------------</span><br><span class="line">|    |    |    |    |</span><br><span class="line">---------------------</span><br></pre></td></tr></table></figure><p>f(2,4) = f(2,3)+f(1,4)<br />(2,3)位置不能走，所以f(2,3)=0;</p><p>小兵一次在某方向上可以走两步的情况： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;return value:N*M棋盘有多少种走法</span><br><span class="line">int f(int n, int m)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;边界条件</span><br><span class="line">    &#x2F;&#x2F;棋盘都没有</span><br><span class="line">    if(n&#x3D;&#x3D;0||m&#x3D;&#x3D;0)</span><br><span class="line">    &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;条状棋盘</span><br><span class="line">    if(n&#x3D;&#x3D;1 || m&#x3D;&#x3D;1)</span><br><span class="line">    &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return f(n-1,m)+f(n,m-1)</span><br><span class="line">         + f(n-2,m)+f(n,m-2);</span><br><span class="line">         &#x2F;&#x2F;上面的边界条件已经够了</span><br><span class="line">         &#x2F;&#x2F;独立不相关的，所以相加</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 可以推广到小兵可以走k步的情况。因此走k步的问题可以先考虑走一步的问题，再考虑走2步的问题。</p><h2 id="走楼梯问题">6. 走楼梯问题</h2><p>n阶台阶，一次最多可以走2步，多少种走法？<br />f[n]n阶台阶有多少种走法。<br />f[0]=1;<br />f[1]=1;<br />f[n] = f[n-1] + f[n-2];<br />n阶台阶，一次最多可以走k步，多少种走法？<br />f[n] = f[n-1] + f[n-2] + f[n-3] + ... + f[n-k];</p><p>边界条件，耐心和思考问题的全面性。</p>]]></content>
      
      
      <categories>
          
          <category> data structures and algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>graph search part1</title>
      <link href="/2016/11/19/graph-search-part1/"/>
      <url>/2016/11/19/graph-search-part1/</url>
      
        <content type="html"><![CDATA[<h2 id="leetcode-78-subsets">1. LeetCode 78: Subsets</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; one_answer;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">subset</span><span class="params">(<span class="keyword">int</span> idx, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; choose)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(idx&gt;=nums.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();++i)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(choose[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    one_answer.push_back(nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(one_answer);</span><br><span class="line">            one_answer.clear();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        choose[idx] = <span class="literal">true</span>;</span><br><span class="line">        subset(idx+<span class="number">1</span>,nums,choose);</span><br><span class="line">        choose[idx] = <span class="literal">false</span>;</span><br><span class="line">        subset(idx+<span class="number">1</span>,nums,choose);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; choose(nums.size(),<span class="literal">false</span>);</span><br><span class="line">        subset(<span class="number">0</span>,nums,choose);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; one_answer;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">subset</span><span class="params">(<span class="keyword">int</span> idx, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; choose)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(idx&gt;=nums.size())</span><br><span class="line">        &#123;</span><br><span class="line">            ans.push_back(one_answer);</span><br><span class="line">            one_answer.clear();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        subset(idx+<span class="number">1</span>,nums,choose);</span><br><span class="line"></span><br><span class="line">        one_answer.push_back(nums[idx]);</span><br><span class="line">        subset(idx+<span class="number">1</span>,nums,choose);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; subsets(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        subset(<span class="number">0</span>,nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>深度优先，优先往深处走，广度优先，优先往最近的走。 时间复杂度是一样的，邻接矩阵<code>O(n^2)</code>;邻接表<code>O(n+e)</code>; <a id="more"></a> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">int visited[N];&#x2F;&#x2F;数组visited表示图中顶点的访问情况，1表示已经访问，0表示未访问</span><br><span class="line">void DFS(Graph G, int v)</span><br><span class="line">&#123;</span><br><span class="line">    visited[v] &#x3D; 1;</span><br><span class="line">    Visit(v);&#x2F;&#x2F;函数Visit(v)表示对顶点v的访问</span><br><span class="line">    &#x2F;&#x2F;函数FirstAdjVex(G,v)返回图G中v的第一个邻接顶点</span><br><span class="line">    &#x2F;&#x2F;函数NextAdjVex(G,v,w)返回图G中v的(相对于w的)下一个邻接顶点，若w是v的最后一个邻接点，则返回空</span><br><span class="line">    for(w&#x3D;FirstAdjVex(G,v);w&gt;&#x3D;0;w &#x3D; NextAdjVex(G,v,w))</span><br><span class="line">    &#123;</span><br><span class="line">        if(!visited[w])</span><br><span class="line">        &#123;</span><br><span class="line">            DFS(G,w);&#x2F;&#x2F;对v的未被访问过的邻接顶点进行深度优先搜索</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">void DFSSearch(Graph G)&#x2F;&#x2F;对图G进行深度优先搜索</span><br><span class="line">&#123;</span><br><span class="line">    for(v&#x3D;0;v&lt;G.vexnum;++v)</span><br><span class="line">    &#123;</span><br><span class="line">        visited[v] &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    for(v&#x3D;0;v&lt;G.vexnum;++v)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!visited[v])</span><br><span class="line">        &#123;</span><br><span class="line">            DFS(G,v);&#x2F;&#x2F;对未访问过的顶点调用DFS</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int visited[N];</span><br><span class="line">void BFSSearch(Graph G)</span><br><span class="line">&#123;</span><br><span class="line">    for(v&#x3D;0;v&lt;G.vexnum;++v)</span><br><span class="line">    &#123;</span><br><span class="line">        visited[v] &#x3D; 0;</span><br><span class="line">    &#125;</span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    for(v&#x3D;0;v&lt;G.vexnum;++v)</span><br><span class="line">    &#123;</span><br><span class="line">        if(!visited[v])&#x2F;&#x2F;顶点v未被访问过</span><br><span class="line">        &#123;</span><br><span class="line">            visited[v] &#x3D; 1;</span><br><span class="line">            Visit(v);</span><br><span class="line">            EnQueue(Q,v);</span><br><span class="line">            while(!QueueEmpty(Q))</span><br><span class="line">            &#123;</span><br><span class="line">                DeQueue(Q,u);</span><br><span class="line">                for(w&#x3D;FirstAdjVex(G,u);w&gt;&#x3D;0;w&#x3D;NextAdjVex(G,u,w))</span><br><span class="line">                &#123;</span><br><span class="line">                    if(!visited[w])&#x2F;&#x2F;w是v未被访问过的邻接顶点</span><br><span class="line">                    &#123;</span><br><span class="line">                        visited[w] &#x3D; 1;</span><br><span class="line">                        Visit(w);</span><br><span class="line">                        EnQueue(Q,w);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="leetcode-51.-n-queens">2. LeetCode 51. N-Queens</h2><p>回溯法，本质是深度优先，隐式图搜索。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">vector&lt;string&gt; one_answer;</span><br><span class="line">int num;</span><br><span class="line">vector&lt;int&gt; v_row;&#x2F;&#x2F;行是否被占</span><br><span class="line">vector&lt;int&gt; v_line1;&#x2F;&#x2F;正的斜线</span><br><span class="line">vector&lt;int&gt; v_line2;&#x2F;&#x2F;反的斜线</span><br><span class="line">vector&lt;int&gt; path;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;决策到第几列 idx</span><br><span class="line">void dfs(int idx, int n)</span><br><span class="line">&#123;</span><br><span class="line">if (idx&gt;&#x3D;n)</span><br><span class="line">&#123;</span><br><span class="line">one_answer.clear();</span><br><span class="line">&#x2F;&#x2F;记录所有的解</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">string tmp &#x3D; &quot;&quot;;</span><br><span class="line">for (int j &#x3D; 0; j &lt; n; ++j)</span><br><span class="line">&#123;</span><br><span class="line">if (j &#x3D;&#x3D; path[i])</span><br><span class="line">&#123;</span><br><span class="line">tmp +&#x3D; &quot;Q&quot;;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">tmp +&#x3D; &quot;.&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">one_answer.push_back(tmp);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">ans.push_back(one_answer);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;对于某一列，可选的有n行</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">if (v_row[i]&#x3D;&#x3D;0 &amp;&amp; v_line1[idx + i]&#x3D;&#x3D;0 &amp;&amp; v_line2[idx - i + n - 1]&#x3D;&#x3D;0)</span><br><span class="line">&#123;</span><br><span class="line">path[idx] &#x3D; i;</span><br><span class="line">v_row[i] &#x3D; 1;</span><br><span class="line">v_line1[idx + i] &#x3D; 1;</span><br><span class="line">v_line2[idx - i + n - 1] &#x3D; 1;</span><br><span class="line">dfs(idx + 1, n);</span><br><span class="line">v_row[i] &#x3D; 0;&#x2F;&#x2F;还原</span><br><span class="line">v_line1[idx + i] &#x3D; 0;</span><br><span class="line">v_line2[idx - i + n - 1] &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) &#123;</span><br><span class="line">v_row.resize(n);</span><br><span class="line">v_line1.resize(2*n);</span><br><span class="line">v_line2.resize(2*n);</span><br><span class="line">path.resize(n);</span><br><span class="line">for (int i &#x3D; 0; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">v_row[i] &#x3D; 0;</span><br><span class="line">path[i] &#x3D; -1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">for (int i &#x3D; 0; i &lt; 2*n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">v_line1[i] &#x3D; 0;</span><br><span class="line">v_line2[i] &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line">ans.clear();</span><br><span class="line">&#x2F;&#x2F;搜索列</span><br><span class="line">dfs(0, n);</span><br><span class="line">return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">int n &#x3D; 4;</span><br><span class="line">Solution s;</span><br><span class="line">vector&lt;vector&lt;string&gt;&gt; ans &#x3D; s.solveNQueens(4);</span><br><span class="line">for (vector&lt;vector&lt;string&gt;&gt;::iterator it &#x3D; ans.begin(); it !&#x3D; ans.end(); ++it)</span><br><span class="line">&#123;</span><br><span class="line">for (vector&lt;string&gt;::iterator it2 &#x3D; (*it).begin(); it2 !&#x3D; (*it).end(); ++it2)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; *it2 &lt;&lt; &quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 时间复杂度和状态空间数有关。 一种放置方法是一个状态，时间复杂度是<code>O(N^N)</code>。暴力算法的时间复杂度是很难计算的。有剪枝，要小于<code>O(N^N)</code>;</p><h2 id="骑士游历问题">3. 骑士游历问题</h2><p>重复的地方不能走，不重复不遗漏的遍历所有的格子，从左下角出发。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//走到哪个位置 (x,y);马在每个位置有八种走法，第一象限2中，四个象限八种。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (idx&gt;=n)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对于某一列，可选的有n行</span></span><br><span class="line"><span class="keyword">for</span> (!v[xi][yi])</span><br><span class="line">&#123;</span><br><span class="line">            v[xi][yi] = <span class="number">1</span>;</span><br><span class="line">            dfs(x,y);</span><br><span class="line">            v[xi][yi] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">v_row.resize(n);</span><br><span class="line">v_line1.resize(<span class="number">2</span>*n);</span><br><span class="line">v_line2.resize(<span class="number">2</span>*n);</span><br><span class="line">path.resize(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">v_row[i] = <span class="number">0</span>;</span><br><span class="line">path[i] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>*n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">v_line1[i] = <span class="number">0</span>;</span><br><span class="line">v_line2[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">ans.clear();</span><br><span class="line"><span class="comment">//搜索列</span></span><br><span class="line">dfs(<span class="number">0</span>, n);</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">4</span>;</span><br><span class="line">Solution s;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; ans = s.solveNQueens(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;::iterator it = ans.begin(); it != ans.end(); ++it)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::iterator it2 = (*it).begin(); it2 != (*it).end(); ++it2)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it2 &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启发式搜索(A*)A star：改变搜索顺序。 先走四个角，再走边上的，最后走中间的。</p><p>迭代加深(ID)：探测的方式</p><p>递归达到一定的深度就强制退出。</p><p>每一层是N的，每一层有n中情况，一共有D层，共有O(N^D)</p><p>best最优步数 1~best-1,都没有出现解，到best解出现，best之后的步数都能找到解。 迭代加深最优的时间复杂度<code>O(N^best)</code>;</p><p>NP问题指数灾难，降低指数大小。</p><p>不需要判重，不对的解已经被抛弃。 搜到即是最优。</p><p>迭代加深+启发式(IDA*)</p>]]></content>
      
      
      <categories>
          
          <category> data structures and algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>graph search part2</title>
      <link href="/2016/11/19/graph-search-part2/"/>
      <url>/2016/11/19/graph-search-part2/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> visited[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BFSSearch</span><span class="params">(Graph G)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;++v)</span><br><span class="line">    &#123;</span><br><span class="line">        visited[v] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.vexnum;++v)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[v])<span class="comment">//顶点v未被访问过</span></span><br><span class="line">        &#123;</span><br><span class="line">            visited[v] = <span class="number">1</span>;</span><br><span class="line">            Visit(v);</span><br><span class="line">            EnQueue(Q,v);</span><br><span class="line">            <span class="keyword">while</span>(!QueueEmpty(Q))</span><br><span class="line">            &#123;</span><br><span class="line">                DeQueue(Q,u);</span><br><span class="line">                <span class="keyword">for</span>(w=FirstAdjVex(G,u);w&gt;=<span class="number">0</span>;w=NextAdjVex(G,u,w))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!visited[w])<span class="comment">//w是v未被访问过的邻接顶点</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        visited[w] = <span class="number">1</span>;</span><br><span class="line">                        Visit(w);</span><br><span class="line">                        EnQueue(Q,w);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>种子填充法 Flood Fill洪水填充法 <a id="more"></a> ## 1. LeetCode 200. Number of Islands <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment">//队列</span></span><br><span class="line">    <span class="keyword">int</span> *qx = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000000</span>];</span><br><span class="line">    <span class="keyword">int</span> *qy = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;=<span class="number">0</span> &amp;&amp; x&lt;n &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;m &amp;&amp; grid[x][y]==<span class="string">'1'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            qx[r] = x;</span><br><span class="line">            qy[r] = y;</span><br><span class="line">            ++r;</span><br><span class="line">            <span class="comment">//扩散过标为无效</span></span><br><span class="line">            grid[x][y] = <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid,<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//队列头尾</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">        qx[<span class="number">0</span>]=x;</span><br><span class="line">        qy[<span class="number">0</span>]=y;</span><br><span class="line">        grid[x][y] = <span class="string">'0'</span>;</span><br><span class="line">        <span class="keyword">while</span>(h&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            r = check(qx[h]<span class="number">-1</span>,qy[h],grid,r,n,m);</span><br><span class="line">            r = check(qx[h],qy[h]<span class="number">-1</span>,grid,r,n,m);</span><br><span class="line">            r = check(qx[h]+<span class="number">1</span>,qy[h],grid,r,n,m);</span><br><span class="line">            r = check(qx[h],qy[h]+<span class="number">1</span>,grid,r,n,m);</span><br><span class="line">            ++h;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(grid.size()==<span class="number">0</span> || grid[<span class="number">0</span>].size()==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = grid.size();</span><br><span class="line">        <span class="keyword">int</span> m = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j]==<span class="string">'1'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    fill(i,j,grid,n,m);</span><br><span class="line">                    ++ans;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="leetcode-130.-surrounded-regions">2. LeetCode 130. Surrounded Regions</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//队列</span></span><br><span class="line">    <span class="keyword">int</span> *qx = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000000</span>];</span><br><span class="line">    <span class="keyword">int</span> *qy = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1000000</span>];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v;</span><br><span class="line">    <span class="keyword">bool</span> reverse;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r, <span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;=<span class="number">0</span> &amp;&amp; x&lt;n &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;m)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[x][y]==<span class="string">'O'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                qx[r] = x;</span><br><span class="line">                qy[r] = y;</span><br><span class="line">                ++r;</span><br><span class="line">                <span class="comment">//扩散过标为无效</span></span><br><span class="line">                grid[x][y] = <span class="string">'X'</span>;</span><br><span class="line">                v[x][y] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            reverse = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid,<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        reverse = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//队列头尾</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">        qx[<span class="number">0</span>]=x;</span><br><span class="line">        qy[<span class="number">0</span>]=y;</span><br><span class="line">        grid[x][y] = <span class="string">'X'</span>;</span><br><span class="line">        v[x][y]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(h&lt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            r = check(qx[h]<span class="number">-1</span>,qy[h],grid,r,n,m);</span><br><span class="line">            r = check(qx[h],qy[h]<span class="number">-1</span>,grid,r,n,m);</span><br><span class="line">            r = check(qx[h]+<span class="number">1</span>,qy[h],grid,r,n,m);</span><br><span class="line">            r = check(qx[h],qy[h]+<span class="number">1</span>,grid,r,n,m);</span><br><span class="line">            ++h;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(reverse)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;r; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                grid[qx[i]][qy[i]] = <span class="string">'O'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(board.size()==<span class="number">0</span> || board[<span class="number">0</span>].size()==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> n = board.size();</span><br><span class="line">        <span class="keyword">int</span> m = board[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;m;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.push_back(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            v.push_back(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j]==<span class="string">'O'</span> &amp;&amp; !v[i][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    fill(i,j,board,n,m);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="八数码">3. 八数码</h2><p>3*3的方格内有编号1-8的方块，求最少的步数，恢复这些方块的顺序</p><ul><li>深度优先 or 广度优先？answer:广度优先</li><li>判重（Hash）</li></ul><p>深度优先很难求最优，用迭代加深的方式可以求最优。<br />广度优先搜索搜到即是最优。</p><p>双向搜索</p><ul><li>起始点和目标点，轮流扩展</li><li>Hash表判断相遇</li><li>复杂度</li></ul><p>启发式</p><ul><li>价值函数（启发函数）</li><li>优先队列（堆）</li></ul><p>DFS vs BFS</p><ul><li>都为暴力搜索，但搜索顺序不同</li><li>栈 vs 队列</li><li>可行解 vs 最优解</li><li>递归 vs 非递归</li><li>空间占用，BFS需要存储状态，DFS无需</li></ul>]]></content>
      
      
      <categories>
          
          <category> data structures and algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>array problems</title>
      <link href="/2016/11/11/array-problems/"/>
      <url>/2016/11/11/array-problems/</url>
      
        <content type="html"><![CDATA[<h1 id="array-problems">Array Problems</h1><h2 id="求局部最大值">1. 求局部最大值</h2><ul><li>给定一个无重复元素的数组A[0...N-1]，求找到一个该数组的局部最大值。规定：在数 组边界外的值无穷小。即：A[0] &gt; A[-1]，A[N-1] &gt; A[N]。</li><li>显然，遍历一遍可以找到全局最大值，而全局最大值显然是局部最大值。</li><li>可否有更快的办法？</li></ul><a id="more"></a><p><strong>问题分析</strong></p><ul><li>定义：若子数组Array[from,...,to]满足<ul><li>Array[from] &gt; Array[from-1]</li><li>Array[to] &gt; Array[to+1]</li></ul></li><li>称该子数组为"高原数组"。<ul><li>若高原数组长度为1，则该高原数组的元素为<font color="red">局部最大值</font>。</li></ul></li><li>因为A[0] &gt; A[-1]，A[N-1] &gt; A[N]，所以数组本身就是一个高原数组。</li></ul><p>算法描述</p><ul><li>使用索引left、right分别指向数组首尾，根据定义，该数组为<font color="red">高原数组</font>。</li><li>求中点mid=(left+right)/2</li><li><font color="blue">A[mid]</font> &gt; A[mid+1]，子数组<font color="blue">A[left...mid]</font>为高原数组<ul><li>丢弃后半段：right=mid</li></ul></li><li><font color="blue">A[mid+1]</font> &gt; A[mid]，子数组<font color="blue">A[mid...right]</font>高原数组<ul><li>丢弃前半段：left=mid+1</li></ul></li><li>递归直至<font color="red">left==right</font><ul><li>时间复杂度为O(logN)。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">localMaximum</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *a, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> right = size - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (left &lt; right)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (a[mid] &gt; a[mid + <span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">right = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> a[left];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span> &#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; localMaximum(a,<span class="number">11</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第一个缺失的整数">2. 第一个缺失的整数</h2><ul><li>给定一个数组A[0...N-1]，找到从1开始，第一个不在数组中的正整数。如3,5,1,2,-3,7,14,8输出4。</li><li>思路一，bitmap，hash,初始化为0，有了赋值为1，没有保持为0，最后遍历一遍，找出第一个未出现的数字。</li></ul><p><strong>循环不变式</strong></p><ul><li>思路：将找到的元素放到正确的位置上，如果最终发现某个元素一直没有找到，则该元素即为所求。</li><li>循环不变式：如果某命题初始为真，且每次更改后仍然保持该命题为真，则若干次更改后该命题仍然为真。</li><li>为表述方便，下面的算法描述从1开始数。</li></ul><p><strong>利用循环不变式设计算法</strong></p><ul><li>假定前i-1个数已经找到，并且依次存放在A[1,2,...,i-1]中，继续考察A[i]：</li><li>若A[i] &lt; i且A[i] &gt;= 1，则A[i]在A[1,2,...,i-1]中已经出现过，可以直接丢弃。<ul><li>若A[i]为负，则更应该丢弃它。</li></ul></li><li>若A[i] &gt; i且A[i] &lt;= N，则A[i]应该位于后面的位置上，则将A[A[i]]和A[i]交换。<ul><li>若A[i] &gt; N，由于缺失数据一定小于N，则A[i]丢弃。</li></ul></li><li>若A[i]=i，则A[i]位于正确的位置上，则i加1，循环不变式扩大，继续比较后面的元素。</li></ul><p><strong>合并相同的分支</strong></p><ul><li>整理算法描述：<ul><li>若A[i] &lt; i 或者 A[i] &gt; N，则丢弃A[i]</li><li>若A[i] &gt; i，则将A[A[i]]和A[i]交换。</li><li>若A[i] = i，i加1，继续比较后面的元素。</li></ul></li><li>思考：如何快速丢弃A[i]？<ul><li>将A[N]赋值给A[i]，然后N减1。</li></ul></li></ul><p>code: <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findFirstMissingNumber</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">--a;<span class="comment">//从1开始数</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= N)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] &lt; i || a[i] &gt; N)</span><br><span class="line">&#123;</span><br><span class="line">a[i] = a[N];</span><br><span class="line">--N;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a[i] &gt; i)</span><br><span class="line">&#123;</span><br><span class="line">swap(a[a[i]], a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// if(a[i]==i)</span></span><br><span class="line">&#123;</span><br><span class="line">++i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">-3</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">8</span> &#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; findFirstMissingNumber(a,<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="查找旋转数组循环数组的最小值">3. 查找旋转数组（循环数组）的最小值</h2><ul><li>假定一个排序数组以某个未知元素为支点做了旋转，如：原数组<font color="red">0 1 2</font> <font color="blue">4 5 6 7</font>旋转后得到<font color="blue">4 5 6 7</font> <font color="red">0 1 2</font>。请找出旋转后数组的最小值。假定数组中没有重复数字。</li></ul><p><strong>分析</strong></p><ul><li>旋转之后的数组实际上可以划分成两个有序的子数组：前面子数组的大小都大于后面子数组中的元素（这个性质很重要）；</li><li>4 5 6 7 0 1 2</li><li>注意到实际上最小的元素就是两个子数组的分界线。</li></ul><p><strong>寻找循环数组最小值：4 5 6 7 0 1 2</strong></p><ul><li>用索引left，right分别指向首尾元素，元素不重复。<ul><li>若子数组是<font color="red">普通升序数组</font>，则<font color="red">A[left] &lt; A[right]</font>。</li><li>若子数组是<font color="blue">循环升序数组</font>，前半段子数组的元素全都大于后半段子数组中的元素：<font color="blue">A[left] &gt; A[right]</font>(最小值在循环升序数组中)</li></ul></li><li>计算中间位置mid = (low+high)/2;<ul><li>显然，A[low...mid]与A[mid+1...high]必有一个是循环升序数组，一个是普通升序数组。</li><li>若：A[mid] &gt; A[high]，说明子数组A[mid+1,mid+2,...high]循环升序；更新low=mid+1；</li><li>若：A[mid] &lt; A[high]，说明子数组A[mid+1,mid+2,...high]普通升序；更新：high=mid</li></ul></li></ul><h2 id="零子数组">4. 零子数组</h2><ul><li>求对于长度为N的数组A，求连续子数组的和最接近0的值。</li><li>如：数组A：1, -2, 3, 10, -4, 7, 2, -5</li><li>它是所有子数组中，和最接近0的是哪个？</li></ul><p><strong>算法流程</strong></p><ul><li>申请比A长1的空间sum[0...,N-1,N]，sum[i]是A的前i项和。<ul><li>定义sum[0] = 0</li></ul></li><li>显然有：<span class="math inline">\(\sum_{k=i}^{j} A_{k} = sum(j)-sum(i-1)\)</span></li><li>算法思路：<ul><li>对sum[0...,N-1,N]排序，然后计算sum相邻元素的差的绝对值，最小值即为所求</li><li>在A中任意取两个前缀子数组的和求差的最小值</li></ul></li></ul><p><strong>零子数组的讨论</strong></p><ul><li>计算前n项和数组sum和计算sum相邻元素差的时间复杂度，都是O(N)，排序的时间复杂 度认为是O(NlogN)，因此，总时间复杂度：O(NlogN)。</li><li>思考：如果需要返回绝对值最小的子数组本身呢？排序的时候记录是前几项和。看一看公式就明白了。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minSubArraySum</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *sum = <span class="keyword">new</span> <span class="keyword">int</span>[N + <span class="number">1</span>];</span><br><span class="line">sum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//sum[i]: a[0]+a[1]+...+a[i-1]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">&#123;</span><br><span class="line">sum[i + <span class="number">1</span>] = sum[i] + a[i];</span><br><span class="line">&#125;</span><br><span class="line">sort(sum, sum + N + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> difference = <span class="built_in">abs</span>(sum[<span class="number">1</span>] - sum[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> t = <span class="built_in">abs</span>(sum[i + <span class="number">1</span>] - sum[i]);</span><br><span class="line">difference = min(difference, t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] sum;</span><br><span class="line"><span class="keyword">return</span> difference;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span>,<span class="number">-2</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">-4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">-5</span> &#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; minSubArraySum(a,<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大子数组和">5. 最大子数组和</h2><ul><li>给定一个数组A[0,...,n-1]，求A的连续子数组，使得该子数组的和最大。</li><li>例如，数组： 1, -2, 3, 10, -4, 7, 2, -5</li><li>最大子数组：3, 10, -4, 7, 2</li></ul><p><strong>分析</strong><br />解法一：</p><ul><li>定义：前缀和sum[i] = a[0] + a[1] + ... + a[i]</li><li>则：a[i,j]=sum[j]-sum<a href="定义p%5B-1%5D%20=%200">i-1</a></li><li><span class="math inline">\(\sum_{k=i}^{j} A_{k} = sum(j)-sum(i-1)\)</span></li></ul><p>算法过程:</p><ol type="1"><li>求i前缀sum[i]：<ul><li>遍历i：0 &lt;= i &lt;= n-1</li><li>sum[i] = sum[i-1] + a[i]</li></ul></li><li>计算以a[i]结尾的子数组的最大值<ul><li>对于某个i：遍历0 &lt;= j &lt;= i，求sum[j]的最小值m</li><li>sum[i]-m 即为以a[i]结尾的数组中最大的子数组的值</li></ul></li><li>统计 sum[i]-m 的最大值， 0 &lt;= i &lt;= n-1</li></ol><p>1 2 3步都是线性的，因此，时间复杂度O(n)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArraySum</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *sum = <span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">1</span>];</span><br><span class="line">sum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//sum[i]: a[0]+a[1]+...+a[i-1]</span></span><br><span class="line"><span class="keyword">int</span> min = <span class="number">99999</span>;</span><br><span class="line"><span class="keyword">int</span> minIndex = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> maxIndex = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> max = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">&#123;</span><br><span class="line">sum[i+<span class="number">1</span>] = sum[i] + a[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (min &gt; sum[j])</span><br><span class="line">&#123;</span><br><span class="line">min = sum[j];</span><br><span class="line">minIndex = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (max &lt; sum[i+<span class="number">1</span>] - min)</span><br><span class="line">&#123;</span><br><span class="line">max = sum[i+<span class="number">1</span>] - min;</span><br><span class="line">maxIndex = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; minIndex &lt;&lt; <span class="string">" "</span> &lt;&lt; maxIndex &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">delete</span>[] sum;</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span>,<span class="number">-2</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">-4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">-5</span> &#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; maxSubArraySum(a,<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>进一步的分析</strong></p><ul><li>记S[i]为<font color="purple">以A[i]结尾</font>的数组中和最大的子数组</li><li>则：S[i+1] = max( S[i] + A[i+1], A[i+1] )</li><li>S[0] = A[0]</li><li>遍历i： 0 &lt;= i &lt;= n-1</li><li>动态规划：最优子问题</li><li>时间复杂度：O(n)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArraySumDP1</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sum[0] = a[0];</span></span><br><span class="line"><span class="comment">sum[i] =  max(sum[i-1]+a[i],a[i]);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> sum = a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> from = <span class="number">0</span>, to = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> fromNew;</span><br><span class="line"><span class="keyword">int</span> result = sum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i)</span><br><span class="line">&#123;</span><br><span class="line">sum = sum + a[i];</span><br><span class="line"><span class="comment">//sum = max(sum, a[i]);</span></span><br><span class="line"><span class="keyword">if</span> (sum &lt; a[i])</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">sum = a[i];</span><br><span class="line">fromNew = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (result &lt; sum)</span><br><span class="line">&#123;</span><br><span class="line">result = sum;</span><br><span class="line">from = fromNew;</span><br><span class="line">to = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; from &lt;&lt; <span class="string">" "</span> &lt;&lt; to &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArraySumDP2</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sum[0] = a[0];</span></span><br><span class="line"><span class="comment">sum[i] =  max(sum[i-1]+a[i],a[i]);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">int</span> sum = a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> startIndex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> endIndex = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> result = sum;</span><br><span class="line"><span class="keyword">int</span> from, to;</span><br><span class="line"><span class="keyword">int</span> fromNew;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (sum &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">sum = sum + a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">sum = a[i];</span><br><span class="line">fromNew = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (result &lt; sum)</span><br><span class="line">&#123;</span><br><span class="line">result = sum;</span><br><span class="line">from = fromNew;</span><br><span class="line">to = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; from &lt;&lt; <span class="string">" "</span> &lt;&lt; to &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span>,<span class="number">-2</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">-4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">-5</span> &#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; maxSubArraySumDP2(a,<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大间隔">6. 最大间隔</h2><ul><li>给定整数数组A[0...N-1]，求这N个数排序后最大间隔。如：1,7,14,9,4,13的最大间隔为4。</li><li>排序后：1,4,7,9,13,14，最大间隔是13-9=4</li><li>显然，对原数组排序，然后求后项减前项的最大值，即为解。</li><li>可否有更好的方法？</li></ul><p><strong>问题分析</strong></p><ul><li>假定N个数的最大最小值为max，min，则这N个数形成N-1个间隔，其最小值是<span class="math inline">\(\frac{max-min}{N-1}\)</span></li><li>如果N个数完全均匀分布，则间距全部是<span class="math inline">\(\frac{max-min}{N-1}\)</span>且最小；</li><li>如果N个数不是均匀分布，间距不均衡，则最大间距必然大于<span class="math inline">\(\frac{max-min}{N-1}\)</span></li></ul><p><strong>解决思路</strong></p><ul><li>思路：将N个数用间距<span class="math inline">\(\frac{max-min}{N-1}\)</span>分成N-1个区间，则落在同一区间内的数不可能有最大间距。统计后一区间的最小值与前一区间的最大值的差即可。</li><li>若没有任何数落在某区间，则该区间无效，不参与统计。</li><li>显然，这是借鉴桶排序/Hash映射的思想。</li></ul><p><strong>桶的数目</strong></p><ul><li>同时，N-1个桶是理论值，会造成若干个桶的数目比其他桶大1，从而造成统计误差。</li><li>如：7个数，假设最值为10、80，如果使用6个桶，则桶的大小为70/6=11.66，每个桶分别为： [10,21]、[22,33]、[34,44]、[45,56]、[57,68]、[69,80]，存在大小为12的桶，比理论下界11.66大。（10-21桶的大小是12，34-44的大小是11）</li><li>因此，使用N个桶。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bucket</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">bool</span> valid;<span class="comment">//valiad是否有值落在桶内。</span></span><br><span class="line"><span class="keyword">int</span> min;</span><br><span class="line"><span class="keyword">int</span> max;</span><br><span class="line">Bucket():valid(<span class="literal">false</span>)&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!valid)</span><br><span class="line">&#123;</span><br><span class="line">min = max = n;</span><br><span class="line">valid = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (max &lt; n)</span><br><span class="line">&#123;</span><br><span class="line">max = n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (min &gt; n)</span><br><span class="line">&#123;</span><br><span class="line">min = n;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calMaxGap</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *A, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//初始化桶</span></span><br><span class="line">Bucket *bucket = <span class="keyword">new</span> Bucket[size];</span><br><span class="line"><span class="comment">//求最值</span></span><br><span class="line"><span class="keyword">int</span> max = A[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> min = A[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; size; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (max &lt; A[i])</span><br><span class="line">&#123;</span><br><span class="line">max = A[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (min &gt; A[i])</span><br><span class="line">&#123;</span><br><span class="line">min = A[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//依次将数据放入桶中</span></span><br><span class="line"><span class="keyword">int</span> len = max - min;</span><br><span class="line"><span class="keyword">int</span> number;<span class="comment">//某数应该放在哪个桶中</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">&#123;</span><br><span class="line">number = (A[i] - min)*size / len;</span><br><span class="line"><span class="keyword">if</span> (number &gt;= size)</span><br><span class="line">&#123;</span><br><span class="line">number = size - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">bucket[number].add(A[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算最大间隔</span></span><br><span class="line">i = <span class="number">0</span>;<span class="comment">//首个桶一定是有效的</span></span><br><span class="line"><span class="keyword">int</span> maxGap = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> gap;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; size; ++j)<span class="comment">//i是前一个桶，j是后一个桶</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (bucket[j].valid)</span><br><span class="line">&#123;</span><br><span class="line">gap = bucket[j].min - bucket[i].max;</span><br><span class="line"><span class="keyword">if</span> (gap &gt; maxGap)</span><br><span class="line">&#123;</span><br><span class="line">maxGap = gap;</span><br><span class="line">&#125;</span><br><span class="line">i = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxGap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span>,<span class="number">7</span>,<span class="number">14</span>,<span class="number">9</span>,<span class="number">4</span>,<span class="number">13</span>&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; calMaxGap(a,<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="cantor数组">7. Cantor数组</h2><ul><li>已知数组A[0...N-1]乱序着前N个正整数(数组的值是1到N的)，现统计后缀数组A[i+1...N-1]中小于元素A[i]的数目，并存放在数组C[i]中。如给定数组A={4,6,2,5,3,1}，得到数组C={3,4,1,2,1,0}。</li><li>问：给定数组C={3,4,1,2,1,0}，如何恢复数组A？</li><li>我们称A为原数组，C为Cantor数组。</li></ul><p>原数组 -&gt; Cantor数组<br />code:<br /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cantorExpansion</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">&#123;</span><br><span class="line">b[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; size; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[j] &lt; a[i])</span><br><span class="line">&#123;</span><br><span class="line">++b[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">4</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> size = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">int</span> *b = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">cantorExpansion(a, b, size);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>问题分析</strong></p><p>example:</p><ul><li>Cantor数组：{3,4,1,2,1,0}</li><li>原数组： {4,6,2,5,3,1}</li></ul><p>思路：</p><ul><li>给定顺序数组B={1,2,3...N-1,N}，从0开始数</li><li>考察Cantor数组的首位C[0]：小于A[0]的个数为C[0]，则A[0]为B[C[0]]。首位一定能确定。</li><li>在序列数组B中删除B[C[0]]，仍然满足以上性质。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//加一个size,维护已知的大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> *b, <span class="keyword">int</span> index,<span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = index + <span class="number">1</span>; i &lt; size; ++i)</span><br><span class="line">&#123;</span><br><span class="line">b[i - <span class="number">1</span>] = b[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cantorExpansionR</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> *c, <span class="keyword">int</span> *a, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> *seq = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">&#123;</span><br><span class="line">seq[i] = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> t = size;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">&#123;</span><br><span class="line">a[i] = seq[c[i]];</span><br><span class="line">remove(seq, c[i],t--);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> c[] = &#123; <span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> size = <span class="keyword">sizeof</span>(c) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">cantorExpansionR(c, a, size);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>进一步思考</strong></p><ul><li>以上代码空间复杂度为O(N)，时间复杂度为O(N^2)，若允许更改数组C，可否降低空间复杂度？<ul><li>Cantor数组：{3,4,1,2,1,0}</li><li>原数组：{4,6,2,5,3,1}</li></ul></li><li>考察Cantor数组中<font color="red">第一个出现0</font>的位置：它表示位于该位置右侧的所有元素都大于该元素，则该元素必然是<font color="red">最小的</font>。<ul><li>每次找到第一个0后，将0左侧的Cantor值都减一，重复以上操作。(如果该处已经赋值过，就跳过)</li><li>空间复杂度为O(1)。</li></ul></li><li>从左往右找第一个最小的。两种思路完全不一样。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cantorExpansionR2</span><span class="params">(<span class="keyword">int</span> *c, <span class="keyword">int</span> *result, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(result, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int</span>)*size);</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; size; ++j)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (result[j] != <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span> (c[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">--c[j];</span><br><span class="line">&#125;</span><br><span class="line">result[j] = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> c[] = &#123; <span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> size = <span class="keyword">sizeof</span>(c) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">cantorExpansionR2(c, a, size);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">^ 此处已经赋值过了</span><br></pre></td></tr></table></figure><p><strong>总结与思考</strong> - "Cantor数组"：{3,4,1,2,1,0} - 原数组：{4,6,2,5,3,1} - 将Cantor数组的每个元素都指定各自的权重：c[i]的权重为(n-1-i)的阶乘，则Cantor数组与一个整数一一对应，该数称为原数组的<font color="red">Cantor展开数</font>，从<font color="red">Cantor展开数</font>求Cantor数组的过程称为<font color="red">Cantor展开</font>。c[0]的权重为(6-1-0)!=5！，即c<a href="3">0</a>的权重为5!。c[i]为后面右边有几个数。数组任何一个数是互不相等的，看做是N个元素的一个排列，那么这个排列是第几个？就是cantor展开数。 - Cantor数组中元素的和，表示原数组中<font color="red">逆序对</font>的个数，问：给定数组A，如果计算A的逆序对个数？ - cantor数组的意义就是右边有几个数比该值小，所以cantor数组的和就是逆序对的个数。3表示3后面的数有几个比3的值要小。 - 思考时间复杂度为O(NlogN)的算法（归并排序）。</p><h2 id="子集和数问题n-sum">8. 子集和数问题N-Sum</h2><ul><li>已知数组A[0...N-1]，给定某数值sum，找出数组中的若干个数，使得这些数的和为sum。</li><li>布尔向量x[0...N-1]</li><li>x[i]=0表示不取A[i]，x[i]=1表示取A[i]</li><li>假定数组中的元素都大于0：A[i] &gt; 0</li><li>这是个NP问题！</li></ul><p><strong>分析方法</strong></p><ul><li>直接递归法(枚举)</li><li>分支限界</li><li>存在负数的处理办法</li></ul><p>直接递归法（暴力搜索法）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//bool *x = new bool[n];</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">bool</span> *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (x[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从前往后搜索（从后往前搜索也是一样的）</span></span><br><span class="line"><span class="comment">//idx当前搜索到第几个数,has当前已有的加和，x存储结果</span></span><br><span class="line"><span class="comment">//has是a[0]+a[1]+...+a[idx-1]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span> has, <span class="keyword">bool</span> *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (idx &gt;= n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (has + a[idx] == sum)</span><br><span class="line">&#123;</span><br><span class="line">x[idx] = <span class="literal">true</span>;</span><br><span class="line">print(x);</span><br><span class="line">x[idx] =<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">x[idx] = <span class="literal">true</span>;</span><br><span class="line">search(idx + <span class="number">1</span>, has + a[idx], x);</span><br><span class="line">x[idx] = <span class="literal">false</span>;</span><br><span class="line">search(idx + <span class="number">1</span>, has, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> *x = <span class="keyword">new</span> <span class="keyword">bool</span>[n];</span><br><span class="line"><span class="built_in">memset</span>(x, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">bool</span>)*n);</span><br><span class="line">search(<span class="number">0</span>, <span class="number">0</span>, x);</span><br><span class="line"><span class="keyword">delete</span>[] x;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>考虑对于分支如何限界</strong></p><ul><li>前提：数组A[0...N-1]的元素都大于0</li><li>考察向量x[0...N-1]，假定已经确定了前i个值，现在要判定第i+1个值x[i]为0还是1。</li><li>假定由x[0...i-1]确定的A[0...i-1]的和为has；</li><li>A[i,i+1,...N-1]的和为residue(简记为r)；<ul><li>has+a[i] &lt;= sum并且has+r &gt;= sum：x[i]可以为1；</li><li>has+(r-a[i]) &gt;= sum：x[i]可以为0；</li><li>注意，这里是“可以”——可以能够：可能。</li></ul></li><li>怎么想上面的分支限界条件呢？就是考虑a[i]要不要取。根据取不取a[i]来确定边界条件。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">40</span>;</span><br><span class="line"><span class="comment">//bool *x = new bool[n];</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum_</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">sum += a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">bool</span> *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (x[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从前往后搜索（从后往前搜索也是一样的）</span></span><br><span class="line"><span class="comment">//idx当前搜索到第几个数,has当前已有的加和，x存储结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span> has, <span class="keyword">bool</span> *x, <span class="keyword">int</span> residue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (idx &gt;= n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (has + a[idx] == sum)</span><br><span class="line">&#123;</span><br><span class="line">x[idx] = <span class="literal">true</span>;</span><br><span class="line">print(x);</span><br><span class="line">x[idx] = <span class="literal">false</span>;<span class="comment">//加上</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (has + a[idx] &lt;= sum &amp;&amp; has + residue &gt;= sum)</span><br><span class="line">&#123;</span><br><span class="line">x[idx] = <span class="literal">true</span>;</span><br><span class="line">search(idx + <span class="number">1</span>, has + a[idx], x, residue - a[idx]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (has + residue - a[idx] &gt;= sum)</span><br><span class="line">&#123;</span><br><span class="line">x[idx] = <span class="literal">false</span>;</span><br><span class="line">search(idx + <span class="number">1</span>, has, x, residue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> *x = <span class="keyword">new</span> <span class="keyword">bool</span>[n];</span><br><span class="line"><span class="keyword">int</span> residue = sum_(a,n);</span><br><span class="line"><span class="built_in">memset</span>(x, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">bool</span>)*n);</span><br><span class="line">search(<span class="number">0</span>, <span class="number">0</span>, x, residue);</span><br><span class="line"><span class="keyword">delete</span>[] x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>数理逻辑的重要应用：分支限界的条件</strong></p><ul><li>分支限界的条件是充分条件吗？不是充分条件是必要条件。</li><li>在新题目中，如何发现分支限界的条件。</li><li>学会该方法，比此问题本身更重要</li></ul><p><strong>考虑负数的情况</strong></p><ul><li>枚举法肯定能得到正确的解</li><li>如何对负数进行分支限界？</li><li>可对整个数组A[0...N-1]正负排序，使得负数都在前面，正数都在后面，使用剩余正数的和作为分支限界的约束：</li><li>如果A[i]为负数：如果全部剩余正数都算上还不够，就不能选A[i]；</li><li>如果递归进入了正数范围，按照数组是全正数的情况正常处理；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">-3</span>,<span class="number">-5</span>,<span class="number">-2</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> n = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">5</span>;</span><br><span class="line"><span class="comment">//bool *x = new bool[n];</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sum_</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> n, <span class="keyword">int</span>&amp; negtive, <span class="keyword">int</span>&amp; positive)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">negtive = <span class="number">0</span>;</span><br><span class="line">positive = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">negtive += a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">positive += a[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">bool</span> *x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (x[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//从前往后搜索（从后往前搜索也是一样的）</span></span><br><span class="line"><span class="comment">//idx当前搜索到第几个数,has当前已有的加和，x存储结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">search</span><span class="params">(<span class="keyword">int</span> idx, <span class="keyword">int</span> has, <span class="keyword">bool</span> *x, <span class="keyword">int</span> negtive, <span class="keyword">int</span> positive)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (idx &gt;= n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (has + a[idx] == sum)</span><br><span class="line">&#123;</span><br><span class="line">x[idx] = <span class="literal">true</span>;</span><br><span class="line">print(x);</span><br><span class="line">x[idx] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a[idx] &gt;= <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//两种情况下都跳过了一个正数</span></span><br><span class="line"><span class="keyword">if</span> (has + a[idx] &lt;= sum &amp;&amp; has + positive &gt;= sum)</span><br><span class="line">&#123;</span><br><span class="line">x[idx] = <span class="literal">true</span>;</span><br><span class="line">search(idx + <span class="number">1</span>, has + a[idx], x, negtive, positive - a[idx]);</span><br><span class="line">x[idx] = <span class="literal">false</span>;<span class="comment">//这句话一定要加上</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (has + positive - a[idx] &gt;= sum)</span><br><span class="line">&#123;</span><br><span class="line">x[idx] = <span class="literal">false</span>;</span><br><span class="line">search(idx + <span class="number">1</span>, has, x, negtive, positive-a[idx]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//负数情况</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//两种情况下都跳过了一个负数</span></span><br><span class="line"><span class="comment">//既然是选择x[idx]条件里一定要加上x[idx]</span></span><br><span class="line"><span class="keyword">if</span> (has + a[idx] + positive &gt;= sum)</span><br><span class="line">&#123;</span><br><span class="line">x[idx] = <span class="literal">true</span>;</span><br><span class="line">search(idx + <span class="number">1</span>, has + a[idx], x, negtive - a[idx], positive);</span><br><span class="line">x[idx] = <span class="literal">false</span>;<span class="comment">//这句话一定要加上，还原现场</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (has + negtive &lt;= sum &amp;&amp; has + positive &gt;= sum)</span><br><span class="line">&#123;</span><br><span class="line">x[idx] = <span class="literal">false</span>;</span><br><span class="line">search(idx + <span class="number">1</span>, has, x, negtive - a[idx], positive);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> *x = <span class="keyword">new</span> <span class="keyword">bool</span>[n];</span><br><span class="line"><span class="keyword">int</span> negtive = <span class="number">0</span>, positive = <span class="number">0</span>;</span><br><span class="line">sum_(a, n, negtive, positive);</span><br><span class="line"><span class="built_in">memset</span>(x, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">bool</span>)*n);</span><br><span class="line">search(<span class="number">0</span>, <span class="number">0</span>, x, negtive, positive);</span><br><span class="line"><span class="keyword">delete</span>[] x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完美洗牌算法">完美洗牌算法</h2><p>先不介绍...</p>]]></content>
      
      
      <categories>
          
          <category> data structures and algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tree</title>
      <link href="/2016/10/15/tree/"/>
      <url>/2016/10/15/tree/</url>
      
        <content type="html"><![CDATA[<h1 id="tree">Tree</h1><h2 id="tree-terminology">1. Tree Terminology</h2><ul><li>Root: node without parent (A)</li><li>Siblings(兄弟): nodes share the same parent</li><li>Internal node(内部结点): node with at least one child (A, B, C, F)</li><li>External node (leaf ): node without children (E, I, J, K, G, H, D)</li><li>Ancestors (祖先)of a node: parent, grandparent, grand-grandparent, etc.</li><li>Descendant(后裔) of a node: child, grandchild, grand-grandchild, etc.</li></ul><a id="more"></a><figure><img src="tree-terminology.png" alt="" /><figcaption>Tree Terminology</figcaption></figure><ul><li>Depth of a node: number of ancestors</li><li>Height of a tree: maximum depth of any node</li><li>Degree of a node: the number of its children</li><li>Degree of a tree: the maximum number of its node.</li><li>Subtree: tree consisting of a node and its descendants</li></ul><figure><img src="tree-terminology-2.png" alt="" /><figcaption>Tree Terminology</figcaption></figure><h2 id="a-problem-often-in-exam-of-data-structure">2. A problem often in exam of data structure</h2><figure><img src="problem-of-tree-1.png" alt="" /><figcaption>Tree Problem</figcaption></figure><p>solution:</p><h2 id="print-arithmetic-expressions">3. Print Arithmetic Expressions</h2><figure><img src="print-arithmetic-expressions.png" alt="" /><figcaption>Print Arithmetic Expression</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt; <span class="title">void</span> <span class="title">BinaryTree</span>&lt;Type&gt; :</span>: Outputexpress ( <span class="keyword">const</span> BinTreeNode &lt;Type&gt; *T )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (T)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;leftChild != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"("</span>);</span><br><span class="line">Outputexpress(T-&gt;leftChild);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; T-&gt;data;</span><br><span class="line">    <span class="keyword">if</span>(T-&gt;rightChild != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">Outputexpress(T-&gt;rightChild);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">")"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求表达式的值">4. 求表达式的值</h2><figure><img src="evaluate-arithmetic-expressions.png" alt="" /><figcaption>Evaluate Arithmetic Expressions</figcaption></figure><h2 id="create-a-binary-tree-through-preorder-sequence">5. Create a Binary Tree through Preorder Sequence</h2><figure><img src="create-a-btree-through-preorder-sequence.png" alt="" /><figcaption>Create a Binary Tree through Preorder Sequence</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt; <span class="title">void</span> <span class="title">BinaryTree</span>&lt;Type&gt;:</span>: CreateBinaryTree()</span><br><span class="line">&#123;</span><br><span class="line">   CreateBinaryTree(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt; <span class="title">void</span> <span class="title">BinaryTree</span>&lt;Type&gt;:</span>: CreateBinaryTree(BiTreeNode *T)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(&amp;ch);                    <span class="comment">//get a char</span></span><br><span class="line">    <span class="keyword">if</span> (ch==‘*’)</span><br><span class="line">    &#123;</span><br><span class="line">    T=<span class="literal">NULL</span>;       <span class="comment">//if it denotes an empty tree</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span>(!(T= <span class="keyword">new</span> BiTreeNode&lt;Type&gt;()))</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);              <span class="comment">//allocated failed</span></span><br><span class="line">        &#125;</span><br><span class="line">        T-&gt;data = ch;</span><br><span class="line">        CreateBiTree(T-&gt;leftChild); <span class="comment">//creates its left subtree</span></span><br><span class="line">        CreateBiTree(T-&gt;rightChild); <span class="comment">//creates its right subtree</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pathlength">6. PathLength</h2><figure><img src="path-length.png" alt="" /><figcaption>Path Length</figcaption></figure><h2 id="numberoftree-and-numberofleaf">7. NumberofTree and NumberofLeaf</h2><p>Algorithm NumberofTree(v, n) Input: a tree node v and an initial value n Output: the number of nodes with root v Usage: leafn = NumberofTree(root, 0);</p><p>Algorithm NumberofLeaf(v, n) Input: a tree node v and an initial value n Output: the number of leaf nodes with root v Usage: leafn = Numberofleaf(root, 0);</p>]]></content>
      
      
      <categories>
          
          <category> data structures and algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dsa </tag>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stacks and Queues</title>
      <link href="/2016/10/14/Stacks-and-Queues/"/>
      <url>/2016/10/14/Stacks-and-Queues/</url>
      
        <content type="html"><![CDATA[<h2 id="stack">1. Stack</h2><p>A stack is a list in which insertion and deletion take place at the same end</p><ul><li>This end is called top</li><li>The other end is called bottom</li></ul><p>Stacks are known as LIFO (Last In, First Out) lists.</p><ul><li>The last element inserted will be the first to be retrieved.</li></ul><a id="more"></a><figure><img src="stack-adt.png" alt="" /><figcaption>Stack ADT</figcaption></figure><h3 id="data-structures----stacks">1.1 Data Structures -- Stacks</h3><p>Operations of Stack</p><ul><li>IsEmpty: return true if stack is empty, return false otherwise</li><li>IsFull: return true if stack is full, return false otherwise</li><li>top: return the element at the top of stack</li><li>Push: add an element to the top of stack</li><li>Pop: delete the element at the top of stack</li><li>displayStack: print all the data in the stack</li></ul><figure><img src="dsa-stacks.png" alt="" /><figcaption>Stack ADT</figcaption></figure><h3 id="implementation-of-stacks">1.2 Implementation of Stacks</h3><p>Any list implementation could be used to implement a stack</p><ol type="1"><li>Arrays<ul><li>static: the size of stack is given initially</li></ul></li><li>Linked lists<ul><li>dynamic: never become full</li></ul></li></ol><h4 id="array-implementation-of-stacks">1.2.1 Array Implementation of Stacks</h4><p>Attributes of Stack:</p><ul><li>stacksize: the max size of stack</li><li>top: the Address of the top element of stack</li><li>base: points to structure storing elements of stack</li></ul><p><strong>ADT of Stacks Implmented by Array</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">    Type *elements;</span><br><span class="line">    <span class="keyword">int</span> maxSize;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stack(<span class="keyword">int</span> size = <span class="number">10</span>);<span class="comment">//构造函数</span></span><br><span class="line">    ~Stack()&#123; <span class="keyword">delete</span> []elements; &#125;<span class="comment">//析构函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">const</span> Type&amp; item)</span></span>;<span class="comment">//进栈</span></span><br><span class="line">    <span class="function">Type <span class="title">Pop</span><span class="params">()</span></span>;<span class="comment">//出栈</span></span><br><span class="line">    <span class="function">Type <span class="title">GetTop</span><span class="params">()</span></span>;<span class="comment">//取出栈顶元素</span></span><br><span class="line">    <span class="comment">//从0开始</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MakeEmpty</span><span class="params">()</span></span>&#123; top = <span class="number">-1</span>; &#125;<span class="comment">//置空栈</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> top == <span class="number">-1</span>; &#125;<span class="comment">//判断栈是否是空的</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">IsFull</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> top == maxSize<span class="number">-1</span>; &#125;<span class="comment">//判断栈是否已满</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Stack</span>&lt;Type&gt;:</span>:Stack(<span class="keyword">int</span> s): top(<span class="number">-1</span>), maxSize(s)</span><br><span class="line">&#123;</span><br><span class="line">    elements = <span class="keyword">new</span> Type[maxSize];</span><br><span class="line">    assert(elements != <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//allocate a stack array of maxSize</span></span><br><span class="line">    <span class="comment">//initially top is set to -1, it means the stack is empty</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. Note: Is there spare space?</span></span><br><span class="line"><span class="comment">// 2. Push an element onto the stack</span></span><br><span class="line"><span class="comment">// 3. Note top always represents the index of the top element, After pushing an element, increase top</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Stack</span>&lt;Type&gt;:</span>:Push(<span class="keyword">const</span> Type&amp; item)</span><br><span class="line">&#123;    </span><br><span class="line">    assert(!IsFull());<span class="comment">//判断是否有空闲空间</span></span><br><span class="line">    elements[++top] = item;<span class="comment">//加入新元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Pop Stack</span></span><br><span class="line"><span class="comment">// 1. Note : Is there any elements in the stack?</span></span><br><span class="line"><span class="comment">// 2. Pop and return the element at the top of the stack. Don't forget to decrease top</span></span><br><span class="line"><span class="comment">// 若栈不为空则函数返回该栈顶元素的值，然后栈顶指针退1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Type</span> <span class="title">Stack</span>&lt;Type&gt;:</span>:Pop()</span><br><span class="line">&#123;</span><br><span class="line">    assert(!IsEmpty());<span class="comment">//先决条件断言</span></span><br><span class="line">    <span class="keyword">return</span> elements[top--];<span class="comment">//退出栈顶元素</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Type</span> <span class="title">Stack</span>&lt;Type&gt;:</span>:GetTop()</span><br><span class="line">&#123;</span><br><span class="line">    assert(!IsEmpty());</span><br><span class="line">    <span class="keyword">return</span> elements[top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        a.Push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a.GetTop()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        a.Pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="implementation-based-on-linked-list">1.2.2 Implementation based on Linked List</h4><figure><img src="implementation-based-on-linked-list.png" alt="" /><figcaption>Implementation based on Linked List</figcaption></figure><figure><img src="push-of-list-stack.png" alt="" /><figcaption>Push Operation of Stack Implementation based on Linked List</figcaption></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt; <span class="title">class</span> <span class="title">Stack</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt; <span class="title">class</span> <span class="title">StackNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Type data;<span class="comment">//结点数据</span></span><br><span class="line">    StackNode&lt;Type&gt; *link;<span class="comment">//结点链接指针</span></span><br><span class="line">    StackNode(Type d = <span class="number">0</span>, StackNode&lt;Type&gt; *l = <span class="literal">NULL</span>):data(d),link(l)&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt; <span class="title">class</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    StackNode&lt;Type&gt; *top;<span class="comment">//栈顶指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stack():top(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">    ~Stack();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(<span class="keyword">const</span> Type&amp; item)</span></span>;</span><br><span class="line">    <span class="function">Type <span class="title">Pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Type <span class="title">GetTop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MakeEmpty</span><span class="params">()</span></span>;<span class="comment">//实现与~Stack()相同</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> top == <span class="literal">NULL</span>; &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Stack</span>&lt;Type&gt;:</span>:~Stack()</span><br><span class="line">&#123;</span><br><span class="line">    StackNode&lt;Type&gt; *p;</span><br><span class="line">    <span class="keyword">while</span>(top!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = top;</span><br><span class="line">        top = top-&gt;link;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Stack</span>&lt;Type&gt;:</span>:Push(<span class="keyword">const</span> Type&amp; item)</span><br><span class="line">&#123;</span><br><span class="line">    top = <span class="keyword">new</span> StackNode&lt;Type&gt;(item,top);</span><br><span class="line">    <span class="comment">//新结点链入top之后，并称为新栈顶</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Type</span> <span class="title">Stack</span>&lt;Type&gt;:</span>:Pop()</span><br><span class="line">&#123;</span><br><span class="line">    assert(!IsEmpty());</span><br><span class="line">    StackNode&lt;Type&gt; *p = top;</span><br><span class="line">    Type retValue = p-&gt;data;<span class="comment">//暂存栈顶数据</span></span><br><span class="line">    top = top-&gt;link;<span class="comment">//修改栈顶指针</span></span><br><span class="line">    <span class="keyword">delete</span> p;<span class="comment">//释放，返回数据</span></span><br><span class="line">    <span class="keyword">return</span> retValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Type</span> <span class="title">Stack</span>&lt;Type&gt;:</span>:GetTop()</span><br><span class="line">&#123;</span><br><span class="line">    assert(!IsEmpty());</span><br><span class="line">    <span class="keyword">return</span> top-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        a.Push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; a.GetTop()&lt;&lt; <span class="string">" "</span>;</span><br><span class="line">        a.Pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="queue">2. Queue</h2><figure><img src="queue-model.png" alt="" /><figcaption>Queue Model</figcaption></figure><figure><img src="enqueue-and-dequeue.png" alt="" /><figcaption>Enqueue and Dequeue</figcaption></figure><h3 id="queue-adt">2.1 Queue ADT</h3><p>Attributes of Queue</p><ul><li>front/rear: front/rear index</li><li>counter: number of elements in the queue</li><li>maxSize: capacity of the queue</li><li>values: points to structure storing elements of the queue</li></ul><p>Operations of Queue</p><ul><li>IsEmpty: return true if queue is empty, return false otherwise</li><li>IsFull: return true if queue is full, return false otherwise</li><li>Enqueue: add an element to the rear of queue</li><li>Dequeue: delete the element at the front of queue</li><li>DisplayQueue: print all the data</li></ul><h3 id="implementation-of-queue">2.2 Implementation of Queue</h3><ul><li>Just as stacks can be implemented as arrays or linked lists, so with queues.</li><li>Dynamic queues have the same advantages over static queues as dynamic stacks have over static stacks</li></ul><h4 id="array-implementation">2.2.1 Array Implementation</h4><p><img src="queue-implementation-of-array-1.png" alt="Queue Implementation of Array" /> <img src="queue-implementation-of-array-2.png" alt="Queue Implementation of Array" /> <img src="queue-implementation-of-array-3.png" alt="Queue Implementation of Array" /> <img src="implementation-using-circular-array-1.png" alt="Implementation Using Circular Array" /> <img src="implementation-using-circular-array-2.png" alt="Implementation Using Circular Array" /> <img src="implementation-using-circular-array-3.png" alt="Implementation Using Circular Array" /></p><p>注意：front是空的，队列的第一个元素是(front+1)%maxSize；</p><p><strong>code</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> front, rear;</span><br><span class="line">    Type *elements;</span><br><span class="line">    <span class="keyword">int</span> maxSize;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Queue(<span class="keyword">int</span> size = <span class="number">11</span>);</span><br><span class="line">    ~Queue()&#123; <span class="keyword">delete</span> []elements; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(<span class="keyword">const</span> Type&amp; item)</span></span>;</span><br><span class="line">    <span class="function">Type <span class="title">DeQueue</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Type <span class="title">GetFront</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MakeEmpty</span><span class="params">()</span></span>&#123; front = rear = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> front == rear; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">IsFull</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (rear+<span class="number">1</span>)%maxSize == front; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> (rear-front+maxSize)%maxSize; &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Queue</span>&lt;Type&gt;:</span>:Queue(<span class="keyword">int</span> sz):front(<span class="number">0</span>),rear(<span class="number">0</span>),maxSize(sz)</span><br><span class="line">&#123;</span><br><span class="line">    elements = <span class="keyword">new</span> Type[maxSize];</span><br><span class="line">    assert(elements!=<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Queue</span>&lt;Type&gt;:</span>:EnQueue(<span class="keyword">const</span> Type&amp; item)</span><br><span class="line">&#123;</span><br><span class="line">    assert(!IsFull());</span><br><span class="line">    rear = (rear+<span class="number">1</span>)%maxSize;</span><br><span class="line">    elements[rear] = item;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Type</span> <span class="title">Queue</span>&lt;Type&gt;:</span>:DeQueue()</span><br><span class="line">&#123;</span><br><span class="line">    assert(!IsEmpty());</span><br><span class="line">    front = (front+<span class="number">1</span>)%maxSize;</span><br><span class="line">    <span class="keyword">return</span> elements[front];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Type</span> <span class="title">Queue</span>&lt;Type&gt;:</span>:GetFront()</span><br><span class="line">&#123;</span><br><span class="line">    assert(!IsEmpty());</span><br><span class="line">    <span class="keyword">return</span> elements[(front+<span class="number">1</span>)%maxSize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        q.EnQueue(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;q.DeQueue()&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="linked-list-implementation">2.2.2 Linked List Implementation</h4><p><img src="queue-implementation-base-on-linked-list-1.png" alt="Queue Implementation based on Linked List" /> <img src="queue-implementation-base-on-linked-list-2.png" alt="Queue Implementation based on Linked List" /></p><p><strong>code</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt; <span class="title">class</span> <span class="title">Queue</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt; <span class="title">class</span> <span class="title">QueueNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span>&lt;Type&gt;;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Type data;</span><br><span class="line">    QueueNode&lt;Type&gt; *link;</span><br><span class="line">    QueueNode(Type d = <span class="number">0</span>, QueueNode&lt;Type&gt; *l = <span class="literal">NULL</span>):data(d),link(l)&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt; <span class="title">class</span> <span class="title">Queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Queue():rear(<span class="literal">NULL</span>),front(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">    ~Queue();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">EnQueue</span><span class="params">(<span class="keyword">const</span> Type&amp; item)</span></span>;</span><br><span class="line">    <span class="function">Type <span class="title">DeQueue</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Type <span class="title">GetFront</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MakeEmpty</span><span class="params">()</span></span>;<span class="comment">//实现与~Queue()相同</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> front==<span class="literal">NULL</span>; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QueueNode&lt;Type&gt; *front, *rear;<span class="comment">//队列指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Queue</span>&lt;Type&gt;:</span>:~Queue()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//队列的析构函数</span></span><br><span class="line">    QueueNode&lt;Type&gt; *p;</span><br><span class="line">    <span class="keyword">while</span>(front != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//逐个结点释放</span></span><br><span class="line">        p = front;</span><br><span class="line">        front = front-&gt;link;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Queue</span>&lt;Type&gt;:</span>:EnQueue(<span class="keyword">const</span> Type&amp; item)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//将新元素item插入到队列的队尾</span></span><br><span class="line">    <span class="keyword">if</span>(front == <span class="literal">NULL</span>)<span class="comment">//空，创建第一个结点</span></span><br><span class="line">    &#123;</span><br><span class="line">        front = rear = <span class="keyword">new</span> QueueNode&lt;Type&gt;(item,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        rear = rear-&gt;link = <span class="keyword">new</span> QueueNode&lt;Type&gt;(item,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Type</span> <span class="title">Queue</span>&lt;Type&gt;:</span>:DeQueue()</span><br><span class="line">&#123;</span><br><span class="line">    assert(!IsEmpty());</span><br><span class="line">    <span class="comment">//删去队头结点，并返回队头元素的值</span></span><br><span class="line">    QueueNode&lt;Type&gt; *p = front;</span><br><span class="line">    Type retValue = p-&gt;data;</span><br><span class="line">    front = front-&gt;link;</span><br><span class="line">    <span class="keyword">if</span>(front == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        rear = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    <span class="keyword">return</span> retValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Type</span> <span class="title">Queue</span>&lt;Type&gt;:</span>:GetFront()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//若队列不空，则函数返回队头元素的值；若队空，则函数返回队头元素的值0</span></span><br><span class="line">    assert(!IsEmpty());</span><br><span class="line">    <span class="keyword">return</span> front-&gt;data;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        q.EnQueue(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;q.DeQueue()&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> data structures and algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stack </tag>
            
            <tag> queue </tag>
            
            <tag> data structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>list</title>
      <link href="/2016/10/11/list/"/>
      <url>/2016/10/11/list/</url>
      
        <content type="html"><![CDATA[<h1 id="linked-list">Linked List</h1><h2 id="introduction">1. Introduction</h2><ul><li>An data item plus its pointer is called a node</li><li>A node contains data item and one or more links.<ul><li>The link is a reference to a node.</li><li>The link of last node is set to NULL</li></ul></li><li>a “head” which is a pointer to the first node in the linked list</li><li>We can access all nodes through pointer “head”</li></ul><a id="more"></a><figure><img src="list.png" alt="" /><figcaption>linked list</figcaption></figure><h3 id="linked-list-with-header">1.1 Linked List with header</h3><p>A node linking to the first node is called Header, the header cell only contains references to the first.</p><figure><img src="linked-list-with-header.png" alt="" /><figcaption>linked list</figcaption></figure><h2 id="template-of-linked-list">2. Template of linked list</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt; <span class="title">class</span> <span class="title">List</span>;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">List</span>&lt;Type&gt;;</span></span><br><span class="line">    Type data;<span class="comment">//结点数据</span></span><br><span class="line">    ListNode&lt;Type&gt; *link;<span class="comment">//结点链接指针</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode();</span><br><span class="line">    ListNode(<span class="keyword">const</span> Type&amp; item);</span><br><span class="line">    ListNode&lt;Type&gt; *NextNode()&#123; <span class="keyword">return</span> link; &#125;<span class="comment">//给出当前结点的下一节点地址</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InsertAfter</span><span class="params">(ListNode&lt;Type&gt; *p)</span></span>;<span class="comment">//在当前结点后插入节点p</span></span><br><span class="line">    ListNode&lt;Type&gt; *RemoveAfter();<span class="comment">//摘下当前节点的下一结点</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">List</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ListNode&lt;Type&gt; *first, *last;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode&lt;Type&gt; *GetNode(<span class="keyword">const</span> Type&amp; item, ListNode&lt;Type&gt; *next);</span><br><span class="line">    List(<span class="keyword">const</span> Type&amp; value)</span><br><span class="line">    &#123;</span><br><span class="line">        last = first = <span class="keyword">new</span> ListNode&lt;Type&gt;(value);</span><br><span class="line">    &#125;<span class="comment">//构造函数</span></span><br><span class="line">    ~List();<span class="comment">//析构函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MakeEmpty</span><span class="params">()</span></span>;<span class="comment">//链表置空</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">()</span> <span class="keyword">const</span></span>;<span class="comment">//求链表长度</span></span><br><span class="line">    ListNode&lt;Type&gt; *Find(Type value);</span><br><span class="line">    ListNode&lt;Type&gt; *Find(<span class="keyword">int</span> i);</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Insert</span><span class="params">(Type value, <span class="keyword">int</span> i)</span></span>;</span><br><span class="line">    <span class="function">Type *<span class="title">Remove</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">    <span class="function">Type *<span class="title">Get</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ListNode</span>&lt;Type&gt;:</span>:ListNode():link(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ListNode</span>&lt;Type&gt;:</span>:ListNode(<span class="keyword">const</span> Type&amp; item):data(item),link(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">ListNode</span>&lt;Type&gt;:</span>:InsertAfter(ListNode&lt;Type&gt; *p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在当前结点后插入节点p</span></span><br><span class="line">    p-&gt;link = link;</span><br><span class="line">    link = p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ListNode</span>&lt;Type&gt; *<span class="title">ListNode</span>&lt;Type&gt;:</span>:RemoveAfter()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//摘下当前节点的下一结点</span></span><br><span class="line">    ListNode&lt;Type&gt; *tempptr = link;</span><br><span class="line">    <span class="keyword">if</span>(link == <span class="literal">NULL</span>)&#123; <span class="keyword">return</span> <span class="literal">NULL</span>; &#125;</span><br><span class="line">    link = tempptr-&gt;link;</span><br><span class="line">    <span class="keyword">return</span> tempptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ListNode</span>&lt;Type&gt; *<span class="title">List</span>&lt;Type&gt;:</span>:GetNode(<span class="keyword">const</span> Type&amp; item, ListNode&lt;Type&gt; *next = <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ListNode&lt;Type&gt; *newnode = <span class="keyword">new</span> ListNode&lt;Type&gt;(item);</span><br><span class="line">    newnode-&gt;link = next;</span><br><span class="line">    <span class="keyword">return</span> newnode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">List</span>&lt;Type&gt;:</span>:~List()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//析构函数（链表的公共操作）</span></span><br><span class="line">    MakeEmpty();</span><br><span class="line">    <span class="keyword">delete</span> first;</span><br><span class="line">    <span class="comment">//链表置空，再删去表头结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">List</span>&lt;Type&gt;:</span>:MakeEmpty()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//删去链表中除表头结点外的所有其他结点</span></span><br><span class="line">    ListNode&lt;Type&gt; *q;</span><br><span class="line">    <span class="keyword">while</span>(first-&gt;link != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        q = first-&gt;link;</span><br><span class="line">        <span class="comment">//将表头结点后第一个结点从链中摘下</span></span><br><span class="line">        first-&gt;link = q-&gt;link;</span><br><span class="line">        <span class="keyword">delete</span> q;<span class="comment">//释放它</span></span><br><span class="line">    &#125;</span><br><span class="line">    last = first;<span class="comment">//修改表尾指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">List</span>&lt;Type&gt;:</span>:Length() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//求链表长度</span></span><br><span class="line">    ListNode&lt;Type&gt; *p = first-&gt;link;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;link;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ListNode</span>&lt;Type&gt; *<span class="title">List</span> &lt;Type&gt;:</span>:Find(Type value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在链表中从头搜索其数据值为value的结点</span></span><br><span class="line">    ListNode&lt;Type&gt; *p = first-&gt;link;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; p-&gt;data != value)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;link;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">    <span class="comment">//p在搜索成功时返回找到的结点地址，p在搜索不成功时返回空值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">ListNode</span>&lt;Type&gt; *<span class="title">List</span>&lt;Type&gt;:</span>:Find(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">-1</span>) <span class="keyword">return</span> first;<span class="comment">//i应&gt;=0</span></span><br><span class="line">    ListNode&lt;Type&gt; *p = first-&gt;link;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//第一个位置的结点的下标是0，不计头节点</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span> &amp;&amp; j &lt; i)<span class="comment">//j = i 停</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;link;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">List</span>&lt;Type&gt;:</span>:Insert(Type value, <span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//将含value的新元素插入到链表的第i个位置</span></span><br><span class="line">    ListNode&lt;Type&gt; *p = Find(i<span class="number">-1</span>);</span><br><span class="line">    <span class="comment">//p指向链表的第i-1个结点</span></span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    ListNode&lt;Type&gt; *newnode = GetNode(value,p-&gt;link);</span><br><span class="line">    <span class="comment">//创建结点 newnode指向p-&gt;link</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p-&gt;link == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        last = newnode;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;link = newnode;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Type</span> *<span class="title">List</span>&lt;Type&gt;:</span>:Remove(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//从链表中删除第i个结点</span></span><br><span class="line">    ListNode&lt;Type&gt; *p = Find(i<span class="number">-1</span>), *q;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span> || p-&gt;link == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    q = p-&gt;link;</span><br><span class="line">    p-&gt;link = q-&gt;link;</span><br><span class="line">    Type value = <span class="keyword">new</span> Type(q-&gt;data);</span><br><span class="line">    <span class="keyword">if</span>(q == last) </span><br><span class="line">    &#123;</span><br><span class="line">        last = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> q;</span><br><span class="line">    <span class="keyword">return</span> &amp;value;<span class="comment">//调用者得delete该空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Type</span> *<span class="title">List</span>&lt;Type&gt;:</span>:Get(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//提取第i个结点的数据</span></span><br><span class="line">    ListNode&lt;Type&gt; *p = Find(i);</span><br><span class="line">    <span class="comment">//p指向链表的第i个结点</span></span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span> || p == first)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;(p-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="array-versus-linked-list">3. Array versus Linked List</h2><p>Linked lists are more complex to code and management than arrays, but they have some distinct advantages:</p><ul><li>Dynamic: a linked list can easily grow and shrink in size.<ul><li>We don’t need to know how many nodes will be in the list. They are created in memory as needed.</li><li>In contrast, the size of a C array is fixed at compilation time.</li></ul></li><li>Easy and fast insertions and deletions<ul><li>To insert or delete an element in an array, we need to copy to temporary variables to make room for new elements or close the gap caused by deleted elements.</li><li>With a linked list, no need to move other nodes. Only need to reset some pointers.</li></ul></li></ul><h3 id="space-storage-considerations">3.1 Space (storage) considerations</h3><ul><li>A linked list requires pointers to nodes</li><li>An array requires the maximum number of elements to be known in advance. If that maximum is not required, space is wasted at the end of the array.</li></ul><h3 id="time-considerations">3.2 Time considerations</h3><ul><li>Most methods in a linked list require more statements than those in an array, which may indicate more time required</li><li>Arrays are quicker at finding and altering ‘in the middle’</li><li>Linked lists are quicker at additions and removals ‘in the middle’</li></ul><h2 id="variations-of-linked-lists">4. Variations of Linked Lists</h2><p>Two problems:</p><ul><li>we can’t get back to the beginning of the list</li><li>from the end, and we can’t go backwards through the list.</li></ul><p>So, circular linked lists and doubly linked lists were invented.</p><h3 id="circular-linked-lists">4.1 Circular Linked Lists</h3><p>The last node points to the first node of the list</p><figure><img src="circular-linked-list.png" alt="" /><figcaption>circular linked list</figcaption></figure><p>How do we know when we have finished traversing the list? (Tip: check if the pointer of the current node is equal to the head.)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt; <span class="title">class</span> <span class="title">CircList</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt; <span class="title">class</span> <span class="title">CircListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">CircList</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CircListNode(Type d = <span class="number">0</span>, CircListNode&lt;Type&gt; *next = <span class="literal">NULL</span>):data(d),link(next)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Type data;</span><br><span class="line">    CircListNode&lt;Type&gt; *link;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt; <span class="title">class</span> <span class="title">CircList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CircList(Type value);</span><br><span class="line">    ~CircList();</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> first-&gt;link = first; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(<span class="keyword">const</span> Type&amp; value)</span></span>;</span><br><span class="line">    <span class="function">Type <span class="title">getData</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Firster</span><span class="params">()</span></span>&#123; current = first; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">First</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">Prior</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> Type&amp; value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Remove</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    CircListNode&lt;Type&gt; *first, *current, *last;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//////////////////////////////////////////</span></span><br><span class="line"><span class="comment">//List(const Type&amp; value)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//    last = first = new ListNode&lt;Type&gt;(value);</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">/////////////////////////////////////////</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">CircList</span>&lt;Type&gt;:</span>:CircList(<span class="keyword">const</span> Type&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    last = first = <span class="keyword">new</span> CircListNode&lt;Type&gt;(value);</span><br><span class="line">    first-&gt;link = first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Linked Lists: Searching in a CLL</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">CircListNode</span>&lt;Type&gt;* <span class="title">CircList</span>&lt;Type&gt;:</span>:Find(Type value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在链表中从头搜索其数据值为value的结点</span></span><br><span class="line">    CircListNode&lt;Type&gt; *p = first-&gt;link;</span><br><span class="line">    <span class="comment">//检测指针p指示第一个结点</span></span><br><span class="line">    <span class="keyword">while</span>(p != first &amp;&amp; p-&gt;data != value)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;link;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (p!=first)?p:<span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//p在搜索成功时返回找到的结点地址</span></span><br><span class="line">    <span class="comment">//p在搜索不成功时返回空值</span></span><br><span class="line">    <span class="comment">//p==first停止，此时到达链表尾端，没有找到，返回空值。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="doubly-linked-lists">4.2 Doubly Linked Lists</h3><ul><li>Each node points to not only successor but the predecessor</li><li>There are two NULL: at the first and last nodes in the list</li><li>Advantage: given a node, it is easy to visit its predecessor. Convenient to traverse lists backwards</li></ul><figure><img src="doubly-linked-list.png" alt="" /><figcaption>doubly linked list</figcaption></figure><p>双向链表是循环链表。</p><figure><img src="doubly-linked-list-example.png" alt="" /><figcaption>doubly linked list example</figcaption></figure><p><img src="doubly-linked-list-insert.png" alt="doubly linked list insert" /> 在current结点之后插入value新结点。执行完之后current指向新插入的结点。</p><p><img src="doubly-linked-list-delete.png" alt="doubly linked list delete" /> 删除current结点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt; <span class="title">class</span> <span class="title">DblList</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt; <span class="title">class</span> <span class="title">DblNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">DblList</span>&lt;Type&gt;;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Type data;<span class="comment">//数据</span></span><br><span class="line">    DblNode&lt;Type&gt; *lLink, *rLink;<span class="comment">//指针</span></span><br><span class="line">    DblNode(Type value, DblNode&lt;Type&gt; *left, DblNode&lt;Type&gt; *right):data(value),lLink(left),rLink(right)&#123;&#125;</span><br><span class="line">    DblNode(Type value):data(value),lLink(<span class="literal">NULL</span>),rLink(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt; <span class="title">class</span> <span class="title">DblList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DblList(Type uniqueVal);</span><br><span class="line">    ~DblList();</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Length</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> first-&gt;rLink == first; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">const</span> Type&amp; target)</span></span>;</span><br><span class="line">    <span class="function">Type <span class="title">getData</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Firster</span><span class="params">()</span></span>&#123; current = first; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">First</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Prior</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>!()&#123; <span class="keyword">return</span> current != <span class="literal">NULL</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> Type&amp; value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Remove</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    DblNode&lt;Type&gt; *first, *current;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//constructing</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt; <span class="title">DblList</span>&lt;Type&gt;:</span>:DblList(Type uniqueVal)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//双向循环链表的构造函数，创建头结点</span></span><br><span class="line">    first = <span class="keyword">new</span> DblNode&lt;Type&gt;(uniqueVal);</span><br><span class="line">    first-&gt;rLink = first-&gt;lLink = first;</span><br><span class="line">    current = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt; <span class="title">int</span> <span class="title">DblList</span>&lt;Type&gt;:</span>:Find(<span class="keyword">const</span> Type&amp; target)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在双向链表中搜索含target的结点，搜索成功返回1，否则返回0</span></span><br><span class="line">    DblNode&lt;Type&gt; *p = first-&gt;rLink;</span><br><span class="line">    <span class="keyword">while</span>(p != first &amp;&amp; p-&gt;data != target)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;rLink;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p != first)</span><br><span class="line">    &#123;</span><br><span class="line">        current = p;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt; <span class="title">void</span> <span class="title">DblList</span>&lt;Type&gt;:</span>:Insert(<span class="keyword">const</span> Type&amp; value)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在current结点之后插入value</span></span><br><span class="line">    <span class="comment">//跟上面的一页图片ppt正好对应</span></span><br><span class="line">    <span class="keyword">if</span>(current == <span class="literal">NULL</span>)<span class="comment">//空表情形</span></span><br><span class="line">    &#123;</span><br><span class="line">        current = first-&gt;rLink = <span class="keyword">new</span> DblNode&lt;Type&gt;(value,first,first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        current-&gt;rLink = <span class="keyword">new</span> DblNode&lt;Type&gt;(value, current, current-&gt;rLink);</span><br><span class="line">        current = current-&gt;rLink;</span><br><span class="line">    &#125;</span><br><span class="line">    current-&gt;rLink-&gt;lLink = current;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">DblList</span>&lt;Type&gt;:</span>:Remove()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(current != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        DblNode&lt;Type&gt; *temp = current;<span class="comment">//被删结点</span></span><br><span class="line">        current = current-&gt;rLink;<span class="comment">//下一节点</span></span><br><span class="line">        current-&gt;lLink = temp-&gt;lLink;<span class="comment">//从链中摘下</span></span><br><span class="line">        temp-&gt;lLink-&gt;rLink = current;</span><br><span class="line">        <span class="keyword">delete</span> temp;<span class="comment">//删去</span></span><br><span class="line">        <span class="keyword">if</span>(current == first)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(IsEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">                current = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                current = current-&gt;rLink;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">DblList</span>&lt;Type&gt;:</span>:Length() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//求双向循环链表的长度(不计表头结点)</span></span><br><span class="line">    DblNode&lt;Type&gt; *p = first-&gt;rLink;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(p != first)</span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;rLink;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">DblList</span>&lt;Type&gt;:</span>:First()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!IsEmpty())</span><br><span class="line">    &#123;</span><br><span class="line">        current = first-&gt;rLink;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    current = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">DblList</span>&lt;Type&gt;:</span>:Next()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(current-&gt;rLink == first)</span><br><span class="line">    &#123;</span><br><span class="line">        current = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    current = current-&gt;rLink;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">DblList</span>&lt;Type&gt;:</span>:Prior()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(current-&gt;lLink == first)</span><br><span class="line">    &#123;</span><br><span class="line">        current = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    current = current-&gt;lLink;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dll-vs-sll">4.3 DLL vs SLL</h3><p>Advantages:</p><ul><li>Can be traversed in either direction (may be essential for some programs)</li><li>Some operations, such as deletion and inserting before a node, become easier</li></ul><p>Disadvantages:</p><ul><li>Requires more space</li><li>List manipulations are slower (because more links must be changed)</li><li>Greater chance of having bugs (because more links must be manipulated)</li></ul>]]></content>
      
      
      <categories>
          
          <category> data structures and algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dsa </tag>
            
            <tag> linked list </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>array</title>
      <link href="/2016/09/25/array/"/>
      <url>/2016/09/25/array/</url>
      
        <content type="html"><![CDATA[<h2 id="introduction">1. Introduction</h2><ol type="1"><li>存储相同数据类型</li><li>线性结构</li><li>除了第一个元素都有一个唯一的前驱，除了最后一个元素都有一个唯一的后继。</li><li>给定元素的大小和起始地址，可以知道任何一个元素的地址。</li></ol><a id="more"></a><h2 id="adt-of-array----class-declaration">2. ADT of Array -- Class Declaration</h2><p>g++编译通过： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> defaultSize 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Array</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Type *elements;</span><br><span class="line">    <span class="keyword">int</span> arraySize;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getArray</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Array(<span class="keyword">int</span> size=defaultSize);</span><br><span class="line">    Array(<span class="keyword">const</span> Array&lt;Type&gt;&amp; x);</span><br><span class="line">    ~Array()&#123; <span class="keyword">delete</span>[] elements; &#125;</span><br><span class="line">    Array&lt;Type&gt;&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> Array&lt;Type&gt;&amp; A);<span class="comment">//copy array</span></span><br><span class="line">    Type&amp; <span class="keyword">operator</span>[] (<span class="keyword">int</span> i);</span><br><span class="line">    Type* <span class="keyword">operator</span>* () <span class="keyword">const</span> &#123; <span class="keyword">return</span> elements; &#125; </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> arraySize; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> sz)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Array</span>&lt;Type&gt;:</span>:getArray()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//private function, create the space to store the elements</span></span><br><span class="line">    elements = <span class="keyword">new</span> Type[arraySize];</span><br><span class="line">    <span class="keyword">if</span>(elements == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        arraySize = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Memory Allocation Error"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Array</span>&lt;Type&gt;:</span>:Array(<span class="keyword">int</span> sz)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//constructor</span></span><br><span class="line">    <span class="keyword">if</span>(sz &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        arraySize = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"the number of elements in the array is invalid"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    arraySize = sz;</span><br><span class="line">    getArray();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt; <span class="title">Array</span>&lt;Type&gt;:</span>:</span><br><span class="line">Array(<span class="keyword">const</span> Array&lt;Type&gt;&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//copy constructor</span></span><br><span class="line">    <span class="keyword">int</span> n = arraySize = x.arraySize;</span><br><span class="line">    elements = <span class="keyword">new</span> Type[n];</span><br><span class="line">    <span class="keyword">if</span>(elements == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        arraySize = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Memory Allocation Error"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Type* srcptr = x.elements;</span><br><span class="line">    Type* destptr = elements;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123; *destptr++ = *srcptr++; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Type</span>&amp; <span class="title">Array</span>&lt;Type&gt;:</span>:<span class="keyword">operator</span>[](<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt; arraySize - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Array Index Error"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> elements[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">Array</span>&lt;Type&gt;:</span>:resize(<span class="keyword">int</span> sz)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(sz&gt;=<span class="number">0</span> &amp;&amp; sz!= arraySize)</span><br><span class="line">    &#123;</span><br><span class="line">        Type* newArray = <span class="keyword">new</span> Type[sz];</span><br><span class="line">        <span class="keyword">if</span>(newArray == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cerr</span>&lt;&lt;<span class="string">"Memory Allocation Error"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = (sz&lt;=arraySize)?sz:arraySize;</span><br><span class="line">        Type* srcptr = elements;</span><br><span class="line">        Type* destptr = newArray;</span><br><span class="line">        <span class="keyword">while</span>(n--)</span><br><span class="line">        &#123;</span><br><span class="line">            *destptr++ = *srcptr++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> [] elements;</span><br><span class="line">        elements = newArray;</span><br><span class="line">        arraySize = sz;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Array</span>&lt;Type&gt;&amp; <span class="title">Array</span>&lt;Type&gt;:</span>:<span class="keyword">operator</span>= (<span class="keyword">const</span> Array&lt;Type&gt;&amp; A)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> n = arraySize = A.arraySize;</span><br><span class="line">    elements = <span class="keyword">new</span> Type[n];</span><br><span class="line">    <span class="keyword">if</span>(elements == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        arraySize = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Memory Allocation Error"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Type* srcptr = A.elements;</span><br><span class="line">    Type* destptr = elements;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123; *destptr++ = *srcptr++; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Array&lt;<span class="keyword">int</span>&gt; a(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">int</span>* p = *a;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="sequence-list">3. Sequence List</h2><ol type="1"><li>using consecutive set of memory locations(Array);</li><li>Address of element ai: Loc(ai) = Loc(a0)+i*L;</li><li>random access storage</li></ol><p>顺序表用数组实现的操作的特点:</p><ol type="1"><li>通过元素的存储顺序反映线性表中，数据元素之间的逻辑关系；</li><li>可随机存取顺序表的元素；</li><li>顺序表的插入、删除操作要通过移动元素实现，效率较低；</li><li>元素较少时存储空间的利用率较低。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> defaultSize 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">SeqList</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Type* data;</span><br><span class="line">    <span class="keyword">int</span> maxSize;</span><br><span class="line">    <span class="keyword">int</span> last;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SeqList(<span class="keyword">int</span> maxSize=defaultSize);</span><br><span class="line">    ~SeqList()&#123; <span class="keyword">delete</span> [] data; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> last+<span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(Type&amp; x)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">isIn</span><span class="params">(Type&amp; x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(Type&amp; x, <span class="keyword">int</span> i)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(Type&amp; x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">(Type&amp; x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">prior</span><span class="params">(Type&amp; x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> last==<span class="number">-1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">isFull</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> last == maxSize<span class="number">-1</span>;&#125;</span><br><span class="line">    <span class="function">Type <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123; <span class="keyword">return</span> i&lt;<span class="number">0</span>||i&gt;last?<span class="literal">NULL</span>:data[i]; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">SeqList</span>&lt;Type&gt;:</span>:SeqList(<span class="keyword">int</span> sz)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//constructor</span></span><br><span class="line">    <span class="keyword">if</span>(sz&gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        maxSize = sz; last = <span class="number">-1</span>;</span><br><span class="line">        data = <span class="keyword">new</span> Type[maxSize];</span><br><span class="line">        <span class="keyword">if</span>(data == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            maxSize = <span class="number">0</span>;</span><br><span class="line">            last = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">SeqList</span>&lt;Type&gt;:</span>:find(Type&amp; x) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//sequence find x from begin to end;</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=last &amp;&amp; data[i]!=x)</span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;last)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//failure</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> i; <span class="comment">//success</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">SeqList</span>&lt;Type&gt;:</span>:isIn(Type&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Is x in the list?</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, found = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=last &amp;&amp; !found)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(data[i]!=x)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            found = <span class="number">1</span>; <span class="comment">//success</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> found;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">SeqList</span>&lt;Type&gt;:</span>:insert(Type&amp; x, <span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//insert x into the list as the ith element</span></span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span>||i&gt;last+<span class="number">1</span>||last == maxSize<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//failure</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        last++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = last; j &gt; i; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            data[j] = data[j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        data[i]=x;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//success</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">SeqList</span>&lt;Type&gt;:</span>:remove(Type&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//delete x from the list</span></span><br><span class="line">    <span class="keyword">int</span> i = find(x);</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        last--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j&lt;=last; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            data[j] = data[j+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//success</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//failure</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">SeqList</span>&lt;Type&gt;:</span>:next(Type&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//gets the next element in the list</span></span><br><span class="line">    <span class="keyword">int</span> i = find(x);</span><br><span class="line">    <span class="keyword">if</span>(i&gt;=<span class="number">0</span> &amp;&amp; i&lt;last)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>; <span class="comment">//find x</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//failure    </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">SeqList</span>&lt;Type&gt;:</span>:prior(Type&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//gets the predecessor</span></span><br><span class="line">    <span class="keyword">int</span> i = find(x);</span><br><span class="line">    <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; i&lt;=last)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> i<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> data structures and algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dsa </tag>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dsa notes</title>
      <link href="/2016/09/19/dsa-notes/"/>
      <url>/2016/09/19/dsa-notes/</url>
      
        <content type="html"><![CDATA[<h1 id="dsa-notes">dsa notes</h1><h2 id="note-1">1. note 1</h2><h3 id="渐进复杂度">渐进复杂度</h3><p>针对足够大的输入规模n,算法执行时间T(n)的渐进增长速度，应如何度量和评价呢? <a id="more"></a> #### 大O记号(big-O notation)</p><p>具体地，若存在正的常数c和函数f(n)，使得对任何n&gt;&gt;2都有 <span class="math display">\[ T(n) \leq c \cdot f(n) \]</span> 则可以认为在n足够大之后，<strong><font color="purple">f(n)给出了T(n)增长速度的一个渐进上界</font></strong>。此时，记之为： <span class="math display">\[ T(n) = O(f(n)) \]</span> 由这一定义，可导出大O记号的以下性质：'</p><ol type="1"><li>对于任一常数c&gt;0，有<span class="math inline">\(O(f(n)) = O(c \cdot f(n))\)</span></li><li>对于任意常数a&gt;b&gt;0，有<span class="math inline">\(O(n^a+n^b)=O(n^a)\)</span></li></ol><p>前一性质意味着，在大O记号的意义下，函数各项正的常系数可以忽略并等同于1。后一性质则意味着，多项式中的低次项均可忽略，只保留最高次项。可以看出，大O记号的这些性质的确体现了对函数总体增长趋势的关注和刻画。<br />以大O记号形式表示的时间复杂度，实质上是对算法执行时间的一种保守估计——对于规模为n的任意输入，算法的运行时间都不会超过O(f(n))。比如，起泡排序算法复杂度T(n)=O(n<sup>2)，意味着，该算法处理任何序列所需的时间绝不会超过O(n</sup>2)。的确需要这么长计算时间的输入实例，称作是最坏实例或最坏情况。</p><h4 id="大omega记号bit-omega-notation">大<span class="math inline">\(\Omega\)</span>记号(bit-<span class="math inline">\(\Omega\)</span> notation)</h4><p>如果存在正的常数c和函数g(n)，使得对于任何n &gt;&gt; 2都有 <span class="math display">\[T(n) \geq c \cdot g(n)\]</span> 就可以认为，在n足够大之后，g(n)给出了T(n)的一个渐进下界。此时，我们记之为： <span class="math display">\[T(n)= \Omega(g(n))\]</span> 这里的<span class="math inline">\(\Omega\)</span>称作大<span class="math inline">\(\Omega\)</span>记号。与大O记号恰好相反，大<span class="math inline">\(\Omega\)</span>记号是对算法执行效率的乐观估计——对于规模为n的任意输入，算法的运行时间都不低于<span class="math inline">\(\Omega (g(n))\)</span>。比如，即便在最好的情况下，起泡排序也至少需要<span class="math inline">\(T(n)=\Omega(n)\)</span>的计算时间。</p><h4 id="大theta记号">大<span class="math inline">\(\Theta\)</span>记号</h4><p>借助大O记号，大<span class="math inline">\(\Omega\)</span>记号，可以对算法的时间复杂度做出定量的界定，亦即，从渐进的趋势看，T(n)介于<span class="math inline">\(\Omega(g(n))\)</span>与<span class="math inline">\(O(f(n))\)</span>之间。若恰巧出现<span class="math inline">\(g(n)=f(n)\)</span>的情况，则可以用另一符号表示。<br />如果存在正的常数<span class="math inline">\(c_1\)</span>&lt;<span class="math inline">\(c_2\)</span>和函数<span class="math inline">\(h(n)\)</span>，使得对于任何n&gt;&gt;2都有， <span class="math display">\[c_1 \cdot h(n) \leq T(n) \leq c_2 \cdot h(n)\]</span> 就可以认为在n足够大之后，h(n)给出了T(n)的一个确界。此时，我们记之为： <span class="math display">\[T(n) = \Theta(h(n))\]</span> 这里的<span class="math inline">\(\Theta\)</span>称作大<span class="math inline">\(\Theta\)</span>记号，(big-theta notation)，它是对算法复杂度的准确估计——对于规模为n的任何输入，算法的运行时间T(n)都与<span class="math inline">\(\Theta(h(n))\)</span>同阶。<br />形象表示如下图所示： <img src="o-theta-omega.png" /></p><h2 id="note-2-统计二进制展开中-数位1的个数">2. note 2 : 统计二进制展开中　数位1的个数</h2><p>考查如下问题：对于任意非负整数，统计其二进制展开中数位为1的总数。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countOnes</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> ones = <span class="number">0</span>;<span class="comment">//计数器复位</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">0</span>&lt;n)</span><br><span class="line">    &#123;</span><br><span class="line">    ones+= (n&amp;<span class="number">1</span>);<span class="comment">//检查最低位，若为1，则计数。</span></span><br><span class="line">        n &gt;&gt;=<span class="number">1</span>;<span class="comment">//右移一位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="note-3-数组求和">3. note 3 : 数组求和</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="number">1</span>&gt;n)<span class="comment">//平凡情况，递归基</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//直接，非递归式计算</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//一般情况</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> sum(A,n<span class="number">-1</span>)+A[n<span class="number">-1</span>];<span class="comment">//递归，前n-1项之和，再累计第n-1项。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归分析： <img src="sum-recursion.png" /></p><h2 id="note-4-二分递归">4. note 4 : 二分递归</h2><p>数组求和： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(lo==hi)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">return</span> A[lo];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">int</span> mi = (lo+hi)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> sum(A,lo,mi)+sum(A,mi+<span class="number">1</span>,hi)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <img src="binary-recursion.png" alt="binary recursion" /> <img src="binary-recursion-trace.png" alt="binary recursion trace" /></p>]]></content>
      
      
      <categories>
          
          <category> data structures and algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dsa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tail recursion</title>
      <link href="/2016/09/16/tail-recursion/"/>
      <url>/2016/09/16/tail-recursion/</url>
      
        <content type="html"><![CDATA[<h1 id="尾递归">尾递归</h1><p>尾递归的形式，不难将算法改写为迭代形式。<br />在线性递归算法中，若递归调用在递归实例中恰好以最后一步操作的形式出现，则称作尾递归。比如如下代码中reverse(A, lo, hi)算法的最后一步操作，是对去除了首末元素之后总长缩减两个单元的字数组进行递归倒置，即属于典型的尾递归。实际上属于尾递归形式的算法，均可以简捷地转换为等效的迭代版本。 <a id="more"></a> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尾递归版</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>* A, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(lo &lt; hi)</span><br><span class="line">    &#123;</span><br><span class="line">    swap(A[lo], A[hi]);</span><br><span class="line">        reverse(A, lo+<span class="number">1</span>, hi<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代版1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>* A, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">next:</span><br><span class="line"><span class="keyword">if</span>(lo &lt; hi)</span><br><span class="line">    &#123;</span><br><span class="line">    swap(A[lo], A[hi]);</span><br><span class="line">        lo++; hi--;</span><br><span class="line">        <span class="keyword">goto</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代版2</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>* A, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(lo &lt; hi)</span><br><span class="line">    &#123;</span><br><span class="line">    swap(A[lo++], A[hi--]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> c </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tail recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sorting</title>
      <link href="/2016/09/13/sorting/"/>
      <url>/2016/09/13/sorting/</url>
      
        <content type="html"><![CDATA[<h1 id="sorting">Sorting</h1><h2 id="introduction">1. Introduction</h2><p><strong>stable</strong>:<br />if <span class="math inline">\(i &lt; j\)</span> and <span class="math inline">\(K_i = K_j\)</span>, then <span class="math inline">\(R_i\)</span> precedes <span class="math inline">\(R_j\)</span> in the sorted list.</p><p><strong>Internal sort vs. external sort</strong>:<br />In internal sorting all the data to sort is stored in memory at all times while sorting is in progress. In external sorting data is stored outside memory (like on disk) and only loaded into memory in small chunks. External sorting is usually applied in cases when data can't fit into memory entirely.</p><p>So in internal sorting you can do something like shell sort - just access whatever array elements you want at whatever moment you want. You can't do that in external sorting - the array is not entirely in memory, so you can't just randomly access any element in memory and accessing it randomly on disk is usually extremely slow. The external sorting algorithm has to deal with loading and unloading chunks of data in optimal manner.<br /><a id="more"></a> <img src="the-family-of-sorting-methods.png" alt="the-family-of-sorting-methods.png" /></p><p>key是关键码，排序的准则。</p><p>types of comparison-based sorting algorithm</p><ul><li><p>Insertion Sorting</p><ul><li>insert and keep sorted</li><li>Shell sort [diminishing increment sorting]</li></ul></li><li><p>transposition sorting[Bubble sort and Quick sort ]</p></li><li><p>Selection sort [priority queue sorting]</p></li><li><p>Merge sort [divide and conquer sorting]</p></li><li><p>Always insert in the correct position</p><ul><li>Simple inserting, BST</li></ul></li><li><p>An example is using a Binary Search Tree which gives the TreeSort</p></li><li><p>An in-order traversal visits each element in the tree in ascending order</p></li><li><p>O(n log n) because log n to find insertion place multiplied by the number of elements to be inserted</p></li><li><p>插入排序的寻找适当元素的方法可以采用二叉查找树树提高查找的效率。</p></li></ul><p>其中稳定的排序算法有直接插入排序，冒泡排序和归并排序。</p><h2 id="insertion-sorting-algorithm">2. Insertion Sorting Algorithm</h2><ul><li>Binary insertion sort<ul><li>sequential search --&gt; binary search</li><li>reduce # of comparisons, # of moves unchanged</li></ul></li><li>List insertion sort<ul><li>array --&gt; linked list</li><li>sequential search, move --&gt; 0</li></ul></li></ul><h3 id="算法思路">2.1 算法思路</h3><p>算法的思路可简要描述为：始终将整个序列视作并切分为两部分：有序的前缀，无序的后缀；通过迭代，反复地将后缀的首元素转移至前缀中。<br />由此亦可看出插入排序算法的不变性：<br /><strong>在任何时刻，相对于当前节点e=S[r]，前缀S[0,r)总是也已有序</strong><br />算法开始时该前缀为空，不变性自然满足。<br /><img src="insertion-sort-idea.png" alt="Insertion Sort Idea" /></p><h3 id="实例">2.2 实例</h3><p>插入排序算法的一个实例，如下所示： <img src="insertion-sort-instance.png" alt="Insertion Sort Instance" /></p><h3 id="代码">2.3 代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_array</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i&lt;len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> insert_value = a[i];</span><br><span class="line">        <span class="keyword">for</span>(j=i;j&gt;<span class="number">0</span>; --j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j<span class="number">-1</span>]&gt;insert_value)</span><br><span class="line">            &#123;</span><br><span class="line">                a[j] = a[j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此处跳出循环时，在不满足条件时，已经执行了一次--j</span></span><br><span class="line">        a[j] = insert_value;</span><br><span class="line">        print_array(a,<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    print_array(a,<span class="number">10</span>);</span><br><span class="line">    insertion_sort(a,<span class="number">10</span>);</span><br><span class="line">    print_array(a,<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line"><span class="number">5</span> <span class="number">4</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">0</span> <span class="number">1</span> <span class="number">3</span> <span class="number">2</span> </span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">0</span> <span class="number">1</span> <span class="number">3</span> <span class="number">2</span> </span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">0</span> <span class="number">1</span> <span class="number">3</span> <span class="number">2</span> </span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">8</span> <span class="number">9</span> <span class="number">7</span> <span class="number">6</span> <span class="number">0</span> <span class="number">1</span> <span class="number">3</span> <span class="number">2</span> </span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">6</span> <span class="number">0</span> <span class="number">1</span> <span class="number">3</span> <span class="number">2</span> </span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">0</span> <span class="number">1</span> <span class="number">3</span> <span class="number">2</span> </span><br><span class="line"><span class="number">0</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">1</span> <span class="number">3</span> <span class="number">2</span> </span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">3</span> <span class="number">2</span> </span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">2</span> </span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> </span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><h2 id="selection-sort">3. Selection Sort</h2><p>自己的理解，更精确的是selection Max sort.每次从前缀中选择最大的，放入后缀的最前面。</p><h3 id="构思">3.1 构思</h3><p>与插入排序类似，该算法也将序列划分为无序前缀和有序后缀两部分，此外，还要求前缀不大于后缀，如此，每次只需从前缀中选出最大者，并作为最小元素转移至后缀中，即可使有序部分的范围不断扩张。<br />同样的，上述描述也给出了选择排序算法过程所具有的不变性：<br /><strong>在任何时刻，后缀S(r,n)已经有序，且不小于前缀S[0,r]</strong><br />在算法的初始时刻，后缀为空，不变形自然满足。<br />序列的结构如下所示： <img src="selection-sort-idea.png" alt="Selection Sort Idea" /></p><h3 id="实例-1">3.2 实例</h3><p>选择排序算法的一个实例，如下所示： <img src="selection-sort-instance.png" alt="Selection Sort Instance" /></p><h3 id="代码-1">3.3 代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void swap(int *a, int *b)</span><br><span class="line">&#123;</span><br><span class="line">    *a &#x3D; *a ^ *b;</span><br><span class="line">    *b &#x3D; *a ^ *b;</span><br><span class="line">    *a &#x3D; *a ^ *b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print_array(int a[], int len)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for(i &#x3D; 0; i&lt;len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d &quot;,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void selection_sort(int a[],int len)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    int j;</span><br><span class="line">    int max_index;</span><br><span class="line">    for(i &#x3D; len-1; i&gt;0;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        max_index &#x3D; i; </span><br><span class="line">        for(j&#x3D;i-1;j&gt;&#x3D;0;--j)</span><br><span class="line">        &#123;</span><br><span class="line">            if(a[max_index]&lt;a[j])</span><br><span class="line">            &#123;</span><br><span class="line">                max_index &#x3D; j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;每一次选择最大的交换的过程中会导致不稳定。</span><br><span class="line">        if(max_index!&#x3D;i)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(&amp;a[max_index],&amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        print_array(a,10);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int a[] &#x3D; &#123;5,4,9,8,7,6,0,1,3,2&#125;;</span><br><span class="line">    print_array(a,10);</span><br><span class="line">    selection_sort(a,10);</span><br><span class="line">    print_array(a,10);</span><br><span class="line">&#125;</span><br><span class="line">output:</span><br><span class="line">5 4 9 8 7 6 0 1 3 2 </span><br><span class="line">5 4 2 8 7 6 0 1 3 9 </span><br><span class="line">5 4 2 3 7 6 0 1 8 9 </span><br><span class="line">5 4 2 3 1 6 0 7 8 9 </span><br><span class="line">5 4 2 3 1 0 6 7 8 9 </span><br><span class="line">0 4 2 3 1 5 6 7 8 9 </span><br><span class="line">0 1 2 3 4 5 6 7 8 9 </span><br><span class="line">0 1 2 3 4 5 6 7 8 9 </span><br><span class="line">0 1 2 3 4 5 6 7 8 9 </span><br><span class="line">0 1 2 3 4 5 6 7 8 9 </span><br><span class="line">0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><h2 id="transposition-sorting---bubble-sort">4. Transposition Sorting - Bubble Sort</h2><p>之前写过一篇文章介绍冒泡排序，可以通过本站的搜索功能找到那篇文章。<br />这里补充一个双向冒泡排序。它的基本思想是首先将第一个记录的关键字和第二个记录的关键字进行比较，若为逆序，即<code>L.r[1].key&gt;L.r[2].key</code>，则将两个记录交换，然后比较第二个和第三个记录的关键字，依此类推，直至第<code>n-1</code>个记录的关键字和第<code>n</code>个记录的关键字比较过为止。这时一趟冒泡排序，其结果是使得关键字最大的记录被安置到最后一个记录的位置上。</p><p>第一趟排序之后进行第二趟冒泡排序，将第n-2个记录的关键字与第n-1个记录的关键字进行比较，若为逆序，即<code>L.r[n-2].key&gt;L.r[n-1].key</code>,则将两个记录交换，然后比较第n-3个记录和n-2个记录的关键字，依此类推，直至第1个记录的关键字和第2个记录的关键字比较过为止。其结果是使得关键字最小的记录被安置到第1个记录的位置上。<br />再对剩余的n-2个记录进行上述同样的操作，其结果是使关键字次大的记录被安置到第n-1个记录的位置，是关键字次小的记录被安置到第2个记录的位置。</p><p>一般的，第i趟的冒泡排序是：若i为奇数，则从<code>L.r[i/2+1]~L.r[n-i/2]</code>依次比较相邻的两个关键字，并在逆序的时候交换相邻记录，其结果是这<code>n-i+1</code>个记录中关键字最大的记录被交换到第<code>n-i/2</code>的位置上；若i为偶数，则从<code>L.r[n-i/2]~L.r[i/2]</code>依次比较相邻两个记录的关键字，并在逆序时交换相邻记录，其结果是这<code>n-i+1</code>个记录中关键字最小的记录被交换到<code>i/2</code>的位置上。整个排序过程需要进行<code>K(1&lt;=K&lt;n)</code>趟冒泡排序，同样判别冒泡排序结束的条件是：在一趟排序过程中没有进行过交换记录的操作。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">void swap(int *a, int *b)</span><br><span class="line">&#123;</span><br><span class="line">    *a &#x3D; *a ^ *b;</span><br><span class="line">    *b &#x3D; *a ^ *b;</span><br><span class="line">    *a &#x3D; *a ^ *b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void print_array(int a[], int len)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for(i &#x3D; 0; i&lt;len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d &quot;,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int a[] &#x3D; &#123;5,4,9,8,7,6,0,1,3,2&#125;;</span><br><span class="line">    print_array(a,10);</span><br><span class="line">    &#x2F;&#x2F;insertion_sort(a,10);</span><br><span class="line">    bubble2sort(a,10);</span><br><span class="line">    print_array(a,10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>output: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">5 4 9 8 7 6 0 1 3 2 </span><br><span class="line">4 5 8 7 6 0 1 3 2 9 </span><br><span class="line">0 4 5 8 7 6 1 2 3 9 </span><br><span class="line">0 4 5 7 6 1 2 3 8 9 </span><br><span class="line">0 1 4 5 7 6 2 3 8 9 </span><br><span class="line">0 1 4 5 6 2 3 7 8 9 </span><br><span class="line">0 1 2 4 5 6 3 7 8 9 </span><br><span class="line">0 1 2 4 5 3 6 7 8 9 </span><br><span class="line">0 1 2 3 4 5 6 7 8 9 </span><br><span class="line">0 1 2 3 4 5 6 7 8 9 </span><br><span class="line">0 1 2 3 4 5 6 7 8 9 </span><br><span class="line">0 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure></p><h2 id="quicksort">5. QuickSort</h2><ul><li>As its name implies, QuickSort is the fastest known sorting algorithm in practice (address-based sorts can be faster)</li><li>It was devised by C.A.R. Hoare in 1962</li><li>Its average running time is <span class="math inline">\(O(nlogn)\)</span> and it is very fast</li><li>It has worst-case performance of <span class="math inline">\(O(n^2)\)</span> but this can be made very unlikely with little effort</li></ul><p>The idea is as follows:</p><ol type="1"><li>If the number of elements to be sorted is 0 or 1, then return</li><li>Pick any element, v (this is called the pivot)</li><li>Partition the other elements into two disjoint sets, <span class="math inline">\(S_1\)</span> of elements &lt;= v, and <span class="math inline">\(S_2\)</span> of elements &gt; v</li><li>Return QuickSort(<span class="math inline">\(S_1\)</span>) followed by v followed by QuickSort(<span class="math inline">\(S_2\)</span>)</li></ol><p>quicksort example:</p><figure><img src="quicksort-example.png" alt="" /><figcaption>quicksort example</figcaption></figure><p>Pseudo code for partitioning: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pivotPos &#x3D; middle of array a;</span><br><span class="line">swap a[pivotPos] with a[first];   &#x2F;&#x2F; Move the pivot out of the way</span><br><span class="line">swapPos &#x3D; first + 1;</span><br><span class="line">for each element in the array from swapPos to last do:</span><br><span class="line">    &#x2F;&#x2F; If the current element is smaller than pivot we</span><br><span class="line">    &#x2F;&#x2F; move it towards start of array</span><br><span class="line">    if (a[currentElement] &lt; a[first]):</span><br><span class="line">        swap a[swapPos] with a[currentElement];</span><br><span class="line">         increment swapPos by 1;</span><br><span class="line">    &#x2F;&#x2F; Now move the pivot back to its rightful place</span><br><span class="line">    swap a[first] with a[swapPos-1];</span><br><span class="line">    return swapPos-1;   &#x2F;&#x2F; Pivot position</span><br></pre></td></tr></table></figure> code: <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *a = *a ^ *b;</span></span><br><span class="line"><span class="comment">    *b = *a ^ *b;</span></span><br><span class="line"><span class="comment">    *a = *a ^ *b;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">int</span> temp = *b;</span><br><span class="line">    *b = *a;</span><br><span class="line">    *a = temp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_array</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition1</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> swappos = low+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//取中间元素为pivot</span></span><br><span class="line">    swap(&amp;a[low],&amp;a[(low+high)/<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">int</span> pivot = a[low];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,pivot);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = low+<span class="number">1</span>;i&lt;=high;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;pivot &amp;&amp; swappos==i)</span><br><span class="line">        &#123;</span><br><span class="line">            swappos++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[i]&lt;pivot &amp;&amp; swappos!=i)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(&amp;a[i],&amp;a[swappos]);</span><br><span class="line">            ++swappos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//swappos的位置为第一个大于pivot的位置，</span></span><br><span class="line">    <span class="comment">//将处在low处的pivot与最后一个小于pivot的（即处于swappos-1处的）元素交换</span></span><br><span class="line">    <span class="keyword">if</span>(low!=swappos<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(&amp;a[swappos<span class="number">-1</span>],&amp;a[low]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//print_array(a,10);</span></span><br><span class="line">    <span class="keyword">return</span> swappos<span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition2</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivotpos = low;</span><br><span class="line">    <span class="comment">//取中间元素为pivot</span></span><br><span class="line">    swap(&amp;a[low],&amp;a[(low+high)/<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">int</span> pivot = a[low];</span><br><span class="line">    <span class="comment">//printf("%d\n",pivot);</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = low+<span class="number">1</span>;i&lt;=high;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i]&lt;pivot &amp;&amp; ++pivotpos!=i)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(&amp;a[i],&amp;a[pivotpos]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//swappos的位置为第一个大于pivot的位置，</span></span><br><span class="line">    <span class="comment">//将处在low处的pivot与最后一个小于pivot的（即处于swappos-1处的）元素交换</span></span><br><span class="line">    <span class="keyword">if</span>(low!=pivotpos)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(&amp;a[pivotpos],&amp;a[low]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//print_array(a,10);</span></span><br><span class="line">    <span class="keyword">return</span> pivotpos;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> pivotpos = partition2(a,low,high);</span><br><span class="line">        quicksort(a,low,pivotpos<span class="number">-1</span>);</span><br><span class="line">        quicksort(a,pivotpos+<span class="number">1</span>,high);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    print_array(a,<span class="number">10</span>);</span><br><span class="line">    quicksort(a,<span class="number">0</span>,<span class="number">9</span>);</span><br><span class="line">    print_array(a,<span class="number">10</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    int a[] = &#123;5,4,9,8,7,6,0,1,3,2&#125;;</span></span><br><span class="line"><span class="comment">    swap(&amp;a[1],&amp;a[1]);</span></span><br><span class="line"><span class="comment">    printf("a=%d\n",a[1]);</span></span><br><span class="line"><span class="comment">    */</span>    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 写代码过程中遇到的坑： 1. 交换函数。用异或交换，如果是交换同一个数，就会出错。 2. partition函数太复杂，逻辑不容易记住。</p><p>下面来个简单版本的partition，partition4的介绍参见邓俊辉数据结构C++版12.1节。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition3</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = low;</span><br><span class="line">    <span class="keyword">int</span> j = high;</span><br><span class="line">    <span class="keyword">int</span> pivot = a[low];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"low=%d,high=%d\nArrayBefore:\n"</span>, low, high );</span><br><span class="line">    print_array(a,<span class="number">12</span>);</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=high &amp;&amp; a[i]&lt;=pivot)</span><br><span class="line">        &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(a[j]&gt;pivot)</span><br><span class="line">        &#123;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(&amp;a[i],&amp;a[j]);</span><br><span class="line">            <span class="comment">//++i;--j;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pivot=%d, i=%d, j=%d, a[i]=%d, a[j]=%d\n"</span>,pivot, i,j,a[i],a[j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ArrayAfterSwap\n"</span>);</span><br><span class="line">    print_array(a,<span class="number">12</span>);</span><br><span class="line">    <span class="comment">//执行完a[j]&lt;=pivot,且i&gt;=j</span></span><br><span class="line">    swap(&amp;a[j],&amp;a[low]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ArrayAfterSwapPivot:\n"</span>);</span><br><span class="line">    print_array(a,<span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition_error</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = low+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = high;</span><br><span class="line">    <span class="keyword">int</span> pivot = a[low];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"low=%d,high=%d\nArrayBefore:\n"</span>, low, high );</span><br><span class="line">    print_array(a,<span class="number">12</span>);</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=high &amp;&amp; a[i]&lt;pivot)</span><br><span class="line">        &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(a[j]&gt;pivot)</span><br><span class="line">        &#123;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(&amp;a[i],&amp;a[j]);</span><br><span class="line">            <span class="comment">//++i;--j;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pivot=%d, i=%d, j=%d, a[i]=%d, a[j]=%d\n"</span>,pivot, i,j,a[i],a[j]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ArrayAfterSwap\n"</span>);</span><br><span class="line">    print_array(a,<span class="number">12</span>);</span><br><span class="line">    <span class="comment">//执行完a[j]&lt;=pivot,且i&gt;=j</span></span><br><span class="line">    swap(&amp;a[j],&amp;a[low]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ArrayAfterSwapPivot:\n"</span>);</span><br><span class="line">    print_array(a,<span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">    <span class="comment">//确实是错的，通过打印能找出错误。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition4</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = low;</span><br><span class="line">    <span class="keyword">int</span> j = high;</span><br><span class="line">    <span class="keyword">int</span> pivot = a[low];</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//pivot&lt;=a[j];</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;j &amp;&amp; pivot&lt;=a[j])</span><br><span class="line">        &#123;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i] = a[j];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//a[i]&lt;=pivot</span></span><br><span class="line">        <span class="keyword">while</span>(i&lt;j &amp;&amp; a[i]&lt;=pivot)</span><br><span class="line">        &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)</span><br><span class="line">        &#123;</span><br><span class="line">            a[j] = a[i];</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"low=%d, high=%d, pivot=%d, i=%d, j=%d, a[i]=%d, a[j]=%d\n"</span>,low,high,pivot, i,j,a[i],a[j]);</span><br><span class="line">    <span class="comment">//执行完a[j]&lt;=pivot,且i&gt;=j</span></span><br><span class="line">    a[i]=pivot;</span><br><span class="line">    print_array(a,<span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> partition过程中会导致不稳定。</p><h2 id="merge-sort">6. Merge Sort</h2><figure><img src="merge-sort.png" alt="" /><figcaption>Merge Sort</figcaption></figure><figure><img src="merge-sort-conquer.png" alt="" /><figcaption>Merge Sort And quicksort</figcaption></figure><figure><img src="merging.png" alt="" /><figcaption>Merging</figcaption></figure><ul><li>For MergeSort an initial array is repeatedly divided into halves (usually each is a separate array), until arrays of just one element remain</li><li>At each level of recombination, two sorted arrays are merged into one</li><li>This is done by copying the smaller of the two elements from the sorted arrays into the new array, and then moving along the arrays</li></ul><p>根据辅助空间的分配策略，实现方式有以下两种：<br />Method 1:<br /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_array</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> nL = mid-left+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> nR = right-mid;</span><br><span class="line">    <span class="comment">//L store the left part; R store the right part</span></span><br><span class="line">    <span class="keyword">int</span> *L = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*nL);</span><br><span class="line">    <span class="keyword">int</span> *R = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*nR);</span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    <span class="keyword">for</span>(i = left,j=<span class="number">0</span>;i&lt;=mid; ++i,++j)</span><br><span class="line">    &#123;</span><br><span class="line">        L[j] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = mid+<span class="number">1</span>, j=<span class="number">0</span>;i&lt;=right;++i,++j)</span><br><span class="line">    &#123;</span><br><span class="line">        R[j] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(k=left,i=<span class="number">0</span>,j=<span class="number">0</span>;i&lt;nL&amp;&amp;j&lt;nR;++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(L[i]&lt;=R[j])</span><br><span class="line">        &#123;</span><br><span class="line">            a[k] = L[i];</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            a[k] = R[j];</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;nL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;nL)</span><br><span class="line">        &#123;</span><br><span class="line">            a[k++] = L[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&lt;nR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;nR)</span><br><span class="line">        &#123;</span><br><span class="line">            a[k++]=R[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(L);</span><br><span class="line">    <span class="built_in">free</span>(R);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        merge_sort(a,left,mid);</span><br><span class="line">        merge_sort(a,mid+<span class="number">1</span>,right);</span><br><span class="line">        merge(a,left,mid,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    print_array(a,<span class="number">12</span>);</span><br><span class="line">    merge_sort(a,<span class="number">0</span>,<span class="number">11</span>);</span><br><span class="line">    print_array(a,<span class="number">12</span>);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> method 2: <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_array</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right, <span class="keyword">int</span> tempArray[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//left part:[left,mid] right part:[mid+1,right]</span></span><br><span class="line">    <span class="comment">// use tempArray[left-right] to store ordered sequence, then copy back to a[]</span></span><br><span class="line">    <span class="keyword">int</span> i=left, j=mid+<span class="number">1</span>, k=left;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&lt;=a[j])</span><br><span class="line">        &#123;</span><br><span class="line">            tempArray[k] = a[i];</span><br><span class="line">            ++k;++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            tempArray[k] = a[j];</span><br><span class="line">            ++k;++j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;=mid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=mid)</span><br><span class="line">        &#123;</span><br><span class="line">            tempArray[k] = a[i];</span><br><span class="line">            ++k;++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&lt;=right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;=right)</span><br><span class="line">        &#123;</span><br><span class="line">            tempArray[k] = a[j];</span><br><span class="line">            ++k;++j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//now tempArray is in order in [left,right]</span></span><br><span class="line">    <span class="comment">//copy back</span></span><br><span class="line">    <span class="keyword">for</span>(i = left;i&lt;=right;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = tempArray[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> tempArray[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&lt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        merge_sort(a,left,mid,tempArray);</span><br><span class="line">        merge_sort(a,mid+<span class="number">1</span>,right,tempArray);</span><br><span class="line">        merge(a,left,mid,right,tempArray);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    print_array(a,<span class="number">12</span>);</span><br><span class="line">    <span class="keyword">int</span> *tempArray = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">12</span>);</span><br><span class="line">    merge_sort(a,<span class="number">0</span>,<span class="number">11</span>,tempArray);</span><br><span class="line">    <span class="built_in">free</span>(tempArray);</span><br><span class="line">    print_array(a,<span class="number">12</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="shell-sortdiminishing-increment-sorting">7. Shell Sort[diminishing increment sorting]</h2><ul><li>Named after D.L. Shell! But it is also rather like shrinking shells of sorting, for Insertion Sort.</li><li>Shell sort aims to reduce the work done by insertion sort (i.e. scanning a list and inserting into the right position).</li><li>It can be shown that this approach will sort a list with a time complexity of <span class="math inline">\(O(N^{1.25})\)</span>.</li></ul><p>希尔排序的实质就是分组插入排序，该方法又称缩小增量排序，因DL．Shell于1959年提出而得名。</p><p>该方法的基本思想是：先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。因为直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的，因此希尔排序在时间效率上比前两种方法有较大提高。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">以n&#x3D;10的一个数组49, 38, 65, 97, 26, 13, 27, 49, 55, 4为例   </span><br><span class="line">第一次 gap &#x3D; 10 &#x2F; 2 &#x3D; 5   </span><br><span class="line"></span><br><span class="line">49  38  65  97  26  13  27  49  55  4</span><br><span class="line">1A                  1B</span><br><span class="line">    2A                  2B</span><br><span class="line">        3A                  3B</span><br><span class="line">            4A                  4B</span><br><span class="line">                5A                  5B</span><br><span class="line"></span><br><span class="line">1A,1B,2A,2B等为分组标记，数字相同的表示在同一组，大写字母表示是该组的第几个元素， 每次对同一组的数据进行直接插入排序。即分成了五组(49, 13) (38, 27) (65, 49)  (97, 55)  (26, 4)这样每组排序后就变成了(13, 49)  (27, 38)  (49, 65)  (55, 97)  (4, 26)，下同。   </span><br><span class="line">第二次 gap &#x3D; 5 &#x2F; 2 &#x3D; 2   </span><br><span class="line">排序后   </span><br><span class="line"></span><br><span class="line">13  27  49  55  4  49  38  65  97  26</span><br><span class="line">1A      1B      1C     1D      1E</span><br><span class="line">    2A      2B     2C      2D      2E</span><br><span class="line"></span><br><span class="line">第三次 gap &#x3D; 2 &#x2F; 2 &#x3D; 1   </span><br><span class="line"></span><br><span class="line">4  26  13  27  38  49  49  55  97  65</span><br><span class="line">1A 1B  1C  1D  1E  1F  1G  1H  1I  1J</span><br><span class="line"></span><br><span class="line">第四次 gap &#x3D; 1 &#x2F; 2 &#x3D; 0 排序完成得到数组：   </span><br><span class="line">4  13  26  27  38  49  49  55  65  97</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_array</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellsort1</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gap,i,j,k;</span><br><span class="line">    <span class="keyword">for</span>(gap=len/<span class="number">2</span>;gap&gt;=<span class="number">1</span>;gap=gap/<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;gap;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(j=i+gap;j&lt;len;j=j+gap)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> insert_value = a[j];</span><br><span class="line">                <span class="keyword">for</span>(k=j;k&gt;=gap;k=k-gap)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(a[k-gap]&gt;insert_value)</span><br><span class="line">                    &#123;</span><br><span class="line">                        a[k]=a[k-gap];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                a[k]=insert_value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    print_array(a,<span class="number">12</span>);</span><br><span class="line">    shellsort1(a,<span class="number">12</span>);</span><br><span class="line">    print_array(a,<span class="number">12</span>);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，上面的shellsort1代码虽然对直观的理解希尔排序有帮助，但代码量太大了，不够简洁清晰。因此进行下改进和优化，以第二次排序为例，原来是每次从1A到1E，从2A到2E，可以改成从1B开始，先和1A比较，然后取2B与2A比较，再取1C与前面自己组内的数据比较...。这种每次从数组第gap个元素开始，每个元素与自己组内的数据进行直接插入排序显然也是正确的。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_array</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellsort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gap,i,j;</span><br><span class="line">    <span class="keyword">for</span>(gap=len/<span class="number">2</span>;gap&gt;=<span class="number">1</span>;gap = gap/<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//insertion sort</span></span><br><span class="line">        <span class="keyword">for</span>(i=gap; i&lt;len; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> insert_value = a[i];</span><br><span class="line">            <span class="keyword">for</span>(j=i;j&gt;=gap;j=j-gap)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"gap=%d,i=%d,j=%d\n"</span>,gap,i,j);</span><br><span class="line">                <span class="keyword">if</span>(a[j-gap]&gt;insert_value)</span><br><span class="line">                &#123;</span><br><span class="line">                    a[j] = a[j-gap];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            a[j] = insert_value;</span><br><span class="line">            print_array(a,<span class="number">12</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    print_array(a,<span class="number">12</span>);</span><br><span class="line">    shellsort(a,<span class="number">12</span>);</span><br><span class="line">    print_array(a,<span class="number">12</span>);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> http://blog.csdn.net/morewindows/article/details/6668714</p><h2 id="heap-sort">8. Heap Sort</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *b;</span><br><span class="line">    *b = *a;</span><br><span class="line">    *a = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_array</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//pos的范围为[0,len]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjustMaxHeap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> pos, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">int</span> child;</span><br><span class="line">    <span class="comment">//shift down下滤操作为temp找合适的位置</span></span><br><span class="line">    <span class="keyword">for</span>(temp = a[pos];<span class="number">2</span>*pos+<span class="number">2</span>&lt;=len;pos=child)</span><br><span class="line">    &#123;</span><br><span class="line">        child = <span class="number">2</span>*pos+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(child&lt;len &amp;&amp; a[child]&lt;a[child+<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            ++child;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[child]&gt;temp)</span><br><span class="line">        &#123;</span><br><span class="line">            a[pos]=a[child];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    a[pos]=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapsort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">//这里的i=len/2-1是有原因的，来源于以下知识点：见下面</span></span><br><span class="line">    <span class="keyword">for</span>(i=len/<span class="number">2</span><span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        adjustMaxHeap(a,i,len<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(&amp;a[<span class="number">0</span>],&amp;a[i]);</span><br><span class="line">        adjustMaxHeap(a,<span class="number">0</span>,i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    print_array(a,<span class="number">12</span>);</span><br><span class="line">    heapsort(a,<span class="number">12</span>);</span><br><span class="line">    print_array(a,<span class="number">12</span>);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>heapsort中对所有的内部节点进行调整。若对二叉树大的根节点从0开始编号，则相应的i号节点的父亲节点的编号为<code>(i-1)/2</code>，左孩子的编号为<code>2i+1</code>，右孩子的编号为<code>2i+2</code>。最后一个页节点的位置为<code>len-1</code>，所以其父亲节点为<code>(len-1-1)/2</code>，也就是<code>len/2-1</code>;</p><p>version 2: <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *b;</span><br><span class="line">    *b = *a;</span><br><span class="line">    *a = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_array</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//to heapify a subtree rooted with node i which is </span></span><br><span class="line"><span class="comment">//an index in a[], n is the size of heap [0,n)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> largest = i;<span class="comment">//Initialize largest as root</span></span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">2</span>*i+<span class="number">1</span>;<span class="comment">//left index</span></span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">2</span>*i+<span class="number">2</span>;<span class="comment">//right index</span></span><br><span class="line">    <span class="keyword">if</span>(l&lt;n &amp;&amp; a[l]&gt;a[largest])</span><br><span class="line">    &#123;</span><br><span class="line">        largest = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;n &amp;&amp; a[r]&gt;a[largest])</span><br><span class="line">    &#123;</span><br><span class="line">        largest = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(largest!=i)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(&amp;a[i],&amp;a[largest]);</span><br><span class="line">        heapify(a,n,largest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapsort2</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = len/<span class="number">2</span><span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        heapify(a,len,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(&amp;a[<span class="number">0</span>],&amp;a[i]);</span><br><span class="line">        heapify(a,i,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    print_array(a,<span class="number">12</span>);</span><br><span class="line">    heapsort2(a,<span class="number">12</span>);</span><br><span class="line">    print_array(a,<span class="number">12</span>);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> http://quiz.geeksforgeeks.org/heap-sort/</p><h2 id="radix-sort">9. Radix Sort</h2><p>http://www.geeksforgeeks.org/radix-sort/</p><h2 id="bucket-sort-bin-sort">10. Bucket Sort (Bin Sort)</h2><p>http://www.geeksforgeeks.org/bucket-sort-2/</p><h2 id="counting-sort">11. Counting Sort</h2><p>http://www.geeksforgeeks.org/counting-sort/</p>]]></content>
      
      
      <categories>
          
          <category> data structures and algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sorting </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gdb part2</title>
      <link href="/2016/09/07/gdb-part2/"/>
      <url>/2016/09/07/gdb-part2/</url>
      
        <content type="html"><![CDATA[<h1 id="using-gnus-gdb-debugger">Using GNU's GDB Debugger</h1><h2 id="memory-layout-and-the-stack">1. Memory Layout And The Stack</h2><p>From: <a href="http://www.dirac.org/linux/gdb/02a-Memory_Layout_And_The_Stack.php?printable=yes" target="_blank" rel="noopener">http://www.dirac.org/linux/gdb/02a-Memory_Layout_And_The_Stack.php?</a></p><h2 id="breakpoints-and-watchpoints">2. Breakpoints And Watchpoints</h2><p>So far you know how to list source code and run a program from within gdb. But you already knew how to do that without gdb. What else does gdb give us? To do anything really useful with gdb, you need to set breakpoints which temporarily pause your program's execution so you can do useful debugging work like inspecting variables and watching the program's execution in an atomic line-by-line fashion. This right here is the magic of a symbolic debugger.<br /><a id="more"></a> Breakpoints come in three flavors:</p><ol type="1"><li>A breakpoint stops your program whenever a particular point in the program is reached. We will discuss breakpoints momentarily.</li><li>A watchpoint stops your program whenever the value of a variable or expression changes. We'll discuss watchpoints later on in this chapter.</li><li>A catchpoint stops your program whenever a particular event occurs. We won't discuss catchpoints until I get a chance to write about them.</li></ol><p>A breakpoint stops your program whenever a particular place in the program is reached. Here are some examples of what a breakpoint does:</p><p>Mr. Computer, won't you please stop when... - you reach line 420 of the current source code file? - you enter the function validateInput()? - you reach line 2718 of the file video.c?</p><p>All those requests have one thing in common: they ask gdb to stop based on reaching some location within the program. That's what a breakpoint does. There are two things I'd like to mention before we start:</p><p>1.What does "stopping at line 5" mean?<br />When gdb stops at "line 5", this means that gdb is currently waiting "between" lines 4 and 5. Line 5 hasn't executed yet. Keep this in mind! You can execute line 5 with the next command, but line 5 has not happened yet.</p><p>2.Why did gdb stop here?<br />Sometimes you may be surprised at where gdb stops. You may have specified a breakpoint at line 5 of the source code, but gdb could stop at line 7, for instance. This can happen for 2 reasons. First, if you compile a program with optimization set, some lines of source code may be optimized out of existence; they exist in your source code, but not in the executable. Secondly, not every line of source code gets compiled into machine code instruction. See the section on "until" (FIXME: when I write it). Consider the code below: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>   <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="number">2</span>      </span><br><span class="line"><span class="number">3</span>   <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function">4   </span>&#123;</span><br><span class="line"><span class="number">5</span>        <span class="keyword">int</span> i;</span><br><span class="line"><span class="number">6</span>        i = <span class="number">3</span>;</span><br><span class="line"><span class="number">7</span>   </span><br><span class="line"><span class="number">8</span>        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">9</span>   &#125;</span><br></pre></td></tr></table></figure> Inserting a breakpoint at line X makes your program pause at line Y...</p><table><colgroup><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /><col style="width: 25%" /></colgroup><thead><tr class="header"><th>unoptimized code</th><th>unoptimized code</th><th>optimized code</th><th>optimized code</th></tr></thead><tbody><tr class="odd"><td>Breakpoint at line</td><td>rogram pauses at line</td><td>reakpoint set at line</td><td>rogram pauses at line</td></tr><tr class="even"><td>1--4, main()</td><td>4</td><td>1--4, main()</td><td>4</td></tr><tr class="odd"><td>5, 6</td><td>6</td><td>5--9</td><td>9</td></tr><tr class="even"><td>7, 8</td><td>8</td><td></td><td></td></tr><tr class="odd"><td>9</td><td>9</td><td></td><td></td></tr></tbody></table><p>Each breakpoint, watchpoint, and catchpoint you set is assigned a number starting with 1. You use this number to refer to that breakpoint. To see the list of all breakpoints and watchpoints you've set, type info breakpoints (which can be abbreviated by i b. I show a sample resulting output: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info breakpoints </span><br><span class="line">Num Type           Disp Enb Address    What</span><br><span class="line">1   breakpoint     keep y   0x080483f6 in main at try5.c:4</span><br><span class="line">  breakpoint already hit 1 time</span><br><span class="line">2   breakpoint     keep n   0x0804841a in display at try5.c:14</span><br><span class="line">  breakpoint already hit 1 time</span><br><span class="line">3   hw watchpoint  keep y   i</span><br></pre></td></tr></table></figure></p><p>According to the output, there are two breakpoints, one at line 4 and the other at line 14 of the source code. They are assigned to numbers 1 and 2 respectively. There is also a watchpoint set: the program will halt whenever the variable i (local to display()) changes value.</p><p>In addition to being assigned a number, each breakpoint and watchpoint can be enabled or disabled. A program's execution won't stop at a disabled breakpoint or watchpoint. By default, when you create a new breakpoint or watchpoint, it's enabled. To disable the breakpoint or watchpoint assigned to number <code>n</code>, type: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disable n</span><br></pre></td></tr></table></figure> To re-enable this breakpoint or watchpoint, type: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enable n</span><br></pre></td></tr></table></figure> If you look at the sample output of info breakpoints above, you'll see that breakpoint 2 has been disabled.</p><h3 id="breaking">2.1 Breaking</h3><p>Compile and run the fgets program, which is a multi-filed program (the files are fgets.c, fgets.h, and main.c: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fgets.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"fgets.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TakeGuess</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *word)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buffer[<span class="number">255</span>];</span><br><span class="line"></span><br><span class="line">fgets(buffer, <span class="number">255</span>, <span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strcmp</span>(buffer, word))</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;fgets.h</span><br><span class="line">#ifndef fGETS_H</span><br><span class="line">#define FGETS_H</span><br><span class="line"></span><br><span class="line">#define TRUE  1</span><br><span class="line">#define FALSE 0</span><br><span class="line"></span><br><span class="line">int TakeGuess(const char *word);</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;main.c</span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &quot;fgets.h&quot;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">char *word &#x3D; &quot;password&quot;;</span><br><span class="line">int  KeepGoing;</span><br><span class="line"></span><br><span class="line">printf(&quot;I&#39;m thinking of a word.  Let&#39;s see if you can guess it.\n&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">while ( KeepGoing )</span><br><span class="line">&#123;</span><br><span class="line">KeepGoing &#x3D; TakeGuess(word);</span><br><span class="line"></span><br><span class="line">if (KeepGoing &#x3D; TRUE)</span><br><span class="line">printf(&quot;Nope.  That&#39;s not right.\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">printf(&quot;Yes, that was the word!\n&quot;);</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -c -g -W -Wall fgets.c main.c</span><br><span class="line">$ gcc -o fgets fgets.o main.o</span><br></pre></td></tr></table></figure> Note that the compiler generated a warning. That's because we used '-W -Wall' which instructs gcc to tell us when it sees what it thinks might be a common programming error. The best way to debug your program is to not put the bugs in the program to begin with. You should always use these gcc bug finding options. Let me be blunt here, and I hope I don't offend anyone. It's stupid not to use <strong>-W -Wall</strong> when you compile code. Plain and simple. Stupid. With a capital S. Most people don't use them, even people who are clearly better programmers than me. That's because even smart people can do dumb things. Don't you be dumb. Always use <strong>-W -Wall</strong>.</p><p>The program is a password guessing program. Take a moment to look through the code to see how it works. The program is ultra-simple so we can focus on learning GDB rather than trying to figure out complicated code like linked lists and whatnot. You should be able to deduce how the program works (and what the password is) in under a few seconds. Now run the code and notice it simply doesn't work. We'll first concentrate on learning how to set breakpoints, and then we'll debug the program.</p><h3 id="setting-basic-breakpoints">2.2 Setting Basic Breakpoints</h3><p>There are four major ways to set a breakpoint, in roughly the order that I personally use them.:</p><ol type="1"><li>By function name.</li><li>By line number.</li><li>By filename and line number.</li><li>By address.</li></ol><h4 id="by-function-name">2.2.1 By Function Name</h4><p>We've already seen the most common way of setting a brekpoint: with the function name. <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ gdb fgets</span><br><span class="line">Using host libthread_db library &quot;&#x2F;lib&#x2F;tls&#x2F;libthread_db.so.1&quot;.</span><br><span class="line">(gdb) break main</span><br><span class="line">Breakpoint 1 at 0x8048464: file main.c, line 6.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure> The <strong>"break main"</strong> command sets a breakpoint at the top of <strong>main()</strong>, which happens to be line 6 of <strong>main.c</strong>. If we now run the program, the program will stop at line 6. Recall from the previous discussion that this means that GDB will be sitting between lines 5 and 6. Line 6 will not have executed until we issue the <strong>step</strong> command: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) run</span><br><span class="line">Starting program: code&#x2F;fgets&#x2F;fgets </span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at main.c:6</span><br><span class="line">6               char *word &#x3D; &quot;password&quot;;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure> #### 2.2.2 By Line Number</p><p>A second way of setting breakpoints is with a line number. The line number refers to the file GDB is currently in. Right now, we're in <strong>main.c</strong>, so line numbers are with respect to that file for now. Let's set a breakpoint at line 9, where the <strong>printf()</strong> statement is. <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break 9</span><br><span class="line">Breakpoint 2 at 0x804846b: file main.c, line 9.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure> GDB has a <strong>continue</strong> command which we haven't seen yet. Once GDB pauses due to a breakpoint, the <strong>continue</strong> command will resume execution. Use <strong>continue</strong> to make sure that GDB pauses at line 9: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) continue</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 2, main () at main.c:9</span><br><span class="line">9               printf(&quot;I&#39;m thinking of a word.  Let&#39;s see if you can guess it.\n&quot;);</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p><h4 id="by-filename-and-line-number">2.2.3 By Filename And Line Number</h4><p>A third way of setting breakpoints is with a filename and line number, separated with a colon. Let's set a breakpoint at line 10 of <strong>fgets.c</strong>: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break fgets.c:10</span><br><span class="line">Breakpoint 3 at 0x80483fd: file fgets.c, line 10.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p><h4 id="by-address">2.2.4 By Address</h4><p>A fourth way of setting breakpoints is with a memory address within the process's VM space. I'll find the address of TakeGuess() and set a breakpoint at that address: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print TakeGuess </span><br><span class="line">$1 &#x3D; &#123;int (const char *)&#125; 0x80483f4 &lt;TakeGuess&gt;</span><br><span class="line">(gdb) break *0x80483f4</span><br><span class="line">Breakpoint 4 at 0x80483f4: file fgets.c, line 7.</span><br></pre></td></tr></table></figure> ### 2.3 Breakpoint Numbers</p><p>You might have noticed that each breakpoint is given an integer identifier. For example, we've set 4 breakpoints already, and the last one we set (by address) was assigned the number 4. If you haven't noticed this, go back and take a look. Various operations can be performed on a breakpoint, like removing them. You can perform an operation on a particular breakpoint by referring to its integer identifier.</p><h3 id="removing-breakpoints">2.4 Removing Breakpoints</h3><p>Just as you can set breakpoints, you can also remove them. There are numerous ways to remove a breakpoint:</p><ul><li>If you want to remove the breakpoint by its location, use clear.</li><li>If you want to remove the breakpoint by its identifier, use delete.</li></ul><p>So let's use clear to remove the four breakpoints the way we set them; kind of like "undoing" what we did: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(gdb) clear *0x80483f4</span><br><span class="line">Deleted breakpoint 4 </span><br><span class="line">(gdb) clear fgets.c:10</span><br><span class="line">Deleted breakpoint 3 </span><br><span class="line">(gdb) clear 9</span><br><span class="line">Deleted breakpoint 2 </span><br><span class="line">(gdb) clear main</span><br><span class="line">Deleted breakpoint 1 </span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure> The <strong>delete</strong> command deletes breakpoints by identifier, as opposed to <strong>clear</strong> which removes breakpoints based on their location. In fact, <strong>delete n</strong> deletes the breakpoint with identifier <strong>n</strong>. We investigate this command more fully in the exercises.</p><h4 id="exercises">2.4.1 Exercises</h4><ol type="1"><li>If you've been following along with the tutorial, you shouldn't have any breakpoints set since we deleted them all with clear. Set three breakpoints wherever you like by the methods of your choice. Before you do, guess what their identifiers will be.</li><li>Use delete, not clear, to remove only the last breakpoint you set. This will leave you with two remaining breakpoints.</li><li>You should have two breakpoints left. delete with no arguments removes all breakpoints. Try it out, then quit GDB.</li></ol><h3 id="enabling-disabling-and-ignoring">2.5 Enabling, Disabling, And Ignoring</h3><p>Once set, there are only two ways to get rid of a breakpoint: remove it or quit GDB. GDB will continually break at the breakpoint. However, you'll sometimes find it useful to temporarily disable a breakpoint, that is, you do not want GDB to break at the breakpoint, but you want to keep the breakpoint there in case you need to debug that section of code again.</p><p>Breakpoints can be enabled and disabled. Simply put, your program will pause at an enabled breakpoint, but it will not pause at a disabled breakpoint.</p><p>You can enable or disable breakpoints using the <strong>enable</strong> and <strong>disable</strong> commands which take an argument of the breakpoint identifier for the breakpoint you want to enable or disable. Let's take a look at this using the <strong>fgets</strong> program that we previously used. Start a debugging session of <strong>fgets</strong> and place two breakpoints at lines 6, 9, and 12 of <strong>main.c</strong>: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ gdb fgets</span><br><span class="line">(gdb) break 6</span><br><span class="line">Breakpoint 1 at 0x8048464: file main.c, line 6.</span><br><span class="line">(gdb) break 9</span><br><span class="line">Breakpoint 2 at 0x804846b: file main.c, line 9.</span><br><span class="line">(gdb) break 12</span><br><span class="line">Breakpoint 3 at 0x8048477: file main.c, line 12.</span><br></pre></td></tr></table></figure> Disable breakpoint 2, run the program, and use <strong>continue</strong> to verify that breakpoint 2 does not pause execution. <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disable 2</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: code&#x2F;fgets&#x2F;fgets </span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at main.c:6</span><br><span class="line">6               char *word &#x3D; &quot;password&quot;;</span><br><span class="line">(gdb) continue </span><br><span class="line">Continuing.</span><br><span class="line">I&#39;m thinking of a word.  Let&#39;s see if you can guess it.</span><br><span class="line"></span><br><span class="line">Breakpoint 3, main () at main.c:12</span><br><span class="line">12              while ( KeepGoing )</span><br></pre></td></tr></table></figure> Confirmed, breakpoint 2 is disabled. Finally, enable breakpoint 2 and rerun the program. Use <strong>continue</strong> to verify that breakpoint 2 now pauses execution: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(gdb) enable 2</span><br><span class="line">(gdb) run</span><br><span class="line">The program being debugged has been started already.</span><br><span class="line">Start it from the beginning? (y or n) y</span><br><span class="line"></span><br><span class="line">Starting program: &#x2F;www&#x2F;p&#x2F;linux&#x2F;gdb&#x2F;code&#x2F;fgets&#x2F;fgets </span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at main.c:6</span><br><span class="line">6               char *word &#x3D; &quot;password&quot;;</span><br><span class="line">(gdb) continue </span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Breakpoint 2, main () at main.c:9</span><br><span class="line">9               printf(&quot;I&#39;m thinking of a word.  Let&#39;s see if you can guess it.\n&quot;);</span><br></pre></td></tr></table></figure> Confirmed, once enabled, breakpoint 2 again pauses execution.</p><h4 id="exercises-1">2.5.1 Exercises</h4><ol type="1"><li>The disable command permanently disabled a breakpoint until you explicitly enable it with enable. However, it's possible to temporarily disable a breakpoint. Use GDB's help utility to read about the ignore command, which disables a breakpoint "for n crossings".</li><li>Personally, I don't use ignore a whole lot. It seems like conditional breaking makes ignore not very useful, but you should still know of its existence. Hopefully you have GDB still open. Use ignore to disable breakpoint 3 (the one at line 12) for 3 crossings. Verify that it works.</li></ol><h3 id="listing-breakpoints">2.6 Listing Breakpoints</h3><p>So far, we've seen three commands that take a breakpoint's identifier as an argument: <strong>delete</strong>, <strong>enable</strong>, and <strong>disable</strong>. There are many others, which we'll cover later. The point is, breakpoint identifiers are useful, and you'll find yourself using them quite a bit. But how do you remember the identifiers for your breakpoints, or even where your breakpoints were set to begin with? There's a command, <strong>info breakpoints</strong> which lists all your breakpoints, their identifiers, and lots more information. Hopefully, GDB is still open from the previous subsection, so check it out: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info breakpoints </span><br><span class="line">Num Type           Disp Enb Address    What</span><br><span class="line">1   breakpoint     keep y   0x08048464 in main at main.c:6</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">2   breakpoint     keep y   0x0804846b in main at main.c:9</span><br><span class="line">        breakpoint already hit 1 time</span><br><span class="line">3   breakpoint     keep y   0x08048477 in main at main.c:12</span><br></pre></td></tr></table></figure> This is a very important command, and I find myself using it all the time. It should be completely self explanatory except for a couple of things:</p><ol type="1"><li>The <strong>Num</strong> field gives the identifier.</li><li>The <strong>Type</strong> field gives the type of breakpoint. 3. There are different types of breakpoints, like hardware watchpoints, which we'll cover shortly.</li><li>The <strong>Disp</strong> field (short for disposition) describes what will happen to the breakpoint the next time it's activated (the next time it pauses execution). <strong>keep</strong> indicates nothing will happen to the breakpoint, however, it's possible to disable or even remove a breakpoint the next time it's reached. These situations are identified by the <strong>Disp</strong> field.</li></ol><h2 id="stepping-and-resuming">3. Stepping And Resuming</h2><h3 id="setting-breakpoints-in-single-file-programs">3.1 Setting Breakpoints In Single File Programs</h3><p>There are many ways to set breakpoints. We'll go over each in turn. If you feel up to it, download try5.c and follow my example. Otherwise, you can simply follow the text (I list try5.c in the previous section). It's better if you do this alongside the tutorial, but since I'm showing gdb's output, it's not necessary. First, compile try5.c for debugging. <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//try5.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">display(x);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span> ( i=<span class="number">0</span>; i&lt;x; ++i ) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"i is %d.\n"</span>, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -Wall -W -g -o try5 try5.c</span><br></pre></td></tr></table></figure> The first (and easiest) way you can set a breakpoint is by specifying a line number. To break at line 6, simply type <strong>break 6</strong>. From now on, I'm not going to show the copyright when you first run gdb. <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gdb try5</span><br><span class="line">(gdb) break 6</span><br><span class="line">Breakpoint 1 at 0x80483f6: file try5.c, line 6.</span><br></pre></td></tr></table></figure> Wasn't that easy? You can also set breakpoints with a function name: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break display</span><br><span class="line">Breakpoint 2 at 0x804841a: file try5.c, line 15.</span><br></pre></td></tr></table></figure> Disable the 1st breakpoint, and then look at what you've done: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(gdb) disable 1</span><br><span class="line">(gdb) info breakpoints </span><br><span class="line">Num Type           Disp Enb Address    What</span><br><span class="line">1   breakpoint     keep n   0x080483f6 in main at try5.c:6</span><br><span class="line">2   breakpoint     keep y   0x0804841a in display at try5.c:15</span><br></pre></td></tr></table></figure> Now run the program. Remember, breakpoint 1 is disabled, so it'll stop at line 15. <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) run</span><br><span class="line">Starting program: &#x2F;www&#x2F;p&#x2F;linux&#x2F;gdb&#x2F;try5 </span><br><span class="line"></span><br><span class="line">Breakpoint 2, display (x&#x3D;3) at try5.c:15</span><br><span class="line">15              for (i&#x3D;0; i&lt;x; ++i) &#123;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure> We've seen 2 ways to set a breakpoint. Now here's a third. To set a breakpoint 2 lines down from the current line, use <strong>break +2</strong>. Similarly, you can set a breakpoint 3 lines up from the current line by <strong>break -3</strong>. Let's set a breakpoint at line 18 and continue the execution. <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(gdb) break +3</span><br><span class="line">Breakpoint 3 at 0x8048450: file try5.c, line 18.</span><br><span class="line">(gdb) continue</span><br><span class="line">Continuing.</span><br><span class="line">i is 0.</span><br><span class="line">i is 1.</span><br><span class="line">i is 2.</span><br><span class="line"></span><br><span class="line">Breakpoint 3, display (x&#x3D;5) at try5.c:18</span><br><span class="line">18      &#125;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure> Go ahead and quit gdb to prepare for the next section.</p><h3 id="setting-breakpoints-in-multiple-file-programs">3.2 Setting Breakpoints In Multiple File Programs</h3><p>How do we set breakpoints when a program spans multiple files?</p><p>For the form <strong>break linenumber</strong>, there is an ambiguity when you have a multiple file program. The line number of which file? The answer is that by default, the line number is taken as a line number in whatever file holds <strong>main()</strong>. That is certainly a reasonable default! But what if we wanted to break on line 5 of a different file? This gives a 4th form for the break command: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">break filename:linenumber</span><br></pre></td></tr></table></figure> This command will break on line linenumber of the source code file named filename. For example, <strong>break MyFuncs.c:102</strong> will break on line 102 of the source code file MyFuncs.c. There's a 5th form: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">break filename:function</span><br></pre></td></tr></table></figure> For example, <strong>break MyFuncs.c:MyPrintFunction</strong>. But unless you're using overloaded function names (you've defined a function multiple times), this is superfluous since you're not allowed (in C) to have 2 definitions belonging to the same function name.</p><h3 id="advanced-breaking">3.3 Advanced Breaking</h3><p>If you're trying to debug a program that doesn't have debugging info compiled into the executable, you can't set breakpoints by line number or function name. Instead you have to specify where to break by giving a memory address. This gives us a 6th form: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">break *address</span><br></pre></td></tr></table></figure> Since I know next to nothing about this, I'll move right along...</p><p>The <strong>break</strong> command without any argument gives a 7th form (only one more to go). It sets a break point at the very next instruction. Look at try5 again (having one eye on the source code will help here). <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1    $ gdb try5</span><br><span class="line">2    (gdb) break display</span><br><span class="line">3    Breakpoint 1 at 0x804841a: file try5.c, line 15.</span><br><span class="line">4    (gdb) run</span><br><span class="line">5    Starting program: &#x2F;www&#x2F;p&#x2F;linux&#x2F;gdb&#x2F;try5 </span><br><span class="line">6</span><br><span class="line">7    Breakpoint 1, display (x&#x3D;5) at try5.c:15</span><br><span class="line">8    15              for (i&#x3D;0; i&lt;x; ++i) &#123;</span><br><span class="line">9    (gdb) next</span><br><span class="line">10   16                 printf(&quot;i is %d.\n&quot;, i);</span><br><span class="line">11   (gdb) print i</span><br><span class="line">12   $1 &#x3D; 0</span><br><span class="line">13   (gdb) break</span><br><span class="line">14   Breakpoint 2 at 0x8048430: file try5.c, line 16.</span><br><span class="line">15   (gdb) continue</span><br><span class="line">16   Continuing.</span><br><span class="line">17   i is 0.</span><br><span class="line">18</span><br><span class="line">19   Breakpoint 2, display (x&#x3D;5) at try5.c:16</span><br><span class="line">20   16                 printf(&quot;i is %d.\n&quot;, i);</span><br><span class="line">21   (gdb) print i</span><br><span class="line">22   $2 &#x3D; 1</span><br></pre></td></tr></table></figure> The astute reader will wonder why, on line 22, i has the value of 1 and not 0. We set the breakpoint on line 13 when i had the value of 0. But the very next instruction (which is where we set the breakpoint) was just a printf statement (source code line 16). How in blazes did the printf increment the value of i?</p><p>Here's the answer. Once gdb stops at a breakpoint, it will ignore all other breakpoints until one line of instruction has executed. Why does it do this? If this weren't the case, everytime you stopped at a breakpoint, you'd have to disable that breakpoint to resume execution--you wouldn't be able to get past that breakpoint! If this doesn't make sense to you, think about it for awhile. If you still can't get it, don't worry. It's a minor point.</p><p>There's one more use for breakpoint form 7, the <strong>break</strong> command with no arguments. If you change to a higher frame, use <strong>break</strong> and then continue, the b <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ gdb try5</span><br><span class="line">(gdb) break display</span><br><span class="line">Breakpoint 1 at 0x804841a: file try5.c, line 15.</span><br><span class="line">15              for (i&#x3D;0; i&lt;x; ++i) &#123;</span><br><span class="line">(gdb) backtrace</span><br><span class="line">#0  display (x&#x3D;3) at try5.c:15</span><br><span class="line">#1  0x8048409 in main () at try5.c:8</span><br><span class="line">#2  0x4003e46b in __libc_start_main () from &#x2F;lib&#x2F;libc.so.6</span><br><span class="line">(gdb) frame 1</span><br><span class="line">#1  0x8048409 in main () at try5.c:8</span><br><span class="line">8          display(x);</span><br><span class="line">(gdb) break</span><br><span class="line">Breakpoint 2 at 0x8048409: file try5.c, line 8.</span><br><span class="line">(gdb) continue</span><br><span class="line">Continuing.</span><br><span class="line">i is 0.</span><br><span class="line">i is 1.</span><br><span class="line">i is 2.</span><br><span class="line"></span><br><span class="line">Breakpoint 2, 0x8048409 in main () at try5.c:8</span><br><span class="line">8          display(x);</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p><p>Can you see what happened here? We stopped at the top of display(), frame 0. We then switched to the frame 1 (main()) and issued the break command. This set a breakpoint at the very next instruction after the call to display(). We then continued execution, and the program ran until it hit the very next instruction after display(). In essence, we set the breakpoint so that execution would halt after display() returned. Make sense?</p><p>To reiterate, the 7th form of breakpoint is used for loops when you're in the top most frame and returns from functions when you're not in the top most frame. Frankly, I don't find this terribly useful. When in a loop, I think the break +offset or break linenumber is more convenient. For returning from functions, I find the finish command more useful (which you'll learn about shortly).</p><p>The 8th and last form of break command is the conditional breakpoint. They are quite useful but little understood. Perhaps part of the reason is that the gdb User Manual does a really poor job explaining them. Here is the form: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">break ... if cond</span><br></pre></td></tr></table></figure> where ... represents any one of the previous 7 forms of breakpoints we've learned about already and cond is any conditional in the language you're using. Here is an example: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ gdb try5</span><br><span class="line">(gdb) break 16 if i&#x3D;&#x3D;2</span><br><span class="line">Breakpoint 1 at 0x8048430: file try5.c, line 16.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: &#x2F;www&#x2F;p&#x2F;linux&#x2F;gdb&#x2F;try5 </span><br><span class="line">i is 0.</span><br><span class="line">i is 1.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, display (x&#x3D;3) at try5.c:16</span><br><span class="line">16                 printf(&quot;i is %d.\n&quot;, i);</span><br></pre></td></tr></table></figure></p><p>We used the 1st form of break with the conditional i==2. We could've also used a test for inequality, like i!=2 or i&gt;2. This is mega useful when you're inside of a loop that's going to repeat a million times. The 8th form of break is your friend!</p><h3 id="summary-of-breakpoints">3.4 Summary Of Breakpoints</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Form 1:break linenumberSet a breakpoint at line number linenumber</span><br><span class="line">Form 2:break functionSet a breakpoint at function function.</span><br><span class="line">Form 3:break filename:linenumberSet a breakpoint at line linenum in source file filename.</span><br><span class="line">Form 4:break *addressSet a breakpoint at address &lt;address&gt;. Use this to set breakpoints in parts of a program that doesn&#39;t have debugging information or source files.</span><br></pre></td></tr></table></figure><h3 id="deleting-breakpoints">3.5 Deleting Breakpoints</h3><p>Here are the commands used to delete breakpoints you've set when they've outlived their usefulness. <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">clear &lt;function&gt;Clear any breakpoints set at the entry to the function &lt;function&gt;.</span><br><span class="line">clear &lt;filename&gt;&lt;function&gt;Clear any breakpoints set at the entry to the function &lt;function&gt; defined in the source code file &lt;filename&gt;.</span><br><span class="line">clear &lt;linenum&gt;Clear any breakpoints set at line &lt;linenum&gt; of the current source file. The current source file is the last file whose text was printed.</span><br><span class="line">clear &lt;filename:linenum&gt;Clear any breakpoints at line &lt;linenum&gt; in file &lt;filename&gt;.</span><br><span class="line">deleteClear all breakpoints.</span><br><span class="line">delete nEach breakpoint is assigned a number starting with 1. This clears breakpoint n.</span><br></pre></td></tr></table></figure></p><h3 id="inspecting-variables">3.6 Inspecting Variables</h3><p>Note to Fortran users: All Fortran variables must be in lowercase, regardless of how they were capitalized in your source code. This is because the Fortran standard specifies case independence when it comes to variables. Yes, variable C is variable c in the Fortran standard. There are compilers out there that allow you to use case dependent variables, but this is non-standard, and gcc mandates all lowercase variables. This was done to support legacy code. Sigh.</p><p>The whole purpose of setting a breakpoint or watchpoint is to see what's going on with your variables, so let's take a look at inspecting your variables. You can print the data type of a variable using the ptype command. Here are some examples: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) ptype argc</span><br><span class="line">type &#x3D; int</span><br><span class="line">(gdb) ptype myfloat</span><br><span class="line">type &#x3D; float</span><br><span class="line">(gdb) ptype argv </span><br><span class="line">type &#x3D; char **</span><br><span class="line">(gdb) ptype mystring</span><br><span class="line">type &#x3D; unsigned char *</span><br><span class="line">(gdb) pt myIntArray</span><br><span class="line">type &#x3D; int [10]</span><br></pre></td></tr></table></figure> You can even use ptype to look at structures. Take, for example, the fstat structure defined in sys/stat.h. <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">(gdb) ptype fstat</span><br><span class="line">type &#x3D; struct stat &#123;</span><br><span class="line">    __dev_t st_dev;</span><br><span class="line">    short unsigned int __pad1;</span><br><span class="line">    __ino_t st_ino;</span><br><span class="line">    __mode_t st_mode;</span><br><span class="line">    __nlink_t st_nlink;</span><br><span class="line">    __uid_t st_uid;</span><br><span class="line">    __gid_t st_gid;</span><br><span class="line">    __dev_t st_rdev;</span><br><span class="line">    short unsigned int __pad2;</span><br><span class="line">    __off_t st_size;</span><br><span class="line">    long unsigned int st_blksize;</span><br><span class="line">    __blkcnt_t st_blocks;</span><br><span class="line">    __time_t st_atime;</span><br><span class="line">    long unsigned int __unused1;</span><br><span class="line">    __time_t st_mtime;</span><br><span class="line">    long unsigned int __unused2;</span><br><span class="line">    __time_t st_ctime;</span><br><span class="line">    long unsigned int __unused3;</span><br><span class="line">    long unsigned int __unused4;</span><br><span class="line">    long unsigned int __unused5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> That's quite a structure! You can abbreviate ptype by pt. <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) pt mydouble</span><br><span class="line"></span><br><span class="line">type &#x3D; double</span><br></pre></td></tr></table></figure> Remember, you can only print the data type of a variable which is defined in the currently selected frame.</p><p>Now that you know how to print the data type of your variables, you may want to print their values. Consider the following program (which will be compiled via gcc -g filename):<br /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1   #include&lt;stdio.h&gt;</span><br><span class="line">2   #include&lt;string.h&gt;</span><br><span class="line">3   </span><br><span class="line">4   int main( int argc, char *argv[] )</span><br><span class="line">5   &#123;</span><br><span class="line">6        double mydouble &#x3D; 3.14 &#x2F; 3;</span><br><span class="line">7        float  myfloat  &#x3D; 3.3;</span><br><span class="line">8        char   mychar   &#x3D; &#39;A&#39;;</span><br><span class="line">9        int    myIntArray[10];</span><br><span class="line">10       int    MyNegativeInt &#x3D; -1;</span><br><span class="line">11       char   myString[20];</span><br><span class="line">12  </span><br><span class="line">13       struct foo &#123;</span><br><span class="line">14            char *name;</span><br><span class="line">15            int  EyeColour;</span><br><span class="line">16       &#125; myStruct;</span><br><span class="line">17  </span><br><span class="line">18       strncpy(myString, &quot;hello&quot;, 19);</span><br><span class="line">19  </span><br><span class="line">20       for ( int i &#x3D; 0; i &lt; 10; i++ )</span><br><span class="line">21            myIntArray[i] &#x3D; i;</span><br><span class="line">22  </span><br><span class="line">23       return 0;</span><br><span class="line">24  &#125;</span><br></pre></td></tr></table></figure> You can view the value of a variable using the print command. <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print i</span><br><span class="line">$4 &#x3D; -1073744780</span><br></pre></td></tr></table></figure> I stopped the program right before the for loop, so this is what variable i is before it gets initialized. gdb prints the value of the variable which is most <code>comfortable' (to borrow fortran 99 lingo) with the datatype. In other words, floats get printed as floats: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print myfloat</span><br><span class="line">$1 &#x3D; 3.29999995</span><br></pre></td></tr></table></figure> and doubles get printed as doubles: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print mydouble</span><br><span class="line">$1 &#x3D; 1.0466666666666666</span><br></pre></td></tr></table></figure> and chars get printed as chars: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print mychar</span><br><span class="line">$1 &#x3D; 65 &#39;A&#39;</span><br></pre></td></tr></table></figure> By the way, you can use the abbreviation p for print: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p argc</span><br><span class="line">$1 &#x3D; 1</span><br></pre></td></tr></table></figure> You may be wondering what the numbers preceeded by</code>$ (like $1 or $3)` mean. They're kind of like a variable history. Everytime you print any variable, the $n gets incremented by 1. $ by itself refers to the last variable you printed and $n refers to the n'th variable you printed. Look at the following example to see this: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p mychar</span><br><span class="line">$26 &#x3D; 65 &#39;A&#39;</span><br><span class="line">(gdb) p mydouble</span><br><span class="line">$27 &#x3D; 1.0466666666666666</span><br><span class="line">(gdb) p $</span><br><span class="line">$28 &#x3D; 1.0466666666666666</span><br><span class="line">(gdb) p $27</span><br><span class="line">$29 &#x3D; 1.0466666666666666</span><br><span class="line">(gdb) p $26</span><br><span class="line">$30 &#x3D; 65 &#39;A&#39;</span><br></pre></td></tr></table></figure> You can even typecast a variable when you print it! Here's MyNegativeInt as an int, char and double respectively: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p MyNegativeInt</span><br><span class="line">$41 &#x3D; -1</span><br><span class="line">(gdb) p (char) MyNegativeInt</span><br><span class="line">$42 &#x3D; -1 &#39;ÿ&#39;</span><br><span class="line">(gdb) p (double) MyNegativeInt</span><br><span class="line">$43 &#x3D; -1</span><br></pre></td></tr></table></figure> The possibilities are endless. But wait, there's more!</p><h3 id="inspecting-arrays-and-structures">3.7 Inspecting Arrays And Structures</h3><p>Printing array values is much the same as printing other variables. gdb still uses the concept of being `comfortable'. In other words, when you print an array, that's exactly what you get! From the code snippet of the previous section: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p myIntArray</span><br><span class="line">$46 &#x3D; &#123;0, 1, 2, 3, 4, 5, 6, 7, 8, 9&#125;</span><br></pre></td></tr></table></figure> Of course, gdb knows how to access elements of an array: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) pt myIntArray</span><br><span class="line">type &#x3D; int [10]</span><br><span class="line">(gdb) pt myIntArray[3]</span><br><span class="line">type &#x3D; int</span><br><span class="line">(gdb) p myIntArray[3]</span><br><span class="line">$48 &#x3D; 3</span><br></pre></td></tr></table></figure> You can do kind of advanced stuff too -- things that you'd expect from only Perl :-). Here's how you print 5 elements of myIntArray, starting at element 3: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p myIntArray[3]@5</span><br><span class="line">$49 &#x3D; &#123;3, 4, 5, 6, 7&#125;</span><br></pre></td></tr></table></figure> GDB will not, however, check bounds of the array. Previously we defined myIntArray as an array of 10 ints. Let's see what happens when we try printing 4 ints past the end of the array: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p myIntArray[3]@11</span><br><span class="line">$54 &#x3D; &#123;3, 4, 5, 6, 7, 8, 9, 10, 1107293224, 1079194419, -1947051841&#125;</span><br></pre></td></tr></table></figure> Doh! Hopefully, that's not someone's password. :-). You can also print structures: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p myStruct</span><br><span class="line">$2 &#x3D; &#123;name &#x3D; 0x40014978 &quot;Miles Davis&quot;, EyeColour &#x3D; 1&#125;</span><br></pre></td></tr></table></figure> However, this might get out of hand for very large structs. You can set pretty printing of structures by set print pretty: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set print pretty</span><br><span class="line">(gdb) p myStruct</span><br><span class="line">$4 &#x3D; &#123;</span><br><span class="line">  name &#x3D; 0x40014978 &quot;Miles Davis&quot;, </span><br><span class="line">  EyeColour &#x3D; 1</span><br><span class="line">&#125;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure> or, if you only want one of the elements of the structure, you can print it in the way that would seem obvious: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print myStruct.name</span><br><span class="line">$6 &#x3D; 0x40014978 &quot;Miles Davis&quot;</span><br></pre></td></tr></table></figure> this works too, but why is a mystery to me: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print myStruct-&gt;name </span><br><span class="line">$15 &#x3D; 0x40014978 &quot;Miles Davis&quot;</span><br></pre></td></tr></table></figure></p><h3 id="advanced-inspection">3.8 Advanced Inspection</h3><p>You can print things using a format specifier: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print &#x2F;FMT variable</span><br></pre></td></tr></table></figure> Where FMT is: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ooctalxhexddecimaluunsigned decimal</span><br><span class="line">tbinaryffloataaddresscchar</span><br></pre></td></tr></table></figure> Here's some examples of printing some of our variables using a format specifier: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p mychar</span><br><span class="line">$33 &#x3D; 65 &#39;A&#39;</span><br><span class="line">(gdb) p &#x2F;o mychar</span><br><span class="line">$34 &#x3D; 0101</span><br><span class="line">(gdb) p &#x2F;x mychar </span><br><span class="line">$35 &#x3D; 0x41</span><br><span class="line">(gdb) p &#x2F;d mychar </span><br><span class="line">$36 &#x3D; 65</span><br><span class="line">(gdb) p &#x2F;u mychar </span><br><span class="line">$37 &#x3D; 65</span><br><span class="line">(gdb) p &#x2F;t mychar </span><br><span class="line">$38 &#x3D; 1000001</span><br><span class="line">(gdb) p &#x2F;f mychar </span><br><span class="line">$39 &#x3D; 65</span><br><span class="line">(gdb) p &#x2F;a mychar </span><br><span class="line">$40 &#x3D; 0x41</span><br></pre></td></tr></table></figure> By the way, memory addresses in gdb are printed in hex by default. Therefore, p /a mychar prints mychar interpreted as an address, the hexidecimal representation of 65. This is very different from the address of mychar!</p><p>Speaking of the address of mychar, one would expect that since C loves pointers, gdb would love pointers too. And in fact, it does! Printing the address of mychar is obvious to C programmers (sorry, Fortran users!): <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p &amp;mychar</span><br><span class="line">$42 &#x3D; 0xbffff41b &quot;A33S@¿Xò\213%¿ð?Hôÿ¿\023â\003@\001&quot;</span><br></pre></td></tr></table></figure> gdb even knows about the dereference operator. How's this for being perverse? <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p *(&amp;mychar)</span><br><span class="line">$43 &#x3D; 65 &#39;A&#39;</span><br></pre></td></tr></table></figure> This is the perfect vehicle for teaching students what a pointer is. We're dereferencing the address of mychar. Of course, there's more to this than just coolness (although it's worth it for the coolness factor alone!). I was writing a curses program once and it kept segfaulting on me whenever I tried drawing to a WINDOW object. By looking at the address of a WINDOW that I was passing to a function, I determined that I was passing a WINDOW by value, drawing to a local copy of the WINDOW and returning. Of course, the local copy of the WINDOW wasn't anything initialized by curses so drawing to it was causing a segmentation violation. Looking at the code, it was highly non-obvious what was was going on; it looked just swell! It wasn't until I compared the address of the passed WINDOW with the address of the received WINDOW that I discovered the big oops!</p><p>Furthermore, who here is guilty of buffer overruns? Be truthful! It's very easy to fall into the `off by one' error when you initialize, write to or read from a C array. How many times have you used strcpy when you should've used strncpy? These errors are insidious because they usually don't crash the program, but manifest themselves in wierd behavior in certain rare cases that are hard to track down. Looking at the addresses of what's going on is a sure fire way of finding out the details of what's going on.</p><h3 id="changing-variables">3.9 Changing Variables</h3><p>There are two ways you can change the value of a variable in gdb. Let's change the value of <strong>double myvariable</strong> to 10.0. Firstly, you can use the <strong>set</strong> command: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set myvariable &#x3D; 10.0</span><br></pre></td></tr></table></figure> which is the 'quiet' way. gdb will simply set myvariable to 10 without printing anything. Then there's the 'noisy' way using the print command: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print myvariable &#x3D; 10.0</span><br></pre></td></tr></table></figure> which will set <strong>myvariable</strong> to 10.0 and then print this new value to the screen. The <strong>print</strong> command ends up being less keystrokes because you can use the abbreviation <strong>p</strong> for <strong>print</strong>.</p><p>Remember, you can only change the value of a variable which is defined within the current context. Make sure the variable you want to change is defined in the currently selected frame. If it's not, you need to set the frame before you can change the variable.</p><h3 id="stepping-through-your-program">3.10 Stepping through your program</h3><p>One thing that is good to know is the exact sequence of execution of your program, especially through loops and conditional branches. If the program is not too large, you can follow it easily by executing one line at a time.</p><p>There are two commands used to step through your program:</p><p><strong>step:</strong><br />Execute a single line in the program. If the current statement calls a function, the function is single stepped.<br /><strong>next:</strong><br />Execute a single line in the program but treat function calls as a single line. This command is used to skip over function calls.</p><p>Since C statements like printf() and scanf() are functions themselves, if you step through all your program (as opposed to next, you'll find yourself stepping through glibc, the standard C library (which is probably not what you want!). <strong>Good debugging makes use of next mostly</strong>. If you really want to step through a function call, it's best to set a breakpoint there and then you can use next from inside the function.</p><p>To execute the next statement, type: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">step</span><br></pre></td></tr></table></figure> Each time you type a step command, gdb will then list the line that it is about to execute, with the line number on the left, so you can see what's about to happen before it happens.</p><h3 id="finding-out-where-you-are-and-listing-source-code">3.11 Finding out where you are and listing source code</h3><p>To find out where you are at any time, type the command: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">where</span><br></pre></td></tr></table></figure> This will show you the current line number. For example, a line like this: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#0  foo () at foo.f:12</span><br></pre></td></tr></table></figure> shows that the execution of our program is currently at a location that corresponds to line 12 in the Fortran source file, foo.f.</p><p>You can display a few lines of your source program around the current location by using the command: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list</span><br></pre></td></tr></table></figure> This will list 10 lines of source roughly centred on your current line number. If you haven't started to debug yet, it will list the first 10 lines of source code. If you type list again, it'll print the next 10 lines of source code. You can also type: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list 25</span><br></pre></td></tr></table></figure> and this will list 10 lines of source code centred on line 25. Typing list again will list the next 10 lines of source code. You can also specify a range of lines to be listed. For example, to list lines 10 through 24 in the current program, you'd type: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list 10,24</span><br></pre></td></tr></table></figure> If there is a function in your program named endpoints(), you can list 10 lines centred on the start of <strong>endpoints()</strong> by: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list endpoints</span><br></pre></td></tr></table></figure> If you're listing lines and decide you want to see the 10 lines previous to the 10 lines you just displayed: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list -</span><br></pre></td></tr></table></figure> Suppose you set a breakpoint: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">break 55</span><br></pre></td></tr></table></figure> and gdb responds with: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint 1 at 0x8048540: file program3.c, line 55.</span><br></pre></td></tr></table></figure> You can list the lines centred around that address by specifying the asterisk (for address). It will list the 10 lines centred around the source code line containing that address. <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list *0x8048540</span><br></pre></td></tr></table></figure></p><h2 id="debugging-a-running-process">4. Debugging A Running Process</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;beer-process &amp;</span><br><span class="line">   [1] 17399</span><br><span class="line">   p@satan$ 100000 bottles of beer on the wall.</span><br><span class="line">   99999 bottles of beer on the wall.</span><br><span class="line">   99998 bottles of beer on the wall.</span><br><span class="line">   99997 bottles of beer on the wall.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gdb beer-process 17399</span><br><span class="line">Attaching to program: code&#x2F;running_process&#x2F;beer-process, process 17399</span><br><span class="line">0x410c64fb in nanosleep () from &#x2F;lib&#x2F;tls&#x2F;libc.so.6</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><h3 id="with-the-attach-command">4.1 With The Attach Command</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gdb</span><br><span class="line">   (gdb) attach 17399</span><br><span class="line">   Attaching to process 17399</span><br><span class="line">   Reading symbols from code&#x2F;running_process&#x2F;beer-process...done.</span><br><span class="line">   0x410c64fb in nanosleep () from &#x2F;lib&#x2F;tls&#x2F;libc.so.6</span><br><span class="line">   (gdb)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> c </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> gdb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sizeof</title>
      <link href="/2016/09/06/sizeof/"/>
      <url>/2016/09/06/sizeof/</url>
      
        <content type="html"><![CDATA[<p>solving sizeof problem using gdb.</p><a id="more"></a><p><strong>可执行代码</strong>: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: bubble_sort.c</span></span><br><span class="line"><span class="comment">&gt; Author: yanruibo</span></span><br><span class="line"><span class="comment">&gt; Mail: yanruibo1992@163.com</span></span><br><span class="line"><span class="comment">&gt; Created Time: Mon 05 Sep 2016 03:34:19 PM CST</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_a</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> exchange = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>,j;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n<span class="number">-1</span> &amp;&amp; exchange)</span><br><span class="line">    &#123;</span><br><span class="line">        exchange = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = n - <span class="number">1</span>; j &gt;= i; --j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j<span class="number">-1</span>]&gt;a[j])</span><br><span class="line">            &#123;</span><br><span class="line">                a[j<span class="number">-1</span>] = a[j] + a[j<span class="number">-1</span>];</span><br><span class="line">                a[j] = a[j<span class="number">-1</span>] - a[j];</span><br><span class="line">                a[j<span class="number">-1</span>] = a[j<span class="number">-1</span>] - a[j];</span><br><span class="line">                exchange = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++i;</span><br><span class="line">        <span class="keyword">int</span> size = <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"size=%d\n"</span>,size);</span><br><span class="line">        print_a(a,<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    bubble_sort(a,<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">int</span> size = <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>,size);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">输出结果：</span><br><span class="line">size=<span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> </span><br><span class="line">size=<span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> </span><br><span class="line">size=<span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> </span><br><span class="line">size=<span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> </span><br><span class="line">size=<span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> </span><br><span class="line">size=<span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> </span><br><span class="line">size=<span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure> 结果不对呀，我们每一趟交换之后都打印一下数组，为什么只打印出前两个呢？于是题主用gdb调试一下： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(gdb) backtrace</span><br><span class="line">#0  bubble_sort (a&#x3D;0x7fffffffd3c0, n&#x3D;9) at bubble_sort.c:39</span><br><span class="line">#1  0x00000000004007d2 in main (argc&#x3D;1, argv&#x3D;0x7fffffffd4d8) at bubble_sort.c:46</span><br><span class="line">(gdb) frame 1</span><br><span class="line">#1  0x00000000004007d2 in main (argc&#x3D;1, argv&#x3D;0x7fffffffd4d8) at bubble_sort.c:46</span><br><span class="line">46    bubble_sort(a,sizeof(a)&#x2F;sizeof(int));</span><br><span class="line">(gdb) p sizeof(a)</span><br><span class="line">$11 &#x3D; 36</span><br><span class="line">(gdb) p a</span><br><span class="line">$12 &#x3D; &#123;1, 2, 3, 9, 8, 7, 6, 5, 4&#125;</span><br><span class="line">(gdb) frame 0</span><br><span class="line">#0  bubble_sort (a&#x3D;0x7fffffffd3c0, n&#x3D;9) at bubble_sort.c:39</span><br><span class="line">39        printf(&quot;size&#x3D;%d\n&quot;,size);</span><br><span class="line">(gdb) p a</span><br><span class="line">$13 &#x3D; (int *) 0x7fffffffd3c0</span><br><span class="line">(gdb) p sizeof(a)</span><br><span class="line">$14 &#x3D; 8</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure> 发现在bubble_sort函数中使用sizeof(a)处，可以打印出a[0]到a[8]都可以，但是sizeof(a)为8，sizeof(int)为4，但是我们在bubble_sort函数中和main函数中打印a的方法是不一样的，在main函数中<code>p a</code>是一个数组，<code>p &amp;a</code>才是a的地址，而在bubble_sort中<code>p a</code>是一个指针，由此可知，在main函数中sizeof(a)求的是数组的大小36，而在bubble_sort函数中sizeof(a)求的是a指针的大小8，这也从另一方面说明了在c语言中操作数组的时候都要传<code>(int a[], int n)</code>数组的指针和数组的大小，因为在函数中用sizeof计算得到的是指针的大小，不然的话只传<code>(int a[])</code>就足够了。</p><p>另外sizeof是一个关键字不是一个函数，属于数据类型关键字。</p>]]></content>
      
      
      <categories>
          
          <category> c </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> sizeof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>const in c and cpp</title>
      <link href="/2016/09/06/const-in-c-and-cpp/"/>
      <url>/2016/09/06/const-in-c-and-cpp/</url>
      
        <content type="html"><![CDATA[<h1 id="const">const</h1><h2 id="const-in-c-and-cpp">1. const in c and cpp</h2><p><code>const char* a</code>: 指向常量字符的指针，const限定的是char；<br /><code>char const* a</code>：指向字符的常量指针，const限定的是指针a；<br /><code>char *const a</code>:因为const int a与int const a等价，说明const放在类型和变量之前是一样的效果。<br /><a id="more"></a> 接下来来介绍一下const问题，C语言以及C++语言中的const究竟表示什么？其具体的实现机制又是如何实现的呢？ 　　 本文将对这两个问题进行一些分析，简单解释const的含义以及实现机制。<br />问题分析：简单的说const在C语言中表示只读的变量，而在C++语言中表示常量。<br />那么const究竟是如何实现的呢？ 对于声明为const的内置类型，例如int，short，long等等，编译器会如何实现const的本意？那么对于非内置类型是否也是与内置数据类型一样处理呢，例如对于结构体类型则会怎样处理呢？下面通过几个小例子来说明这些问题。<br />C语言const示例： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i=<span class="number">10</span>; <span class="keyword">int</span> *p=(<span class="keyword">int</span> *)(&amp;i); *p=<span class="number">20</span>; <span class="built_in">printf</span>(<span class="string">"i=%d *p=%d \n"</span>,i,*p);</span><br></pre></td></tr></table></figure> 猜一猜输出结果是什么？ <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">20</span> *p=<span class="number">20</span></span><br></pre></td></tr></table></figure> C++语言const示例1： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i=<span class="number">10</span>; </span><br><span class="line"><span class="keyword">int</span> *p=<span class="keyword">const_cast</span>&lt;<span class="keyword">int</span> *&gt;(&amp;i);</span><br><span class="line">*p=<span class="number">20</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"i="</span>&lt;&lt;i&lt;&lt;<span class="string">" *p="</span>&lt;&lt;*p&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure> 输出结果为： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">10</span> *p=<span class="number">20</span></span><br></pre></td></tr></table></figure> C++语言const示例2： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">char</span> tmp;</span><br><span class="line">test()</span><br><span class="line">&#123;</span><br><span class="line">j=<span class="number">30</span>;</span><br><span class="line">tmp=<span class="string">'a'</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">test</span> <span class="title">t1</span>;</span></span><br><span class="line">    <span class="keyword">int</span> *q=(<span class="keyword">int</span> *)(&amp;t1.j);</span><br><span class="line">    *q=<span class="number">40</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"j="</span>&lt;&lt;t1.j&lt;&lt;<span class="string">" *q="</span>&lt;&lt;*q&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 运行结果为： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">j=<span class="number">40</span> *q=<span class="number">40</span></span><br></pre></td></tr></table></figure></p><p>示例结果分析：</p><p>看到上面三组输出结果，有没有感到很诡异：<br />问题1，对于const int类型的变量i，C语言中通过指针p修改了值后，i变成了20；而在C++中，通过指针p修改了值后，i仍然是10。<br />问题2，C++语言中 const struct test的元素j通过指针q被改变了，为何const int 与 const struct test的反应机制不同？</p><p>针对问题1，我们知道C语言中const表示只读的变量，既然把const看成是变量，那么其在内存中就会有存储他的空间，并且可以通过指针间接的改变该内存空间的值，当通过指针p改变该内存中的值后，再获取i的值的时候，会访问该空间，得到的是被改变后的值。而C++把const看做常量，编译器会使用常数直接替换掉对i的引用，例如<code>cout&lt;&lt;i;</code>会理解成<code>cout&lt;&lt;10;</code> 并不会去访问i的内存地址去取数据，这里有点像是C语言里的宏<code>#define i 10</code>。因此C++里i会输出10，而<code>*p</code>会输出20.</p><p>针对问题2，C++语言中只是对于内置数据类型做常数替换，而对于像结构体这样的非内置数据类型则不会。因为结构体类型不是内置数据类型，编译器不知道如何直接替换，因此必须要访问内存去取数据，而访问内存去取数据必然会取到被指针q改变后的值，因此会造成与C++中const int类型完全不一样的处理模式。</p><h2 id="引用类型和const">2. 引用类型和const</h2><p>引用就是变量的别名，另一个名字，没有产生另一个对象。<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;x;</span><br><span class="line"><span class="keyword">int</span> &amp;r = x;<span class="comment">//r绑定x，不会是别人的引用了，不能改变，不允许有空的引用，</span></span><br><span class="line"><span class="comment">//声明的时候必须初始化且初始化之后不能修改</span></span><br><span class="line"><span class="keyword">int</span> x2 = <span class="number">5</span>;</span><br><span class="line">r = x2;</span><br><span class="line"><span class="keyword">int</span> &amp;r2= r;</span><br></pre></td></tr></table></figure> 上面代码都没有问题。 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span>&amp; r = i;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p = &amp;i;<span class="comment">//p不能变，指针的指向不能变，</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p1;<span class="comment">//指向的整型值不能变，可以到处指，指针的内容不能变，可以随处指但指向的内容不能变。</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> a;<span class="comment">//const放在前面后面都是一样的</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *p2;<span class="comment">//和p1一样</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p3;<span class="comment">//没有指向不能编译通过，常量必须初始化，两个都不能变</span></span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span>* <span class="keyword">const</span> p4;<span class="comment">//p4和p3一样</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> <span class="keyword">const</span> *<span class="keyword">const</span> p5;<span class="comment">// 3,4,5都编译不通过</span></span><br></pre></td></tr></table></figure> 编译结果：<br />g++: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">yanruibo@yanruibo-PC:~&#x2F;self-learning&#x2F;blog-code$ g++ test.cpp </span><br><span class="line">test.cpp: In function ‘int main(int, char**)’:</span><br><span class="line">test.cpp:17:15: error: uninitialized const ‘a’ [-fpermissive]</span><br><span class="line">     const int a;</span><br><span class="line">               ^</span><br><span class="line">test.cpp:18:15: error: redeclaration of ‘const int a’</span><br><span class="line">     int const a;&#x2F;&#x2F;const放在前面后面都是一样的</span><br><span class="line">               ^</span><br><span class="line">test.cpp:17:15: error: ‘const int a’ previously declared here</span><br><span class="line">     const int a;</span><br><span class="line">               ^</span><br><span class="line">test.cpp:20:22: error: uninitialized const ‘p3’ [-fpermissive]</span><br><span class="line">     const int *const p3;&#x2F;&#x2F;没有指向不能编译通过，常量必须初始化，两个都不能变</span><br><span class="line">                      ^</span><br><span class="line">test.cpp:21:22: error: uninitialized const ‘p4’ [-fpermissive]</span><br><span class="line">     int const* const p4;&#x2F;&#x2F;p4和p3一样</span><br><span class="line">                      ^</span><br><span class="line">test.cpp:22:15: error: duplicate ‘const’</span><br><span class="line">     const int const *const p5;&#x2F;&#x2F; 3,4,5都编译不通过</span><br><span class="line">               ^</span><br><span class="line">test.cpp:22:28: error: uninitialized const ‘p5’ [-fpermissive]</span><br><span class="line">     const int const *const p5;&#x2F;&#x2F; 3,4,5都编译不通过</span><br><span class="line">                            ^</span><br></pre></td></tr></table></figure> clang++:<br /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">test.cpp:17:15: error: default initialization of an object of const type &#39;const int&#39;</span><br><span class="line">    const int a;</span><br><span class="line">              ^</span><br><span class="line">test.cpp:18:15: error: default initialization of an object of const type &#39;const int&#39;</span><br><span class="line">    int const b;&#x2F;&#x2F;const放在前面后面都是一样的</span><br><span class="line">              ^</span><br><span class="line">test.cpp:20:22: error: default initialization of an object of const type &#39;const int *const&#39;</span><br><span class="line">    const int *const p3;&#x2F;&#x2F;没有指向不能编译通过，常量必须初始化，两个都不能变</span><br><span class="line">                     ^</span><br><span class="line">test.cpp:21:22: error: default initialization of an object of const type &#39;const int *const&#39;</span><br><span class="line">    int const* const p4;&#x2F;&#x2F;p4和p3一样</span><br><span class="line">                     ^</span><br><span class="line">test.cpp:22:15: warning: duplicate &#39;const&#39; declaration specifier [-Wduplicate-decl-specifier]</span><br><span class="line">    const int const *const p5;&#x2F;&#x2F; 3,4,5都编译不通过</span><br><span class="line">              ^~~~~~</span><br><span class="line">test.cpp:22:28: error: default initialization of an object of const type &#39;const int *const&#39;</span><br><span class="line">    const int const *const p5;&#x2F;&#x2F; 3,4,5都编译不通过</span><br><span class="line">                           ^</span><br><span class="line">1 warning and 5 errors generated.</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> c </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> const </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>automatic variables, local variables, static variables in c</title>
      <link href="/2016/09/06/automatic-variables-local-variables-static-variables-in-c/"/>
      <url>/2016/09/06/automatic-variables-local-variables-static-variables-in-c/</url>
      
        <content type="html"><![CDATA[<h1 id="全局变量局部变量和静态变量">全局变量、局部变量和静态变量</h1><p>转一篇很好的介绍自动变量，局部变量，静态变量的博文，原文链接：<br /><a href="http://www.eefocus.com/jinshaomin/blog/14-02/302032_c5e28.html" target="_blank" rel="noopener">http://www.eefocus.com/jinshaomin/blog/14-02/302032_c5e28.html</a></p><p>众所周知，C中的变量主要有全局变量、局部变量和静态变量。</p><h2 id="全局变量">1. 全局变量</h2><p>　　全局变量：在函数外面定义的变量为全局变量，工程内的所有文件都可以访问他；但是它在整个工程内只能定义一次，不能有重复的定义，不然就会发生错误，而其他的文件要想使用这个变量，必须用extern来声明这个变量，这个声明叫做引用声明。这一点很重要，如果你没有用extern来声明在其他文件中已经定义的全局变量，就来使用它，就会发生错误。<font color="purple">如果你只是想在定义他的文件中使用它，而不允许在其他的文件中使用它，那么就用关键字static来在函数外面声明变量。这样这个变量在其他文件中将不可见，即它的连接性而内部链接。有一点是我们只得注意的像：如果你在函数外这样声明一个变量，const int a ; 变量a的连接性为内部链接，只能在定义他的文件内使用。还有如果你在定义静态变量的时候并没有给变量初始化，则静态变量将被自动初始化为0；</font><br /><a id="more"></a> ## 2. 局部变量</p><p>　　局部变量：局部变量，如不作专门说明为自动变量，都是动态分配存储空间，存储在动态存储区中。这种变量叫自动变量。这种变量只在定义它们的时候才创建，在定义它们的函数返回时系统回收变量所占存储空间。对这些变量存储空间的分配和回收是由系统自动完成的，所以也叫自动变量。一般情况下，不作专门说明的局部变量，均是自动变量。<font color="purple">自动变量也可用关键字auto作出说明。</font></p><h2 id="静态变量">3. 静态变量</h2><p>　　静态变量：静态变量与自动变量的本质区别是，静态变量并不像自动变量那样使用堆栈机制来使用内存。而是为静态变量分配固定的内存，在程序运行的整个过程中，它都会被保持，而不会被销毁。这就是说静态变量的持续性是程序运行的整个周期。这有利于我们共享一些数据。如果静态变量在函数内部定义，则它的作用域就是在这个函数内部，仅在这个函数内部使用它才有效，但是它不同于自动变量的，自动变量离开函数后就会被销毁，而静态变量不会被销毁。他在函数的整个运行周期内都会存在。</p><h2 id="总结">4. 总结</h2><p>　　变量有作用域、链接属性和存储类型3个属性，以下是一些总结：</p><table><thead><tr class="header"><th style="text-align: center;">变量类型</th><th style="text-align: center;">声明位置</th><th style="text-align: center;">存储位置</th><th style="text-align: center;">作用域</th><th style="text-align: center;">声明为static后的链接属性</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">全局变量</td><td style="text-align: center;">所有代码块之外</td><td style="text-align: center;">内存</td><td style="text-align: center;">从声明到文件末</td><td style="text-align: center;">不允许从其他文件访问</td></tr><tr class="even"><td style="text-align: center;">局部变量</td><td style="text-align: center;">代码块起始处</td><td style="text-align: center;">堆栈</td><td style="text-align: center;">整个代码块</td><td style="text-align: center;">不在堆栈，它的值在整个执行期保持</td></tr></tbody></table><p>了解以上三种变量后，再看题目中的三种变量；</p><p>　　自动变量：自动地存储于内存中，地址随机，即局部变量</p><p>　　寄存器变量：在c语言当中可以使用寄存器变量来优化程序的性能,最常见的是在一个函数体当中,将一个常用的变量声明为寄存器变量: register int ra; 如果可能的话,编译器就会为它分配一个单独的寄存器，在整个函数执行期间对这个变量的操作全都是对这个寄存器进行操作,这时候就不用频繁地去访存了,自然就提高了性能.但是寄存器变量不是强制性的,也就是,即使你使用register关键字去声明一个变量为寄存器变量，编译器还是有可能把它作为一个普通的变量而不是寄存器变量来使用的.</p><p>　　易失变量：volatile(嵌入式程序员必须掌握的)，volatile最初的意思是表示汽油容易挥发，在c中的作用大概有两点：（1）表示变量是易失的，易变的。 （2）强制访存操作，防止编译器去优化，告诉编译器每次必须去内存中取值，而不是从寄存器或者缓存。</p>]]></content>
      
      
      <categories>
          
          <category> c </category>
          
      </categories>
      
      
        <tags>
            
            <tag> variable types </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gdb part1</title>
      <link href="/2016/09/05/gdb-part1/"/>
      <url>/2016/09/05/gdb-part1/</url>
      
        <content type="html"><![CDATA[<h1 id="gnus-gdb-debugger">GNU's GDB Debugger</h1><h2 id="chapter-1">1. chapter 1</h2><p>To use gdb, do the following:<br /><strong>Compile your program with the -g flag e.g.</strong><br /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -Wall -Wstrict-prototypes -ansi -pedantic -g myprog.c -o myprog</span><br></pre></td></tr></table></figure> (Note that we're using a lot of warning options as well, which are the "-Wall -Wstrict-prototypes -ansi -pedantic" options; these force the compiler to complain if your code isn't ANSI-compliant or if it has other suspicious features. It's a good habit to always use these options.) The "-g" option puts debugging information into the executable. Most importantly, it puts the text of the source code file into the executable so you can examine it as the program executes (we'll see how below).<br /><a id="more"></a></p><p>Type gdb myprog (for the example above). This will start the interactive debugger. It's basically an interpreter-like environment in which you can run your program line-by-line and do useful debugging tasks as well.</p><p>When in the debugger, you have a choice of lots of commands. Do "info" to get a list of commands. Here are some of the most important ones:<br /><strong> <code>run</code>: runs the program<br /><code>where</code>: tells you where you are in the program when you have stopped at some point. Also tells you the calling history of the program up to that point (i.e. which functions have been called to get you where you are).<br /><code>p &lt;variable&gt;</code>: prints the value of <variable><br /><code>break &lt;file&gt;:&lt;line&gt;</code>: causes the program to stop at a particular line in a particular source code file<br /><code>break &lt;function&gt;</code>: causes the program to stop when entering a particular function.<br /><code>n</code>: executes the next statement and then stops. This command will not enter a new function while you're inside a function. Instead, it goes to the next statement in the current function.<br /><code>s</code>: executes the next statement, possibly entering a new function, and then stops.<br /><code>l</code>: lists lines in a source code file.<br /><code>c</code>: continues executing the program.<br /><code>q</code>: exits (quits) gdb.<br />Several of these commands have longer names that you can use as well: print for p, next for n, step for s, list for l, cont for c, and quit for q.<br /></strong></p><p>You get GDB to pause execution by using breakpoints. We'll cover breakpoints later, but for now, all you need to know is that when you tell GDB break 5, the program will pause at line 5. You may ask: does the program execute line 5 (pause between 5 and 6) or does the program not execute line 5 (pause between 4 and 5)? The answer is that line 5 is not executed. Remember these principles:<br /><strong> 1.<code>break 5</code> means to pause at line 5.<br />2.This means GDB pauses between lines 4 and 5. Line 4 has executed. Line 5 has not.<br /></strong></p><p>We can look at the stack by using GDB's <code>backtrace</code> command.<br />We can ask GDB to tell us which frame its context is in by giving the <code>frame</code> command without arguments.</p><p>We can tell GDB to switch from frame 0 to <code>frame 1</code> using the frame command with the frame number as an argument. This gives us access to the variables in frame 1. As you can guess, after switching frames, we won't have access to variables stored in frame 0.</p><h2 id="chapter-2">2. chapter 2</h2><p>In the last chapter we learned about an executing process's memory layout which is divided into segments. One important segment is the call stack (or stack), which is a collection of stack frames (or frames). There is one frame for each function call, and the frame holds three important things:</p><ol type="1"><li>The local variables for the function.</li><li>The current address pointer within the function.</li><li>The arguments passed to the function.</li></ol><p>When a function is called, a new frame is allocated and added to the stack. When the function returns, its frame is returned back to unused stack memory and execution resumes at the address pointed to by the previous function's current address pointer. We can ask GDB to tell us what the stack looks like with the <code>backtrace</code> command. We can also find out which frame GDB's context is in using the <code>frame</code> command. Lastly, we can change GDB's context to the n'th frame using the <code>frame n</code> command.</p><p>Executables don't contain references to object (function and variable) names or source code line numbers. It would be painful to debug a program without these things, so to debug a program, we generate an augmented symbol table using gcc's <code>-g</code> option.</p><p>Lastly, we briefly learned how to make GDB pause execution using the break command and execute one line of source code using the step command. We'll have much more to say about these commands shortly.</p><h3 id="list">2.1 list</h3><h4 id="basic-listing-of-source-code">2.1.1 Basic Listing of Source Code</h4><p>By default, GDB always lists 10 lines of source code. <font color="purple">When you first issue <code>list</code>, GDB lists 10 lines of source code centred on <code>main()</code></font>. Subsequent use of <code>list</code> gives the next 10 lines of source code.</p><p><code>list -</code> works like <code>list</code>, except in reverse. It lists the 10 lines previous to the last listed lines. If line 50 was the last listed line, <code>list -</code> should print lines 41 through 50.</p><p>If you give <code>list</code> a line number, GDB lists 10 lines centered on that line number:</p><p>Other listing operations you'll find useful:</p><ul><li>starting with some line number <strong>(gdb) list 5,</strong></li><li>ending with some line number <strong>(gdb) list ,28</strong></li><li>between two numbers: <strong>(gdb) list 21,25</strong></li><li>by function name: <strong>(gdb) list f</strong></li><li>functions in the other file: <strong>(gdb) list CentralDiff</strong></li><li>by filename and line number: <strong>(gdb) list derivative.c:12</strong></li><li>filename and function name: <strong>(gdb) list derivative.c:ForwardDiff</strong></li></ul><h4 id="listing-by-memory-address-advanced">2.1.2 Listing By Memory Address (advanced)</h4><p>Every function begins at some memory address. You can find this address with the print function (which we'll cover later). For instance, we'll find the address for main(): <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) print *main</span><br><span class="line">$1 &#x3D; &#123;int (int, char **)&#125; 0x8048647 &lt;main&gt;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure> So main() lives at 0x8048647. We can use list using memory locations as well; the syntax is very C'ish: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(gdb) list *0x8048647</span><br><span class="line">0x8048647 is in main (driver.c:17).</span><br><span class="line">12     &#125;</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16     int main(int argc, char *argv[])</span><br><span class="line">17     &#123;</span><br><span class="line">18          double x, dx, ans;</span><br><span class="line">19          double Forw, ForwDelta, Cent, CentDelta, Extr, ExtrDelta;</span><br><span class="line">20</span><br><span class="line">21          if (argc !&#x3D; 1) &#123;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p><h4 id="setting-the-list-size">2.1.3 Setting The List Size</h4><p>GDB lists code in increments of 10 lines. Maybe that's too much. Or maybe that's too little. You can tell GDB to change the listing size with the set command and listsize variable: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set listsize 5</span><br><span class="line">(gdb) list main</span><br><span class="line">15</span><br><span class="line">16     int main(int argc, char *argv[])</span><br><span class="line">17     &#123;</span><br><span class="line">18          double x, dx, ans;</span><br><span class="line">19          double Forw, ForwDelta, Cent, CentDelta, Extr, ExtrDelta;</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure></p><h3 id="the-.gdbinit-file">2.2 The .gdbinit File</h3><p>Upon startup, GDB reads and executes an initialization file named <code>.gdbinit</code>. It can contain any command (eg <code>set</code> and <code>break</code>), and more. For example, "set listsize" and "set prompt" can go into <code>.gdbinit</code>. There are two locations where GDB will look for this file (in order): - In your home directory - In the current directory</p><p>You can put commands to be executed for all your programming projects in <code>$HOME/.gdbinit</code> and project-specific commands in <code>$PWD/.gdbinit</code>.</p><p>You can comment your <code>.gdbinit</code> files with bash's "#". And blank lines, of course, are ignored.</p><h3 id="run-command">2.3 run command</h3><p>Running A Program In GDB</p><p>Let's properly introduce the run command. <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; argc; ++i)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Argument %d: %s\n"</span>, i, argv[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> The run command with no arguments runs your program without command line arguments. If you want to give the program arguments, use the run command with whatever arguments you want to pass to the program: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ gdb arguments</span><br><span class="line">(gdb) run 1 2</span><br><span class="line">Starting program: try2 1 2</span><br><span class="line">Argument 0: arguments</span><br><span class="line">Argument 1: 1</span><br><span class="line">Argument 2: 2</span><br><span class="line"></span><br><span class="line">Program exited normally.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure> Nothing could be simpler. From now on, whenever you use run again, it will automatically use the arguments you just used (ie, "1 2"): <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(gdb) run</span><br><span class="line">Starting program: arguments 1 2</span><br><span class="line">Argument 0: arguments</span><br><span class="line">Argument 1: 1</span><br><span class="line">Argument 2: 2</span><br><span class="line"></span><br><span class="line">Program exited normally.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure> until you tell it to use different arguments: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(gdb) run testing one two three</span><br><span class="line">Starting program: arguments testing one two three</span><br><span class="line">Argument 0: testing</span><br><span class="line">Argument 1: one</span><br><span class="line">Argument 2: two</span><br><span class="line">Argument 3: three</span><br><span class="line"></span><br><span class="line">Program exited normally.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure> Suppose you want to run the program without command line arguments? How do you get run to stop automatically passing them? There is a "set args" command. If you give this command without any parameters, run will no longer automatically pass command line arguments to the program: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set args</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: arguments </span><br><span class="line">Argument 0: try2</span><br><span class="line"></span><br><span class="line">Program exited normally.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure> If you do give an argument to set args, those arguments will be passed to the program the next time you use run, just as if you had given those arguments directly to run.</p><p>There is one more use for set args. If you intend on passing the same arguments to a program every time you begin a debugging session, you can put it in your .gdbinit file. This will make run pass your arguments to the program without you having to specify them every time you start GDB on a given project.</p><h3 id="restarting-a-program-in-gdb">2.4 Restarting A Program In GDB</h3><p>Sometimes you'll want to re-start a program in GDB from the beginning. One reason why you'd want to do this is if you find that the breakpoint you set is too late in the program execution and you want to set the breakpoint earlier. There are three ways of restarting a program in GDB.</p><ol type="1"><li>Quit GDB and start over.</li><li>Use the <code>kill</code> command to stop the program, and <code>run</code> to restart it.</li><li>Use the GDB command <code>run</code>. GDB will tell you the program is already running and ask if you want to re-run the program from the beginning.</li></ol><p>The last two options will leave everything intact: breakpoints, watchpoints, commands, convenience variables, etc. However, if you don't mind starting fresh with nothing saved from your previous debugging session, quitting GDB is certainly an option.</p><p>You might be wondering why there's a <code>kill</code> command when you can either <code>quit</code> GDB with quit or re-run the program with <code>run</code>. The <code>kill</code> command seems kind of superfluous. There are some reasons why you'd use this command, and you can read about them here. Thanks to Suresh Babu for pointing out that the <code>kill</code> command may also be useful when you are remote debugging or if a process is debugged via the <code>attach</code> command. That said, I've never used <code>kill</code> myself.</p><h2 id="reference">3. reference:</h2><p><font color="purple"> <a href="http://www.dirac.org/linux/gdb/02a-Memory_Layout_And_The_Stack.php" target="_blank" rel="noopener">http://www.dirac.org/linux/gdb/02a-Memory_Layout_And_The_Stack.php</a><br />非常好的gdb学习资料 </font></p>]]></content>
      
      
      <categories>
          
          <category> c </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> gdb </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bubble sort</title>
      <link href="/2016/09/05/bubble-sort/"/>
      <url>/2016/09/05/bubble-sort/</url>
      
        <content type="html"><![CDATA[<h1 id="冒泡排序">冒泡排序</h1><p>交换排序的基本思想是：两两比较待排序记录的关键字，发现两个记录的次序相反时即进行交换，直到没有反序的记录为止。应用交换排序基本思想的主要排序方法有：冒泡排序和快速排序。<br /><a id="more"></a> 本文介绍第一种交换排序方法：冒泡排序。<br />## 1. 排序方法 将被排序的记录数组R[1..n]垂直排列，每个记录R[i]看作是重量为R[i].key 的气泡。根据轻气泡不能在重气泡之下的原则，从下往上扫描数组R：凡扫描到违反本原则的轻气泡，就使其向上"飘浮"。如此反复进行，直到最后任何两个气泡都是轻者在上，重者在下为止。<br />1.初始<br />R[1..n]为无序区。<br />2.第一趟扫描<br />从无序区底部向上依次比较相邻的两个气泡的重量，若发现轻者在下、重者在上，则交换二者的位置。即依次比较(R[n]，R[n-1])，(R[n-1]，R[n-2])，…，(R[2]，R[1])；对于每对气泡(R[j+1]，R[j])，若R[j+1].key &lt; R[j].key，则交换R[j+1]和R[j]的内容。<br />第一趟扫描完毕时，"最轻"的气泡就飘浮到该区间的顶部，即关键字最小的记录被放在最高位置R[1]上。<br />3.第二趟扫描<br />扫描R[2..n]。扫描完毕时，"次轻"的气泡飘浮到R[2]的位置上…… 最后，经过n-1 趟扫描可得到有序区R[1..n]</p><p>注意： 第 i 趟扫描时，R[1..i-1]和 R[i..n]分别为当前的有序区和无序区。扫描仍是从无序区底部向上直至该区顶部。扫描完毕时，该区中最轻气泡飘浮到顶部位置 R[i]上，结果是 R[1..i]变为新的有序区。</p><h2 id="排序算法">2. 排序算法</h2><h3 id="分析">2.1 分析</h3><p>因为每一趟排序都使有序区增加了一个气泡，在经过 n-1 趟排序之后，有序区中就有 n-1 个气泡，而无序区中气泡的重量总是大于等于有序区中气泡的重量，所以整个冒泡排序过程至多需要进行 n-1 趟排序。</p><p>若在某一趟排序中未发现气泡位置的交换，则说明待排序的无序区中所有气泡均满足轻者在上，重者在下的原则，因此，冒泡排序过程可在此趟排序后终止。为此，在下面给出的算法中，引入一个布尔量 exchange，在每趟排序开始前，先将其置为 FALSE。若排序过程中发生了交换，则将其置为 TRUE。各趟排序结束时检查 exchange，若未曾发生过交换则终止算法，不再进行下一趟排序。</p><h3 id="具体算法">2.2 具体算法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(SeqList R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//R(1..n)是待排序的序列，采用自下向上扫描，对R做冒泡排序</span></span><br><span class="line">    <span class="comment">//注意排序的数据是从1开始。</span></span><br><span class="line"><span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">bool</span> exchange;<span class="comment">//交换标志</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt; n; ++i)<span class="comment">//最多做n-1趟排序</span></span><br><span class="line">    &#123;</span><br><span class="line">    exchange = False;<span class="comment">//本趟排序开始前，交换标志应为false</span></span><br><span class="line">        <span class="keyword">for</span>(j=n<span class="number">-1</span>; j&gt;=i; --j)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">if</span>(R[j+<span class="number">1</span>].key &lt; R[j].key)<span class="comment">//交换记录</span></span><br><span class="line">            &#123;</span><br><span class="line">            R[<span class="number">0</span>] = R[j+<span class="number">1</span>];<span class="comment">//R[0]不是哨兵,仅做暂存单元</span></span><br><span class="line">                R[j+<span class="number">1</span>] = R[j];</span><br><span class="line">                R[j] = R[<span class="number">0</span>];</span><br><span class="line">                exchange = True;<span class="comment">//发生了交换，故将交换标志设置为真</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!exchange)&#123;<span class="keyword">return</span>;&#125;<span class="comment">//本趟排序未发生交换，提前终止算法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="purple">记住几个重点的地方，从后往前扫描，第一次扫描1-n,第二次扫描2-n,第n-1次扫描n-1至n。上面的算法是把小的交换到前面</font> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;//<span class="title">algorithm</span> <span class="title">of</span> <span class="title">bubble</span> <span class="title">sort</span></span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">dataList</span>&lt;Type&gt;:</span>:bubbleSort()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//sort form Element[0] to Element[ArraySize-1]</span></span><br><span class="line"><span class="comment">// ArraySize is the length of array</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>, exchange = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//if exchange is 0,then stop，如果没有交换就停止</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;ArraySize &amp;&amp; exchange)</span><br><span class="line">    &#123;</span><br><span class="line">    exchange = <span class="number">0</span>;<span class="comment">//initialization</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = ArraySize<span class="number">-1</span>; j &gt;= i; --j)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">if</span>(Element[j<span class="number">-1</span>] &gt; Element[j])</span><br><span class="line">            &#123;</span><br><span class="line">            swap(Element[j<span class="number">-1</span>],Element[j]);</span><br><span class="line">                <span class="comment">//swap Element[j-1] and Element[j]</span></span><br><span class="line">                exchange = <span class="number">1</span>;<span class="comment">//set the flag to 1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//一趟结束</span></span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="算法分析">3. 算法分析</h2><h3 id="算法的最好时间复杂度">3.1 算法的最好时间复杂度</h3><p>若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数C和记录移动次数M均达到最小值：<br /><span class="math inline">\(C_{min}=n-1;M_{min}=0\)</span><br />冒泡排序最好的时间复杂度为 O(n)。</p><h3 id="算法的最坏时间复杂度">3.2 算法的最坏时间复杂度</h3><p>若初始文件是反序的，需要进行 n-1 趟排序。每趟排序要进行 n-i 次关键字的比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值： <span class="math inline">\(C_{max}=n(n-1)/2=O(n^2);M_{max}=3n(n-1)/2=O(n^2)\)</span><br />冒泡排序的最坏时间复杂度为 O(n^2)。</p><h3 id="算法的平均时间复杂度为-on2">3.3 算法的平均时间复杂度为 O(n^2)</h3><p>虽然冒泡排序不一定要进行 n-1 趟，但由于它的记录移动次数较多，故平均时间性能比直接插入排序要差得多。</p><h3 id="算法稳定性">3.4 算法稳定性</h3><p>冒泡排序是就地排序，且它是稳定的。</p><h2 id="算法改进">4. 算法改进</h2><p>上述的冒泡排序还可做如下的改进：<br />1.记住最后一次交换发生位置 lastExchange 的冒泡排序</p><p>在每趟扫描中，记住最后一次交换发生的位置 lastExchange，（该位置之前的相邻记录均已有序）。下一趟排序开始时，R[1..lastExchange-1]是有序区，R[lastExchange..n]是无序区。这样，一趟排序可能使当前有序区扩充多个记录，从而减少排序的趟数。</p><p>2.改变扫描方向的冒泡排序</p><h2 id="冒泡排序的不对称性">5. 冒泡排序的不对称性</h2><p>能一趟扫描完成排序的情况：<br />只有最轻的气泡位于 R[n]的位置，其余的气泡均已排好序，那么也只需一趟扫描就可以完成排序。<br />【例】对初始关键字序列 12，18，42，44，45，67，94，10 就仅需一趟扫描。<br />需要 n-1 趟扫描完成排序情况：<br />当只有最重的气泡位于R[1]的位置，其余的气泡均已排好序时，则仍需做n-1趟扫描才能完成排序。<br />【例】对初始关键字序列：94，10，12，18，42，44，45，67 就需七趟扫描。</p><h3 id="造成不对称性的原因">5.1 造成不对称性的原因</h3><p>每趟扫描仅能使最重气泡"下沉"一个位置，因此使位于顶端的最重气泡下沉到底部时，需做 n-1 趟扫描。</p><h3 id="改进不对称性的方法">5.2 改进不对称性的方法</h3><p>在排序过程中交替改变扫描方向，可改进不对称性。</p><h3 id="可执行代码">5.3 可执行代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************************************************************************</span></span><br><span class="line"><span class="comment">&gt; File Name: bubble_sort.c</span></span><br><span class="line"><span class="comment">&gt; Author: yanruibo</span></span><br><span class="line"><span class="comment">&gt; Mail: yanruibo1992@163.com</span></span><br><span class="line"><span class="comment">&gt; Created Time: Mon 05 Sep 2016 03:34:19 PM CST</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_a</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> exchange = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>,j;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n<span class="number">-1</span> &amp;&amp; exchange)</span><br><span class="line">    &#123;</span><br><span class="line">        exchange = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = n - <span class="number">1</span>; j &gt;= i; --j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j<span class="number">-1</span>]&gt;a[j])</span><br><span class="line">            &#123;</span><br><span class="line">                a[j<span class="number">-1</span>] = a[j] + a[j<span class="number">-1</span>];</span><br><span class="line">                a[j] = a[j<span class="number">-1</span>] - a[j];</span><br><span class="line">                a[j<span class="number">-1</span>] = a[j<span class="number">-1</span>] - a[j];</span><br><span class="line">                exchange = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d:"</span>,i);</span><br><span class="line">        print_a(a,<span class="number">9</span>);</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort2</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> exchange = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>,j;</span><br><span class="line">    <span class="keyword">int</span> last_exchange = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> last_exchange_tmp=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n<span class="number">-1</span> &amp;&amp; exchange)</span><br><span class="line">    &#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">        exchange = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j = n - <span class="number">1</span>; j &gt;= last_exchange; --j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j<span class="number">-1</span>]&gt;a[j])</span><br><span class="line">            &#123;</span><br><span class="line">                a[j<span class="number">-1</span>] = a[j] + a[j<span class="number">-1</span>];</span><br><span class="line">                a[j] = a[j<span class="number">-1</span>] - a[j];</span><br><span class="line">                a[j<span class="number">-1</span>] = a[j<span class="number">-1</span>] - a[j];</span><br><span class="line">                exchange = <span class="number">1</span>;</span><br><span class="line">                last_exchange_tmp = j;<span class="comment">//记住j的位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        last_exchange = last_exchange_tmp;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"last_exchange = %d\n"</span>,last_exchange);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d:"</span>,i);</span><br><span class="line">        print_a(a,<span class="number">9</span>);</span><br><span class="line">        ++i;</span><br><span class="line">        <span class="keyword">if</span>(last_exchange==n<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"original:"</span>);</span><br><span class="line">    print_a(a,<span class="number">9</span>);</span><br><span class="line">    bubble_sort(a,<span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">int</span> b[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"original:"</span>);</span><br><span class="line">    print_a(b,<span class="number">9</span>);</span><br><span class="line">    bubble_sort2(b,<span class="keyword">sizeof</span>(b)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">运行结果：</span><br><span class="line">original:<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> </span><br><span class="line"><span class="number">1</span>:<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> </span><br><span class="line"><span class="number">2</span>:<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> </span><br><span class="line"><span class="number">3</span>:<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> </span><br><span class="line"><span class="number">4</span>:<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">9</span> <span class="number">8</span> </span><br><span class="line"><span class="number">5</span>:<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> </span><br><span class="line"><span class="number">6</span>:<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> </span><br><span class="line">original:<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> </span><br><span class="line">last_exchange = <span class="number">4</span></span><br><span class="line"><span class="number">1</span>:<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span> </span><br><span class="line">last_exchange = <span class="number">5</span></span><br><span class="line"><span class="number">2</span>:<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> <span class="number">6</span> </span><br><span class="line">last_exchange = <span class="number">6</span></span><br><span class="line"><span class="number">3</span>:<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">9</span> <span class="number">8</span> <span class="number">7</span> </span><br><span class="line">last_exchange = <span class="number">7</span></span><br><span class="line"><span class="number">4</span>:<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">9</span> <span class="number">8</span> </span><br><span class="line">last_exchange = <span class="number">8</span></span><br><span class="line"><span class="number">5</span>:<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><p>再提醒一次，分析的时候注意是从后往前扫描。</p><h2 id="另一版本的冒泡排序">6. 另一版本的冒泡排序</h2><p>还有一个版本的冒泡排序就是从前往后扫描，第一趟扫描将最大的元素移到最后一个位置，第二趟扫描将前面无序区的最大元素移到倒数第二个位置，以此类推。对应的代码如下所示： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">buble_sort</span><span class="params">(<span class="keyword">int</span> A[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">bool</span> sorted = <span class="literal">false</span>;<span class="comment">//整体排序标志，首先假定尚未排序</span></span><br><span class="line">    <span class="keyword">while</span>(!sorted)</span><br><span class="line">    &#123;</span><br><span class="line">    sorted = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i<span class="number">-1</span>]&gt;A[i])</span><br><span class="line">            &#123;</span><br><span class="line">            swap(A[i<span class="number">-1</span>],A[i]);</span><br><span class="line">                sorted = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> data structures and algorithms </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bubble sort </tag>
            
            <tag> data structures and algorithms </tag>
            
            <tag> sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cpp notes</title>
      <link href="/2016/09/04/cpp-notes/"/>
      <url>/2016/09/04/cpp-notes/</url>
      
        <content type="html"><![CDATA[<p>note 1:<br />一个派生类对象如果是public继承的，那么可以被当做一个基类对象来使用<br />- 基类对象可以使用派生类对象赋值<br />- 基类的引用可以用派生类对象初始化<br />- 基类的指针可以用派生类指针赋值<br />- 通过基类指针，对象名只能使用从基类继承的成员</p><a id="more"></a><p>note 2:<br />In the static binding, the decision about which function to use to resolve an overload is made at compile time.<br />静态绑定表示的是调用哪个函数在编译时候已经决定。<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span> :</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">( )</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; “it is in a”&lt;&lt;<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span> <span class="keyword">public</span> A </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> :</span><br><span class="line">     <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">( )</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; “it is in b”&lt;&lt;<span class="built_in">endl</span>;  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> A a;</span><br><span class="line"><span class="number">2.</span> B b;</span><br><span class="line"><span class="number">3.</span> …</span><br><span class="line"><span class="number">4.</span> a.f(); b.f();</span><br><span class="line">Here, <span class="function">the determination of which <span class="title">f</span><span class="params">()</span> is used in the two calls at line4 is computable at compile time</span></span><br></pre></td></tr></table></figure> If a member function is declared to be virtual, dynamic binding is used. The decision about which function to use to resolve an overload is made at run time, if it cannot be determined at compile time:<br />Virtualness is inherited.<br />It is override but not overload.<br />A run-time decision is needed only when an object is accessed through a pointer or reference to a base class.<br />1 如果声明为virtual，则为动态绑定，决定调用哪个函数是在运行时决定的，编译时不能决定。<br />2 虚函数是被继承的。<br />3 是覆盖不是重载。<br />4 动态绑定一般是当通过指针访问基类成员时。</p><p>note 3:<br />A method is declared abstract by specifying that it is virtual and by supplying = 0 in the interface in place of an implementation.<br />An abstract method has no meaningful definition and is thus always defined in the derived class.<br />A class that has at least one abstract method is called an abstract class Because the behavior of an abstract class is not completely defined, abstract classes can never be instantiated.<br />When a derived class fails to override an abstract method with an implementation, it remains abstract, and the compiler reports an error if an attempt to instantiate the abstract derived class is made.<br />抽象方法：纯需函数，抽象类实际上就是画一个框架，它的所有孩子都拥有一样的框架，只是每个人的有不一样<br />1 抽象函数是在函数前加virtual，后面加上=0<br />2 抽象函数没有实际意义的定义，总是在子类里被定义<br />3 至少有一个纯需函数的类叫做抽象类<br />4 因为没有被完整的定义，所以抽象类不能被实例化<br />5 当一个子类没有写抽象方法的实现时，这个子类仍然是抽象类，如果实例化仍然会出错</p><p>note 4:<br />Exception Handling<br />C++ exception handling centers around the use of the try keyword and the catch keyword<br />The C++ Standard Library provides and uses a standard exception class hierarchy.<br />Head file: <code>#include &lt;stdexcept&gt;</code><br />sample code:<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;        </span><br><span class="line">          <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;  </span><br><span class="line">              <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Usage: "</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">" num"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">              <span class="keyword">return</span> EXIT_FAILURE;       </span><br><span class="line">         &#125;        </span><br><span class="line">         <span class="keyword">int</span> number_fib = atoi(argv[<span class="number">1</span>]);       </span><br><span class="line">        calculate_fibonacci(number_fib);       </span><br><span class="line">        <span class="keyword">return</span> EXIT_SUCCESS;    </span><br><span class="line">    &#125;    </span><br><span class="line">   <span class="keyword">catch</span> (exception&amp; e) &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">endl</span>;    </span><br><span class="line">      &#125;    </span><br><span class="line">   <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <image src="cpp-exception.png" align="center"></p><p>In C++, a variable of any data type can be thrown as an exception using the throw statement.<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        srand(time(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">if</span> (rand() % <span class="number">2</span> == <span class="number">0</span>) &#123; </span><br><span class="line">           <span class="keyword">throw</span> out_of_range(<span class="string">"out of range"</span>); </span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">else</span> &#123; </span><br><span class="line">           <span class="keyword">throw</span> length_error(<span class="string">"length error"</span>); </span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (out_of_range e) &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"caught out_of_range exception"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125; </span><br><span class="line">   <span class="keyword">catch</span> (length_error e) &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"caught length_error exception"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>A function can transfer execution to a catch statement that exists in another function. This usually happens when a function (that throws an exception) is called from within a try block of another function. <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_args</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> runtime_error(<span class="string">"Please supply arguments"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; argc; i++) &#123; </span><br><span class="line">       <span class="built_in">cout</span> &lt;&lt; argv[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123; </span><br><span class="line">   <span class="keyword">try</span> &#123;       </span><br><span class="line">       display_args(argc, argv); </span><br><span class="line">       <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (runtime_error&amp; e) &#123; </span><br><span class="line">       <span class="built_in">cerr</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> EXIT_FAILURE; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>C++ provides a mechanism to catch exceptions of all possible types.<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (argc == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> runtime_error(<span class="string">"runtime error"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (argc == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> out_of_range(<span class="string">"out of range"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (argc == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> length_error(<span class="string">"length error"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"An exception was caught!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> EXIT_FAILURE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>note 5:<br />iterator an iterator is an object that allows us to iterate through all objects in a collection.<br /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">example：</span><br><span class="line">   for（int i&#x3D;0；i&lt;v.size();i++)</span><br><span class="line">     cout&lt;&lt;v[i]&lt;&lt;endl;</span><br><span class="line">&#96;&#96;&#96;   </span><br><span class="line">In this loop, i is an iterator. But we can store the collection only in an arraylik structure.   </span><br><span class="line">A flexible alternative：design an iterator class that encapsulates a position inside a collection   </span><br><span class="line">&#96;&#96;&#96;cpp</span><br><span class="line">#include “MyVector.h”</span><br><span class="line">#include “VectorIterator.h”</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  MyVector&lt;int&gt; v;</span><br><span class="line">  v.push_back(3);</span><br><span class="line">  v.push_back(2);</span><br><span class="line">  cout &lt;&lt; “Vector contents:” &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">  VectorIterator&lt;int&gt; itr &#x3D; v.getIterator();</span><br><span class="line">  while(itr.hasNext())</span><br><span class="line">     cout &lt;&lt; itr.next() &lt;&lt; endl;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line">template &lt;class Object&gt;</span><br><span class="line">Class VectorIterator；</span><br><span class="line">template MyVector:public vector&lt;object&gt;</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">   explicit MyVector(int size &#x3D; 0) :vector&lt;object&gt;(size) &#123;&#125;</span><br><span class="line">  VectorIterator&lt;object&gt; getIterator() const </span><br><span class="line">    &#123;return VectorIterator&lt;object&gt;(this);&#125;</span><br><span class="line">&#125;</span><br><span class="line">emplate &lt;class Object&gt;</span><br><span class="line">Class VectorIterator</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">   VectorIterator(const MyVector&lt;Object&gt;*v) :owner(v),count(0) &#123;&#125;</span><br><span class="line">   bool hasNext( ) const</span><br><span class="line">     &#123; return count !&#x3D; owner-&gt;size( ); &#125;</span><br><span class="line">   &#x2F;&#x2F;const不允许修改</span><br><span class="line">   const Object&amp; next( )</span><br><span class="line">     &#123; return (*owner)[count++];&#125;</span><br><span class="line">private:</span><br><span class="line">   const MyVector&lt;Object&gt; *owner;</span><br><span class="line">   int count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> Iterator Design 2 ：Inheritance-Based Iterators<br /><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Object</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Class</span> <span class="title">Iterator</span>;</span></span><br><span class="line">Template &lt;<span class="class"><span class="keyword">class</span> <span class="title">Object</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Class</span> <span class="title">VectorIterator</span>;</span></span><br><span class="line"></span><br><span class="line">Template &lt;<span class="class"><span class="keyword">class</span> <span class="title">Object</span>&gt;</span></span><br><span class="line"><span class="class"> <span class="title">Class</span> <span class="title">MyVector</span>:</span><span class="keyword">public</span> <span class="built_in">vector</span>&lt;Object&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyVector</span><span class="params">(intint size=<span class="number">0</span>)</span></span></span><br><span class="line">      :vector&lt;Object&gt;(size)&#123;&#125;</span><br><span class="line">    Iterator&lt;Object&gt; * getIterator() <span class="keyword">const</span></span><br><span class="line">      &#123;<span class="keyword">return</span> <span class="keyword">new</span> VectorIterator&lt;Object&gt;(<span class="keyword">this</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line">Template &lt;<span class="class"><span class="keyword">class</span> <span class="title">Object</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Class</span> <span class="title">Iterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">virtual</span>  ~Iterator() &#123; &#125;</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">( )</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> Object &amp; <span class="title">next</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line">Template &lt;<span class="class"><span class="keyword">class</span> <span class="title">Object</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">Class</span> <span class="title">VectorIterator</span>:</span><span class="keyword">public</span> Iterator&lt;Object&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   VectorIterator(<span class="keyword">const</span> MyVector&lt;object. * v)</span><br><span class="line">   :owner(v),count(<span class="number">0</span>) &#123; &#125;</span><br><span class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">( )</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">     </span>&#123;<span class="keyword">return</span> count != owner-&gt;size();&#125; </span><br><span class="line">   <span class="function"><span class="keyword">const</span> Object &amp; <span class="title">next</span><span class="params">()</span></span></span><br><span class="line"><span class="function">     </span>&#123;<span class="keyword">return</span> (*owner)[count++]; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">const</span> MyVector&lt;Object&gt; *owner;</span><br><span class="line">   <span class="keyword">int</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> http://www.thecrazyprogrammer.com/2014/11/c-cpp-program-for-priority-scheduling-algorithm.html</p><p>note 6:<br />note 7:<br />note 8:<br />note 9:<br />note 10:<br />note 11:<br />note 12:</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp notes </tag>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深拷贝和浅拷贝</title>
      <link href="/2016/09/03/shallow-copy-and-deep-copy/"/>
      <url>/2016/09/03/shallow-copy-and-deep-copy/</url>
      
        <content type="html"><![CDATA[<h1 id="深拷贝和浅拷贝">深拷贝和浅拷贝</h1><p><strong>shallow copy: copy the pointer;</strong><br /><strong>deep copy: copy the resource that the pointer pointing to;</strong></p><p>言简意赅，下面我们来看几个例子。<br />针对struct和class的例子：<br /><a id="more"></a> <img src="struct-shallow.png" align="middle"/> <img src="class-shallow.png" align="middle"/></p><p>从上面可以看出s和t的地址是相同的值，浅拷贝只是拷贝了指针的只也就是指针所指向的地址。这样析构的时候就会有问题，可能会导致重复析构（delete多次），引发异常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">string</span> *name;</span><br><span class="line"><span class="keyword">int</span> employeeNum;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setName</span><span class="params">(<span class="built_in">string</span>* name)</span> </span>&#123; <span class="keyword">this</span>-&gt;name = name; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setEmployeeNum</span><span class="params">(<span class="keyword">int</span> employeeNum)</span> </span>&#123; <span class="keyword">this</span>-&gt;employeeNum = employeeNum; &#125;</span><br><span class="line">Teacher() &#123;&#125;;</span><br><span class="line">Teacher(<span class="built_in">string</span>* name, <span class="keyword">int</span> employeeNum ) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;employeeNum = employeeNum;</span><br><span class="line">&#125;;</span><br><span class="line">Teacher(Teacher &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;name = <span class="keyword">new</span> <span class="built_in">string</span>(*(rhs.name));</span><br><span class="line"><span class="keyword">this</span>-&gt;employeeNum = rhs.employeeNum;</span><br><span class="line">&#125;</span><br><span class="line">Teacher&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Teacher &amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;name = <span class="keyword">new</span> <span class="built_in">string</span>(*(rhs.name));</span><br><span class="line"><span class="keyword">this</span>-&gt;employeeNum = rhs.employeeNum;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Teacher()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"destory "</span> &lt;&lt; *name &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> != name)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>-&gt;name;</span><br><span class="line">name = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//string name = "name";</span></span><br><span class="line"><span class="comment">//string name2 = "name2";</span></span><br><span class="line"><span class="built_in">string</span>* name = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"name"</span>);</span><br><span class="line"><span class="built_in">string</span>* name2 = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"name2"</span>);</span><br><span class="line">Teacher t,s;</span><br><span class="line">t.setName(name);</span><br><span class="line">t.setEmployeeNum(<span class="number">1</span>);</span><br><span class="line">s = t;</span><br><span class="line">s.setName(name2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>debug两次观察结果如下图： <img src="deep-copy1.png" align="middle"/> <img src="deep-copy2.png" align="middle"/></p><p>可以发现s和t的name属性的地址和值都是不同的。在此需要特别注意一下，如果类中的name属性的值是指针类型的，在用的时候也就是在main函数中也要将name和name2的类型设置成指针类型的，如果设置成string类型的话，就会导致分配的内存在栈上，不能delete，在main函数return的时候调用析构函数就会出错，因为你delete了一个在栈上分配的空间。</p><p><font color='purple'> 同时在此说明一下类的非静态成员变量是在栈上分配内存空间的，跟函数中的局部变量一样。</p><p>new/malloc中的东西都是存在于堆上的，常量或者全局的非常量在静态区分配内存。　　　</p><p>常量是写保护的修改不了，编译完之后静态区就固定了，静态区可以很大在编译时就固定了。　　　</p><p>new/malloc的东西是动态的，free还回来。　　　</p><p>所有栈的空间都不大。因此递归的程序都要找非递归的程序来代替。生命周期短，在函数运行结束后就删掉，不用程序员删。　　　 </font></p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> shallow copy and deep copy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>interview questions 20160902</title>
      <link href="/2016/09/02/interview-questions-20160902/"/>
      <url>/2016/09/02/interview-questions-20160902/</url>
      
        <content type="html"><![CDATA[<ol type="1"><li>分级页面，概率论，LRU，单链表数据结构及其接口，前1000大的整数及其时间复杂度分析。</li><li>两个大文件A，B，文件内容都不能直接读入内存，A，B中存的是一行一行的url，如何找出两个文件中同时存在的url?思路：字符串哈希分块。</li><li>进程和线程的区别?</li><li>进程间通讯的方式?</li><li>什么时候用vector，什么时候用list?vector和list的size的时间复杂度。</li><li>三次握手，四次分手</li><li>TCP，UDP的区别</li><li>10万个整数中找出排序后的前10个数(Top K)及其对应的复杂度。针对topK问题手写代码</li><li>堆排序的算法复杂度</li><li>TCP拥塞控制</li><li>什么是内存对齐</li><li>C++中内存分为几种类型?继承类的内存分配</li><li>B树及其应用场景</li><li>http和https的区别</li><li>Java中HashMap里面的映射?如何实现根据key的hashCode找到下标?HashMap做了哪些优化?</li><li>把你所知道的设计模式说出来</li><li>C语言的编译和链接过程</li><li>Java NIO是啥？</li><li>一个数组，有两个数是相同的，其他各个数是不同的，找出这个数，并且要求时间复杂度和空间复杂度都是O(n)。</li><li>如何判断二维坐标系中圆和三角形是否有重叠区域?</li><li>给一个二维数组，告诉你哪些坐标位置是不能行走的，计算从左上到右下有多少种走法?</li></ol>]]></content>
      
      
      <categories>
          
          <category> interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>周志华机器学习笔记</title>
      <link href="/2016/08/23/machine-learning-zhouzhihua-notes/"/>
      <url>/2016/08/23/machine-learning-zhouzhihua-notes/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章-绪论">第一章　绪论</h1><ol type="1"><li>本书用模型泛指从数据中学得的结果。有文献用模型指全局性结果，例如一棵决策树，而用模式指局部性结果。<br /></li><li>记录的集合称为dataset，每条记录是关于一个事件或者对象的描述，称为一个示例instance或样本，sample。反应事件或对象的某方面的表现或性质的事项，例如色泽，根蒂，敲声，称为属性，attribute，或特征feature。属性上的取值，称为属性值，属性张成的空间称为属性空间，样本空间或者输入空间。把每一个属性作为一个坐标轴，每个对象都可以在空间中找到自己的坐标位置，空间中的每个点对应一个坐标向量，因此我们也把一个示例称为一个特征向量feature vector。示例结果的信息称为标记，label,拥有了标记信息的示例称为样例，sample。所有标记的集合称为标记空间或输出空间。<br /></li><li>现实问题中，我们常面临很大的假设空间，但学习过程是基于有限样本训练集进行的，因此，有可能有多个假设与训练集一致，即存在着一个与训练集一致的假设集合，我们称之为版本空间。</li></ol><h1 id="第二章-模型评估与选择">第二章　模型评估与选择</h1><ol type="1"><li>我们只有一个包含m个样例的数据集<span class="math inline">\(D = {(x_1,y_1),(x_2,y_2),...,(x_m,y_m)}\)</span>，既要训练又要测试，怎样才能做到呢？答案是通过对D进行适当的处理，从中产生训练集S和测试集T。下面介绍常见的做法。</li></ol>]]></content>
      
      
      <categories>
          
          <category> machine learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> machine learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>numpy经典常用操作</title>
      <link href="/2016/06/27/numpy%E7%BB%8F%E5%85%B8%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
      <url>/2016/06/27/numpy%E7%BB%8F%E5%85%B8%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="numpy常用的操作">numpy常用的操作</h1><p>本文适合那些使用过numpy一段时间的人阅读，记录一些numpy中的常用知识点和使用技巧。</p><h2 id="note-1">1. note 1</h2><p>当某个轴的元素为-1时，将根据数组元素的个数自动计算此轴的长度。<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.shape</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.shape = <span class="number">3</span>,<span class="number">-1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">5</span>]])</span><br></pre></td></tr></table></figure></p><a id="more"></a><h2 id="note-2">2. note 2</h2><p>使用bool数组筛选数据。当使用布尔数组b作为下标存取数组x中的元素时，将收集数组x中所有在数组b中对应下标为True的元素。使用布尔数组作为下标获得的数组不和原始数组共享数据空间，注意这种方式只对应于布尔数组，不能使用布尔列表。<br /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = np.arange(<span class="number">5</span>,<span class="number">0</span>,<span class="number">-1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">array([<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[np.array([<span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>])]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 布尔数组中下标为0，2的元素为True，因此获取x中下标为0,2的元素</span></span><br><span class="line">array([<span class="number">5</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[[<span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 如果是布尔列表，则把True当作1, False当作0，按照整数序列方式获取x中的元素</span></span><br><span class="line">array([<span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[np.array([<span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">True</span>])]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 布尔数组的长度不够时，不够的部分都当作False</span></span><br><span class="line">array([<span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[np.array([<span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">True</span>])] = <span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 布尔数组下标也可以用来修改元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">array([<span class="number">-1</span>,  <span class="number">4</span>, <span class="number">-2</span>, <span class="number">-3</span>,  <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = np.random.rand(<span class="number">10</span>) <span class="comment"># 产生一个长度为10，元素值为0-1的随机数的数组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">array([ <span class="number">0.72223939</span>,  <span class="number">0.921226</span>  ,  <span class="number">0.7770805</span> ,  <span class="number">0.2055047</span> ,  <span class="number">0.17567449</span>,</span><br><span class="line">        <span class="number">0.95799412</span>,  <span class="number">0.12015178</span>,  <span class="number">0.7627083</span> ,  <span class="number">0.43260184</span>,  <span class="number">0.91379859</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x&gt;<span class="number">0.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 数组x中的每个元素和0.5进行大小比较，得到一个布尔数组，True表示x中对应的值大于0.5</span></span><br><span class="line">array([ <span class="literal">True</span>,  <span class="literal">True</span>,  <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>,  <span class="literal">True</span>, <span class="literal">False</span>,  <span class="literal">True</span>, <span class="literal">False</span>,  <span class="literal">True</span>], dtype=bool)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[x&gt;<span class="number">0.5</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 使用x&gt;0.5返回的布尔数组收集x中的元素，因此得到的结果是x中所有大于0.5的元素的数组</span></span><br><span class="line">array([ <span class="number">0.72223939</span>,  <span class="number">0.921226</span>  ,  <span class="number">0.7770805</span> ,  <span class="number">0.95799412</span>,  <span class="number">0.7627083</span> ,</span><br><span class="line">        <span class="number">0.91379859</span>])</span><br></pre></td></tr></table></figure></p><h2 id="note-3">3. note 3</h2><p>上面的功能也可以将一个矩阵中的大于等于1的数变成1,等于0的数还是0. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]])</span><br><span class="line">bool = a&gt;=<span class="number">1</span></span><br><span class="line"><span class="keyword">print</span> bool.astype(np.int)</span><br></pre></td></tr></table></figure></p><h2 id="参考资料">参考资料：</h2><p>http://old.sebug.net/paper/books/scipydoc/numpy_intro.html</p>]]></content>
      
      
      <categories>
          
          <category> machine learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> machine learning </tag>
            
            <tag> python </tag>
            
            <tag> numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>comprehensive hmm material</title>
      <link href="/2016/06/15/comprehensive-hmm-material/"/>
      <url>/2016/06/15/comprehensive-hmm-material/</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.comp.leeds.ac.uk/roger/HiddenMarkovModels/html_dev/main.html" target="_blank" rel="noopener">http://www.comp.leeds.ac.uk/roger/HiddenMarkovModels/html_dev/main.html</a></p>]]></content>
      
      
      <categories>
          
          <category> machine learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> machine learning </tag>
            
            <tag> hmm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cmake uninstall ubuntu</title>
      <link href="/2016/06/04/cmake-uninstall-ubuntu/"/>
      <url>/2016/06/04/cmake-uninstall-ubuntu/</url>
      
        <content type="html"><![CDATA[<h2 id="cmake-uninstall">CMake uninstall</h2><p>CMake is a great tool when building cross-plattform software. It offers also install target so you can build and install software this way:</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># create of-of-source build directory</span><br><span class="line">mkdir bld</span><br><span class="line">cd bld</span><br><span class="line"># run CMake to generate a Makefile</span><br><span class="line">ccmake ..</span><br><span class="line"># Build in 4 cores</span><br><span class="line">make -j 4</span><br><span class="line"># Install into CMAKE_INSTALL_PREFIX (default is &#x2F;usr&#x2F;local)</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>However there is no uninstall target. But this is no problem as long as you have a shell and the xargs command (part of GNU findutils).</p><p>CMake creates a file called install_manifest.txt when executing the install target. This contains a list of all installed files. So for removing them you simply need to execute this command:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># uninstall</span><br><span class="line">xargs rm &lt; install_manifest.txt</span><br></pre></td></tr></table></figure><p>该方法同样适用于其他从源码编译安装的软件，比如llvm等。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cmake-uninstall </tag>
            
            <tag> ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu配置spark环境和spark-wordcount以及spark常用的actions和transactions</title>
      <link href="/2016/05/11/Ubuntu%E9%85%8D%E7%BD%AEspark%E7%8E%AF%E5%A2%83%E5%92%8Cspark-wordcount%E4%BB%A5%E5%8F%8Aspark%E5%B8%B8%E7%94%A8%E7%9A%84actions%E5%92%8Ctransactions/"/>
      <url>/2016/05/11/Ubuntu%E9%85%8D%E7%BD%AEspark%E7%8E%AF%E5%A2%83%E5%92%8Cspark-wordcount%E4%BB%A5%E5%8F%8Aspark%E5%B8%B8%E7%94%A8%E7%9A%84actions%E5%92%8Ctransactions/</url>
      
        <content type="html"><![CDATA[<h2 id="spark开发环境配置">1. spark开发环境配置</h2><h3 id="下载所需文件">1.1 下载所需文件</h3><p>下载spark-1.5.1-bin-hadoop2.6.tgz，支持hadoop2.6.0 or later,故可支持hadoop2.7.1。下载scala-2.11.7。如果不使用scala语言，就不用下载scala语言的编译器和解释环境。</p><a id="more"></a><h3 id="配置环境变量">1.2 配置环境变量</h3><p>我配在/etc/profile文件中了 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;home&#x2F;yanruibo&#x2F;software&#x2F;jdk&#x2F;jdk1.7.0_80</span><br><span class="line">export JRE_HOME&#x3D;$&#123;JAVA_HOME&#125;&#x2F;jre</span><br><span class="line">export CLASSPATH&#x3D;.:$&#123;JAVA_HOME&#125;&#x2F;lib:$&#123;JRE_HOME&#125;&#x2F;lib</span><br><span class="line">export JAVA_PATH&#x3D;$&#123;JAVA_HOME&#125;&#x2F;bin</span><br><span class="line"></span><br><span class="line">export HADOOP_HOME&#x3D;&#x2F;home&#x2F;yanruibo&#x2F;software&#x2F;hadoop-2.7.1</span><br><span class="line">export HADOOP_PATH&#x3D;$&#123;HADOOP_HOME&#125;&#x2F;bin:$&#123;HADOOP_HOME&#125;&#x2F;sbin</span><br><span class="line"></span><br><span class="line">export M2_HOME&#x3D;&#x2F;home&#x2F;yanruibo&#x2F;software&#x2F;apache-maven-3.3.3</span><br><span class="line">export M2&#x3D;$&#123;M2_HOME&#125;&#x2F;bin</span><br><span class="line"></span><br><span class="line">export SCALA_HOME&#x3D;&#x2F;home&#x2F;yanruibo&#x2F;software&#x2F;scala-2.11.7</span><br><span class="line">export SCALA_PATH&#x3D;$&#123;SCALA_HOME&#125;&#x2F;bin</span><br><span class="line"></span><br><span class="line">export SPARK_HOME&#x3D;&#x2F;home&#x2F;yanruibo&#x2F;software&#x2F;spark-1.5.1-bin-without-hadoop</span><br><span class="line">export SPARK_PATH&#x3D;$&#123;SPARK_HOME&#125;&#x2F;bin</span><br><span class="line">export PATH&#x3D;$PATH:$&#123;JAVA_PATH&#125;:$&#123;HADOOP_PATH&#125;:$&#123;M2&#125;:$&#123;SCALA_PATH&#125;:$&#123;SPARK_PATH&#125;</span><br></pre></td></tr></table></figure> scala直接解压就行了不需要修改，spark需要在spark_home下的conf文件夹下配置一下spark-env.sh <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp spark-env.sh.template spark-env.sh</span><br></pre></td></tr></table></figure> 在spark-env.sh中添加如下的内容。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">export SCALA_HOME&#x3D;&#x2F;home&#x2F;yanruibo&#x2F;software&#x2F;scala-2.11.7</span><br><span class="line">export JAVA_HOME&#x3D;&#x2F;home&#x2F;yanruibo&#x2F;software&#x2F;jdk&#x2F;jdk1.7.0_80</span><br><span class="line">export HADOOP_HOME&#x3D;&#x2F;home&#x2F;yanruibo&#x2F;software&#x2F;hadoop-2.7.1</span><br><span class="line">export HADOOP_CONF_DIR&#x3D;$HADOOP_HOME&#x2F;etc&#x2F;hadoop</span><br><span class="line">SPARK_MASTER_IP&#x3D;localhost</span><br><span class="line">SPARK_LOCAL_DIRS&#x3D;&#x2F;home&#x2F;yanruibo&#x2F;software&#x2F;spark-1.5.1-bin-hadoop2.6</span><br><span class="line">SPARK_DRIVER_MEMORY&#x3D;512M</span><br></pre></td></tr></table></figure> 这样spark的开发环境就配好了。在命令行输入pyspark，spark-shell都可以进入。 为什么配置本地环境呢？主要是可以在本机调试，调试好了再上传服务器，在服务器上执行。 注意：一定要下载正确spark的版本，刚一开始下载的spark-1.5.1-bin-without-hadoop.tgz，配置不成功，理解错意思了，以为without-hadoop是不自带hadoop的意思。网上一搜看别人都下载的spark-x.y.z-bin-hadoop.tgz于是就换了一个。</p><h2 id="实验过程">2. 实验过程</h2><h3 id="使用pyspark">2.1 使用pyspark</h3><h4 id="向pyspark传递函数实现wordcount">2.1.1 向pyspark传递函数实现wordcount</h4><p>首先我自己写了一个函数，对每个单词进行过滤操作，过滤掉每个单词首尾的特殊字符，把首尾的非字母的子字符串都去掉，但是单词中间的标点符号不去掉，像<code>"''won't:</code>这样的单词经过过滤之后变为<code>won't</code>。代码如下： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">去掉执行map函数时每个word中首尾的非字母的特殊字符，并将不为空的置为１，</span></span><br><span class="line"><span class="string">为空的置为('', 0)</span></span><br><span class="line"><span class="string">因为spark接口必须要求返回一个数据，所以就返回('', 0)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map_filter</span><span class="params">(s)</span>:</span></span><br><span class="line">    <span class="comment">#定义正则表达式匹配以非字母开头的字符串</span></span><br><span class="line">    p = re.compile(<span class="string">'(?i)^[^a-zA-Z]+'</span>)</span><br><span class="line">    m = p.match(s)</span><br><span class="line">    end = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span>(m):</span><br><span class="line">        <span class="comment">#如果匹配上，获得匹配位置的最后一个字符位置</span></span><br><span class="line">        end = m.end()</span><br><span class="line">    s = s[end:]</span><br><span class="line">    <span class="comment">#字符串反转</span></span><br><span class="line">    s = s[::<span class="number">-1</span>]</span><br><span class="line">    <span class="comment">#去掉末尾的特殊字符</span></span><br><span class="line">    m = p.match(s)</span><br><span class="line">    end = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span>(m):</span><br><span class="line">        end = m.end()</span><br><span class="line">    s = s[end:]</span><br><span class="line">    <span class="comment">#最后再反转回来</span></span><br><span class="line">    s = s[::<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">if</span>(len(s) == <span class="number">0</span>):</span><br><span class="line"><span class="comment">#如果字符串为空返回('', 0)</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="string">''</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> (s, <span class="number">1</span>)</span><br></pre></td></tr></table></figure> 这段函数的思路与第一次作业的思路相同，这里就不赘述了。将该函数保存在mapfilter.py中，然后将mapfilter.py放在服务器的主目录下（为什么放在主目录下是因为指定下面的--py-files比较简便，其实放在哪儿都可以，只要知道指定的路径就行），执行如下的命令： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyspark --master yarn-client --num-executors 4 --conf spark.ui.port&#x3D;8015 --py-files mapfilter.py</span><br></pre></td></tr></table></figure> 然后就能调用自己写的函数了。以下是实现的过程 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>textFile = sc.textFile(<span class="string">"/tmp/bigdata/2015/english_novel/*"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wordsrdd = textFile.flatMap(<span class="keyword">lambda</span> s : s.split()) <span class="comment">#Transformation</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> mapfilter</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>maprdd = wordsrdd.map(mapfilter.map_filter) <span class="comment">#Transformation</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> add</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reducerdd =  maprdd.reduceByKey(add)<span class="comment">#Transformation</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reducerdd.repartition(<span class="number">20</span>)<span class="comment">#Transformation</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reducerdd.saveAsTextFile(<span class="string">'hdfs:/user/2015210978/hw2-output2'</span>) <span class="comment">#Action</span></span><br></pre></td></tr></table></figure></p><h4 id="用其他rdd函数实现wordcount">2.1.2 用其他RDD函数实现wordcount</h4><p>在服务器上练习执行命令： pyspark --master yarn-client --num-executors 4 --conf spark.ui.port=8015 --py-files mapfilter.py <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#以下是练习的内容 也通过另外的一些函数实现了wordcount</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>textFile = sc.textFile(<span class="string">"/tmp/bigdata/2015/english_novel/*"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>textFile.repartition(<span class="number">20</span>)　<span class="comment">#Transformation 1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wordsrdd = textFile.flatMap(<span class="keyword">lambda</span> s : s.split())</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> mapfilter</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>maprdd = wordsrdd.map(mapfilter.map_filter)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment">#通过以下的方法也是能统计出词频的</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>maprdd.repartition(<span class="number">50</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>countdict = maprdd.countByKey()　<span class="comment">#Action 1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> item <span class="keyword">in</span> countdict:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> <span class="string">"%s:%d"</span>%(item,countdict[item])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp =open(<span class="string">"countdict.txt"</span>,<span class="string">'w'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> item <span class="keyword">in</span> countdict:</span><br><span class="line"><span class="meta">... </span>    fp.write(item+<span class="string">' '</span>+str(countdict[item])+<span class="string">"\n"</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp.close()</span><br></pre></td></tr></table></figure> 主要用到了countByKey()这个函数，这个函数返回python的dict然后自己按规定的格式写入文件中。这时写入文件的内容是无序的，可以用linux的<code>cat countdict.txt | sort -t' ' -k 1,1df &gt; sorted_result.txt</code>命令进行不区分大小写排序。<strong>注意这里是将结果保存在本地文件中了,如果需要将文件保存在hdfs中还需要调用saveAsTextFile函数</strong>，除了利用linux的sort命令达到最后不去分大小写的效果，还可以利用下面的python语言的不区分大小写排序的策略进行排序。</p><p>下面利用python对字典按key不区分大小写排序，用元组列表的形式返回，遇到了服务器上python编码的问题，修改成utf-8编码，就能正常写入文件了 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#不区分大小写排序返回一个元组的列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>listcount = sorted(countdict.items(),key=<span class="keyword">lambda</span> countdict:countdict[<span class="number">0</span>].lower())</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp = open(<span class="string">"sorted_result.txt"</span>,<span class="string">'w'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> item <span class="keyword">in</span> listcount:</span><br><span class="line"><span class="meta">... </span>    fp.write(item[<span class="number">0</span>]+<span class="string">' '</span>+str(item[<span class="number">1</span>])+<span class="string">'\n'</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">UnicodeEncodeError: <span class="string">'ascii'</span> codec can<span class="string">'t encode character u'</span>\ufffd<span class="string">' in position 3: ordinal not in range(128)</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; import sys</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; reload(sys)</span></span><br><span class="line"><span class="string">&lt;module '</span>sys<span class="string">' (built-in)&gt;</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; sys.setdefaultencoding('</span>utf<span class="number">-8</span><span class="string">')</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; for item in listcount:</span></span><br><span class="line"><span class="string">...     fp.write(item[0]+'</span> <span class="string">'+str(item[1])+'</span>\n<span class="string">')</span></span><br><span class="line"><span class="string">... </span></span><br><span class="line"><span class="string">&gt;&gt;&gt; fp.close()</span></span><br></pre></td></tr></table></figure> 这样保存的sorted_result.txt就是不区分大小写排好序的了。同样也是保存在本地文件中了。</p><h4 id="练习使用pyspark交互式分析">2.1.3 练习使用pyspark交互式分析</h4><p>要求:transformation和action函数每种至少五个<br />本地执行命令：pyspark --num-executors 1 --py-files mapfilter.py<br />以下是针对rdd进行练习拿testrdd.txt这个文件进行练习，其内容为： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a b c d e f g h i g k l m n</span><br><span class="line">ab ac d e ff gf ha heihei Ab AB ac A</span><br><span class="line">I am You are he is she is that</span><br></pre></td></tr></table></figure> 数据量少的话便于查看结果<br /><strong>下面是Transformations练习:</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>textFile = sc.textFile(<span class="string">"hdfs:/usr/yanruibo/testrdd.txt"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>textFile.collect()</span><br><span class="line">[<span class="string">u'a b c d e f g h i g k l m n'</span>, <span class="string">u'ab ac d e ff gf ha heihei Ab AB ac A'</span>, <span class="string">u'I am You are he is she is that'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wordsrdd = textFile.flatMap(<span class="keyword">lambda</span> s : s.split())</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wordsrdd.collect()</span><br><span class="line">[<span class="string">u'a'</span>, <span class="string">u'b'</span>, <span class="string">u'c'</span>, <span class="string">u'd'</span>, <span class="string">u'e'</span>, <span class="string">u'f'</span>, <span class="string">u'g'</span>, <span class="string">u'h'</span>, <span class="string">u'i'</span>, <span class="string">u'g'</span>, <span class="string">u'k'</span>, <span class="string">u'l'</span>, <span class="string">u'm'</span>, <span class="string">u'n'</span>, <span class="string">u'ab'</span>, <span class="string">u'ac'</span>, <span class="string">u'd'</span>, <span class="string">u'e'</span>, <span class="string">u'ff'</span>, <span class="string">u'gf'</span>, <span class="string">u'ha'</span>, <span class="string">u'heihei'</span>, <span class="string">u'Ab'</span>, <span class="string">u'AB'</span>, <span class="string">u'ac'</span>, <span class="string">u'A'</span>, <span class="string">u'I'</span>, <span class="string">u'am'</span>, <span class="string">u'You'</span>, <span class="string">u'are'</span>, <span class="string">u'he'</span>, <span class="string">u'is'</span>, <span class="string">u'she'</span>, <span class="string">u'is'</span>, <span class="string">u'that'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>maprdd = wordsrdd.map(<span class="keyword">lambda</span> s : (s,<span class="number">1</span>))</span><br><span class="line">[(<span class="string">u'a'</span>, <span class="number">1</span>), (<span class="string">u'b'</span>, <span class="number">1</span>), (<span class="string">u'c'</span>, <span class="number">1</span>), (<span class="string">u'd'</span>, <span class="number">1</span>), (<span class="string">u'e'</span>, <span class="number">1</span>), (<span class="string">u'f'</span>, <span class="number">1</span>), (<span class="string">u'g'</span>, <span class="number">1</span>), (<span class="string">u'h'</span>, <span class="number">1</span>), (<span class="string">u'i'</span>, <span class="number">1</span>), (<span class="string">u'g'</span>, <span class="number">1</span>), (<span class="string">u'k'</span>, <span class="number">1</span>), (<span class="string">u'l'</span>, <span class="number">1</span>), (<span class="string">u'm'</span>, <span class="number">1</span>), (<span class="string">u'n'</span>, <span class="number">1</span>), (<span class="string">u'ab'</span>, <span class="number">1</span>), (<span class="string">u'ac'</span>, <span class="number">1</span>), (<span class="string">u'd'</span>, <span class="number">1</span>), (<span class="string">u'e'</span>, <span class="number">1</span>), (<span class="string">u'ff'</span>, <span class="number">1</span>), (<span class="string">u'gf'</span>, <span class="number">1</span>), (<span class="string">u'ha'</span>, <span class="number">1</span>), (<span class="string">u'heihei'</span>, <span class="number">1</span>), (<span class="string">u'Ab'</span>, <span class="number">1</span>), (<span class="string">u'AB'</span>, <span class="number">1</span>), (<span class="string">u'ac'</span>, <span class="number">1</span>), (<span class="string">u'A'</span>, <span class="number">1</span>), (<span class="string">u'I'</span>, <span class="number">1</span>), (<span class="string">u'am'</span>, <span class="number">1</span>), (<span class="string">u'You'</span>, <span class="number">1</span>), (<span class="string">u'are'</span>, <span class="number">1</span>), (<span class="string">u'he'</span>, <span class="number">1</span>), (<span class="string">u'is'</span>, <span class="number">1</span>), (<span class="string">u'she'</span>, <span class="number">1</span>), (<span class="string">u'is'</span>, <span class="number">1</span>), (<span class="string">u'that'</span>, <span class="number">1</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>maprdd.repartition(<span class="number">1</span>) <span class="comment">#Transformation 1</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">之前partition为２</span></span><br><span class="line"><span class="string">repartition(numPartitions):Reshuffle the data in the RDD randomly to create either more or fewer partitions and balance it across them. This always shuffles all data over the network.很容易懂，就不翻译了。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> add</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reducerdd =  maprdd.reduceByKey(add)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reducerdd.collect()</span><br><span class="line">[(<span class="string">u'A'</span>, <span class="number">1</span>), (<span class="string">u'a'</span>, <span class="number">1</span>), (<span class="string">u'ac'</span>, <span class="number">2</span>), (<span class="string">u'e'</span>, <span class="number">2</span>), (<span class="string">u'heihei'</span>, <span class="number">1</span>), (<span class="string">u'g'</span>, <span class="number">2</span>), (<span class="string">u'i'</span>, <span class="number">1</span>), (<span class="string">u'am'</span>, <span class="number">1</span>), (<span class="string">u'k'</span>, <span class="number">1</span>), (<span class="string">u'm'</span>, <span class="number">1</span>), (<span class="string">u'c'</span>, <span class="number">1</span>), (<span class="string">u'I'</span>, <span class="number">1</span>), (<span class="string">u'ff'</span>, <span class="number">1</span>), (<span class="string">u'You'</span>, <span class="number">1</span>), (<span class="string">u'is'</span>, <span class="number">2</span>), (<span class="string">u'are'</span>, <span class="number">1</span>), (<span class="string">u'he'</span>, <span class="number">1</span>), (<span class="string">u'ab'</span>, <span class="number">1</span>), (<span class="string">u'd'</span>, <span class="number">2</span>), (<span class="string">u'f'</span>, <span class="number">1</span>), (<span class="string">u'h'</span>, <span class="number">1</span>), (<span class="string">u'that'</span>, <span class="number">1</span>), (<span class="string">u'l'</span>, <span class="number">1</span>), (<span class="string">u'n'</span>, <span class="number">1</span>), (<span class="string">u'gf'</span>, <span class="number">1</span>), (<span class="string">u'b'</span>, <span class="number">1</span>), (<span class="string">u'she'</span>, <span class="number">1</span>), (<span class="string">u'ha'</span>, <span class="number">1</span>), (<span class="string">u'AB'</span>, <span class="number">1</span>), (<span class="string">u'Ab'</span>, <span class="number">1</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>filterrdd = reducerdd.filter(<span class="keyword">lambda</span> (k,v): k == <span class="string">'Ab'</span>) <span class="comment">#Transformation 2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>filterrdd.collect()</span><br><span class="line">[(<span class="string">u'Ab'</span>, <span class="number">1</span>)]</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">过滤出key为'Ab'的词组</span></span><br><span class="line"><span class="string">filter(func)：Return a new dataset formed by selecting those elements of the source on which func returns true.</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sortedrdd = reducerdd.sortByKey() <span class="comment">#Transformation 3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sortedrdd.collect()</span><br><span class="line">[(<span class="string">u'A'</span>, <span class="number">1</span>), (<span class="string">u'AB'</span>, <span class="number">1</span>), (<span class="string">u'Ab'</span>, <span class="number">1</span>), (<span class="string">u'I'</span>, <span class="number">1</span>), (<span class="string">u'You'</span>, <span class="number">1</span>), (<span class="string">u'a'</span>, <span class="number">1</span>), (<span class="string">u'ab'</span>, <span class="number">1</span>), (<span class="string">u'ac'</span>, <span class="number">2</span>), (<span class="string">u'am'</span>, <span class="number">1</span>), (<span class="string">u'are'</span>, <span class="number">1</span>), (<span class="string">u'b'</span>, <span class="number">1</span>), (<span class="string">u'c'</span>, <span class="number">1</span>), (<span class="string">u'd'</span>, <span class="number">2</span>), (<span class="string">u'e'</span>, <span class="number">2</span>), (<span class="string">u'f'</span>, <span class="number">1</span>), (<span class="string">u'ff'</span>, <span class="number">1</span>), (<span class="string">u'g'</span>, <span class="number">2</span>), (<span class="string">u'gf'</span>, <span class="number">1</span>), (<span class="string">u'h'</span>, <span class="number">1</span>), (<span class="string">u'ha'</span>, <span class="number">1</span>), (<span class="string">u'he'</span>, <span class="number">1</span>), (<span class="string">u'heihei'</span>, <span class="number">1</span>), (<span class="string">u'i'</span>, <span class="number">1</span>), (<span class="string">u'is'</span>, <span class="number">2</span>), (<span class="string">u'k'</span>, <span class="number">1</span>), (<span class="string">u'l'</span>, <span class="number">1</span>), (<span class="string">u'm'</span>, <span class="number">1</span>), (<span class="string">u'n'</span>, <span class="number">1</span>), (<span class="string">u'she'</span>, <span class="number">1</span>), (<span class="string">u'that'</span>, <span class="number">1</span>)]</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">按key进行排序，先排大写字母再排小写字母</span></span><br><span class="line"><span class="string">sortByKey([ascending], [numTasks])：When called on a dataset of (K, V) pairs where K implements Ordered, returns a dataset of (K, V) pairs sorted by keys in ascending or descending order, as specified in the boolean ascending argument.</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>grouprdd = maprdd.groupByKey() <span class="comment">#Transformation 4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>grouprdd.collect()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">groupByKey([numTasks]) 在一个（K,V）对的数据集上调用，返回一个（K，Seq[V])对的数据集</span></span><br><span class="line"><span class="string">注意：默认情况下，只有8个并行任务来做操作，但是你可以传入一个可选的numTasks参数来改变它</span></span><br><span class="line"><span class="string">结果有点抽象没有粘贴。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wordsrdd.distinct().collect()　<span class="comment">#Transformation 5</span></span><br><span class="line">[<span class="string">u'A'</span>, <span class="string">u'a'</span>, <span class="string">u'ac'</span>, <span class="string">u'e'</span>, <span class="string">u'heihei'</span>, <span class="string">u'g'</span>, <span class="string">u'i'</span>, <span class="string">u'am'</span>, <span class="string">u'k'</span>, <span class="string">u'm'</span>, <span class="string">u'c'</span>, <span class="string">u'I'</span>, <span class="string">u'ff'</span>, <span class="string">u'You'</span>, <span class="string">u'is'</span>, <span class="string">u'are'</span>, <span class="string">u'he'</span>, <span class="string">u'ab'</span>, <span class="string">u'd'</span>, <span class="string">u'f'</span>, <span class="string">u'h'</span>, <span class="string">u'that'</span>, <span class="string">u'l'</span>, <span class="string">u'n'</span>, <span class="string">u'gf'</span>, <span class="string">u'b'</span>, <span class="string">u'she'</span>, <span class="string">u'ha'</span>, <span class="string">u'AB'</span>, <span class="string">u'Ab'</span>]</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">这里为了方便就不另外声明一个rdd变量了，相当于唯一化操作</span></span><br><span class="line"><span class="string">distinct([numTasks]))：Return a new dataset that contains the distinct elements of the source dataset.</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wordsrdd.sample(<span class="literal">False</span>,<span class="number">0.1</span>,<span class="number">2</span>).collect() <span class="comment">#Transformation 6</span></span><br><span class="line">[<span class="string">u'k'</span>, <span class="string">u'l'</span>, <span class="string">u'gf'</span>]</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">根据随机数种子２按0.1的比例不替换不足部分取样本</span></span><br><span class="line"><span class="string">sample(withReplacement,fraction, seed):根据fraction指定的比例，对数据进行采样，可以选择是否用随机数进行替换，seed用于指定随机数生成器种子</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wordsrdd.union(wordsrdd).collect()　<span class="comment">#Transformation 7</span></span><br><span class="line">[(<span class="string">u'A'</span>, <span class="number">1</span>), (<span class="string">u'a'</span>, <span class="number">1</span>), (<span class="string">u'ac'</span>, <span class="number">2</span>), (<span class="string">u'e'</span>, <span class="number">2</span>), (<span class="string">u'heihei'</span>, <span class="number">1</span>), (<span class="string">u'g'</span>, <span class="number">2</span>), (<span class="string">u'i'</span>, <span class="number">1</span>), (<span class="string">u'am'</span>, <span class="number">1</span>), (<span class="string">u'k'</span>, <span class="number">1</span>), (<span class="string">u'm'</span>, <span class="number">1</span>), (<span class="string">u'c'</span>, <span class="number">1</span>), (<span class="string">u'I'</span>, <span class="number">1</span>), (<span class="string">u'ff'</span>, <span class="number">1</span>), (<span class="string">u'You'</span>, <span class="number">1</span>), (<span class="string">u'is'</span>, <span class="number">2</span>), (<span class="string">u'are'</span>, <span class="number">1</span>), (<span class="string">u'he'</span>, <span class="number">1</span>), (<span class="string">u'ab'</span>, <span class="number">1</span>), (<span class="string">u'd'</span>, <span class="number">2</span>), (<span class="string">u'f'</span>, <span class="number">1</span>), (<span class="string">u'h'</span>, <span class="number">1</span>), (<span class="string">u'that'</span>, <span class="number">1</span>), (<span class="string">u'l'</span>, <span class="number">1</span>), (<span class="string">u'n'</span>, <span class="number">1</span>), (<span class="string">u'gf'</span>, <span class="number">1</span>), (<span class="string">u'b'</span>, <span class="number">1</span>), (<span class="string">u'she'</span>, <span class="number">1</span>), (<span class="string">u'ha'</span>, <span class="number">1</span>), (<span class="string">u'AB'</span>, <span class="number">1</span>), (<span class="string">u'Ab'</span>, <span class="number">1</span>), <span class="string">u'a'</span>, <span class="string">u'b'</span>, <span class="string">u'c'</span>, <span class="string">u'd'</span>, <span class="string">u'e'</span>, <span class="string">u'f'</span>, <span class="string">u'g'</span>, <span class="string">u'h'</span>, <span class="string">u'i'</span>, <span class="string">u'g'</span>, <span class="string">u'k'</span>, <span class="string">u'l'</span>, <span class="string">u'm'</span>, <span class="string">u'n'</span>, <span class="string">u'ab'</span>, <span class="string">u'ac'</span>, <span class="string">u'd'</span>, <span class="string">u'e'</span>, <span class="string">u'ff'</span>, <span class="string">u'gf'</span>, <span class="string">u'ha'</span>, <span class="string">u'heihei'</span>, <span class="string">u'Ab'</span>, <span class="string">u'AB'</span>, <span class="string">u'ac'</span>, <span class="string">u'A'</span>, <span class="string">u'I'</span>, <span class="string">u'am'</span>, <span class="string">u'You'</span>, <span class="string">u'are'</span>, <span class="string">u'he'</span>, <span class="string">u'is'</span>, <span class="string">u'she'</span>, <span class="string">u'is'</span>, <span class="string">u'that'</span>]</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">union(otherDataset):返回一个新的数据集，新数据集是由源数据集和参数数据集联合而成简单说就是求集合交集。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reducerdd.intersection(wordsrdd).collect() <span class="comment">#Transformation 8</span></span><br><span class="line">[]</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">求交集交集为空</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure> 以上标序号的都是在实验指导书中没有出现的Transforamtion。为了看在实验指导书中是否有该操作，我还特地在实验指导书中搜索了一下，确认没有才进行标号的。同理下面的Actions也是。<br /><strong>下面是Actions练习:</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>maprdd.countByKey()　<span class="comment">#Action 1</span></span><br><span class="line">defaultdict(&lt;type <span class="string">'int'</span>&gt;, &#123;<span class="string">u'ac'</span>: <span class="number">2</span>, <span class="string">u'ab'</span>: <span class="number">1</span>, <span class="string">u'is'</span>: <span class="number">2</span>, <span class="string">u'am'</span>: <span class="number">1</span>, <span class="string">u'gf'</span>: <span class="number">1</span>, <span class="string">u'are'</span>: <span class="number">1</span>, <span class="string">u'heihei'</span>: <span class="number">1</span>, <span class="string">u'You'</span>: <span class="number">1</span>, <span class="string">u'A'</span>: <span class="number">1</span>, <span class="string">u'AB'</span>: <span class="number">1</span>, <span class="string">u'that'</span>: <span class="number">1</span>, <span class="string">u'I'</span>: <span class="number">1</span>, <span class="string">u'Ab'</span>: <span class="number">1</span>, <span class="string">u'ff'</span>: <span class="number">1</span>, <span class="string">u'ha'</span>: <span class="number">1</span>, <span class="string">u'he'</span>: <span class="number">1</span>, <span class="string">u'a'</span>: <span class="number">1</span>, <span class="string">u'c'</span>: <span class="number">1</span>, <span class="string">u'b'</span>: <span class="number">1</span>, <span class="string">u'e'</span>: <span class="number">2</span>, <span class="string">u'd'</span>: <span class="number">2</span>, <span class="string">u'g'</span>: <span class="number">2</span>, <span class="string">u'f'</span>: <span class="number">1</span>, <span class="string">u'i'</span>: <span class="number">1</span>, <span class="string">u'h'</span>: <span class="number">1</span>, <span class="string">u'k'</span>: <span class="number">1</span>, <span class="string">u'm'</span>: <span class="number">1</span>, <span class="string">u'l'</span>: <span class="number">1</span>, <span class="string">u'n'</span>: <span class="number">1</span>, <span class="string">u'she'</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">返回每个key出现的次数</span></span><br><span class="line"><span class="string">countByKey()：Only available on RDDs of type (K, V). Returns a hashmap of (K, Int) pairs with the count of each key.</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wordsrdd.count()</span><br><span class="line"><span class="number">35</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wordsrdd.distinct().count()</span><br><span class="line"><span class="number">30</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wordsrdd.first()</span><br><span class="line"><span class="string">u'a'</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">取第一个相当于take(1)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wordsrdd.take(<span class="number">10</span>) <span class="comment">#Action 2</span></span><br><span class="line">[<span class="string">u'a'</span>, <span class="string">u'b'</span>, <span class="string">u'c'</span>, <span class="string">u'd'</span>, <span class="string">u'e'</span>, <span class="string">u'f'</span>, <span class="string">u'g'</span>, <span class="string">u'h'</span>, <span class="string">u'i'</span>, <span class="string">u'g'</span>]</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">取前十个</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wordsdd.takeSample(<span class="literal">False</span>,<span class="number">2</span>,<span class="number">3</span>)　<span class="comment">#Action 3</span></span><br><span class="line">[<span class="string">u'n'</span>, <span class="string">u'd'</span>]</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">以随机种子3不替换不足部分随机采样２个。</span></span><br><span class="line"><span class="string">takeSample(withReplacement,num, seed):返回一个数组，在数据集中随机采样num个元素组成，可以选择是否用随机数替换不足的部分，Seed用于指定的随机数生成器种子</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wordsrdd.takeOrdered(<span class="number">10</span>) <span class="comment">#Action 4</span></span><br><span class="line">[<span class="string">u'A'</span>, <span class="string">u'AB'</span>, <span class="string">u'Ab'</span>, <span class="string">u'I'</span>, <span class="string">u'You'</span>, <span class="string">u'a'</span>, <span class="string">u'ab'</span>, <span class="string">u'ac'</span>, <span class="string">u'ac'</span>, <span class="string">u'am'</span>]</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">相当于排好序再take</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>accum = sc.accumulator(<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sc.parallelize([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).foreach(<span class="keyword">lambda</span> x: accum.add(x))<span class="comment">#Action5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>accum.value</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">foreach:一般与accumulator使用</span></span><br><span class="line"><span class="string">foreach(func):Run a function func on each element of the dataset. This is usually done for side effects such as updating an Accumulator or interacting with external storage systems.</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wordsrdd.saveAsSequenceFile(<span class="string">'test1.txt'</span>)<span class="comment"># Action 6 eror can't use</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wordsrdd.saveAsObjectFile(<span class="string">'test1.txt'</span>)<span class="comment"># Action 7　eror can't use</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">saveAsSequenceFile(path):将数据集的元素，以Hadoop sequencefile的格式，保存到指定的目录下，本地系统，HDFS或者任何其它hadoop支持的文件系统。这个只限于由key-value对组成，并实现了Hadoop的Writable接口，或者隐式的可以转换为Writable的RDD。（Spark包括了基本类型的转换，例如Int，Double，String，等等）</span></span><br><span class="line"><span class="string">saveAsObjectFile(path):(Java and Scala)Write the elements of the dataset in a simple format using Java serialization, which can then be loaded usingSparkContext.objectFile().</span></span><br><span class="line"><span class="string">以上两个保存rdd的action在pyspark中不能用，必须得用java或者scala才能用，再一次体现了python语言开发spark程序的限制。spark guide中action的数目还是比较少的，去除在实验指导书上出现的剩下的也就七八个了，还有两个函数saveAsObjectFile,saveAsSequenceFile我测试的是保存wordsrdd时不能用。第一个函数报错：RDD element of type java.lang.String cannot be used，第二个函数报错：AttributeError: 'PipelinedRDD' object has no attribute 'saveAsObjectFile'。但是用reducerdd就能调用saveAsSequenceFile保存，不能调用saveAsObjectFile保存。这个原因和rdd的类型有关。</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure> 以上命令都在本地测试执行过，结果也粘贴出来了。<br />常见的一些Transformation和Action见<a href="http://colobu.com/2014/12/08/spark-programming-guide/" target="_blank" rel="noopener">http://colobu.com/2014/12/08/spark-programming-guide/</a>讲的很详细。 通过上面的命令练习了常用的Transformation和Action。可以在saveAsTextFile函数之前调用repartition加快保存速度。</p><p><strong>使用其他函数实现wordcount思路总结:</strong></p><p>如果自己实现wordcount的功能的话，还可以在map函数之后使用countByKey()这个函数，这个函数的返回值是collections.defaultdict，是python的一个类型，不能调用saveAsTextFile，但可以自己写for循环遍历，并写入本地文件中，在pyspark中是可以使用python的所有特性的。</p><h3 id="编写spark-application">2.2 编写spark application</h3><p><strong>(1) python版本：</strong> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    sc = SparkContext(appName=<span class="string">"PythonWordCount"</span>)</span><br><span class="line">    <span class="comment">#加载数据　并指明partition为1</span></span><br><span class="line">    lines = sc.textFile(<span class="string">"hdfs:/tmp/bigdata/2015/english_novel/*"</span>, <span class="number">1</span>)</span><br><span class="line">    counts = lines.flatMap(<span class="keyword">lambda</span> x: x.split(<span class="string">' '</span>)) \</span><br><span class="line">                  .map(map_filter) \</span><br><span class="line">                  .reduceByKey(add)</span><br><span class="line">    output.saveAsTextFile(<span class="string">'hdfs:/user/2015210978/hw2-output-python'</span>)</span><br><span class="line">    sc.stop()</span><br></pre></td></tr></table></figure> 这里的map_filter函数和上面在pyspark中执行的mapfilter.py中的map_filter函数是同一个函数，为了节省空间，这里没有粘贴出来。上述代码保存为wordcount.py。放在一个路径下，这里我还是放在了主目录下。在主目录下执行提交python application命令： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spark-submit --master yarn-client --conf spark.ui.port&#x3D;8015 .&#x2F;wordcount.py</span><br></pre></td></tr></table></figure> 就可以看到程序开始执行了。<br /><strong>(2)Java版本：</strong><br />采用eclipse开发java版本,首先要在build_path中加入spark的包，即SPARK_HOME/lib/spark-assembly-1.5.1-hadoop2.6.0.jar。否则eclipse提示找不到类。采用eclipse开发一个好处就是可以图形化界面导出jar包，不用自己编写maven编译文件。这里列一下写内容到hdfs文件的代码： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String dest = args[<span class="number">1</span>];</span><br><span class="line">Configuration conf = <span class="keyword">new</span> Configuration();</span><br><span class="line">FileSystem fs = FileSystem.get(URI.create(dest), conf);</span><br><span class="line">OutputStream out = fs.create(<span class="keyword">new</span> Path(dest));</span><br><span class="line">List&lt;Tuple2&lt;String, Integer&gt;&gt; output = counts.collect();</span><br><span class="line"><span class="keyword">for</span> (Tuple2&lt;?, ?&gt; tuple : output) &#123;</span><br><span class="line"><span class="comment">//写入hdfs文件中</span></span><br><span class="line">out.write(tuple._1().toString().getBytes());</span><br><span class="line">out.write(<span class="string">' '</span>);</span><br><span class="line">out.write(tuple._2().toString().getBytes());</span><br><span class="line">out.write(<span class="string">'\n'</span>);</span><br><span class="line">&#125;</span><br><span class="line">out.flush();</span><br><span class="line">out.close();</span><br><span class="line">ctx.stop();</span><br></pre></td></tr></table></figure> 在java程序中，进行了两处修改，第一，对每个单词进行特殊字符的过滤。第二，调用hadoop文件操作API将结果以自己指定的格式写入hdfs中。（因为上面的pyspark shell版本和python application版本得到的结果中是python默认打印元组的格式含有括号和u什么的<code>(u'lead-line', 8)</code>,不便于下一步的数据处理）。程序中指定的输出格式是key+空格＋count然后换行。导出jar包为WordCountSparkInJava.jar并上传到服务器中。在jar包所在的路径下执行如下的命令： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spark-submit --master yarn-client --conf spark.ui.port&#x3D;8015 --name WordCount --class com.alvin.test.WordCount --executor-memory 2G --total-executor-cores 2 .&#x2F;WordCountSparkInJava.jar hdfs:&#x2F;tmp&#x2F;bigdata&#x2F;2015&#x2F;english_novel&#x2F;* hdfs:&#x2F;user&#x2F;2015210978&#x2F;result.txt</span><br></pre></td></tr></table></figure> 执行完之后发现结果保存在hdfs:/user/2015210978/result.txt中了。然后利用<code>hadoop fs -copyToLocal　/user/2015210978/result.txt　./</code> 命令拷贝到服务器本地文件中。需要指出的是在hadoop application中也可以利用java的特性将结果写在本地文件中，这里没有用到，用的是java hdfs的一些API将结果写在了hdfs文件系统中。</p><h3 id="排序形成最终结果">2.3 排序形成最终结果</h3><ol type="1"><li>pyspark中用countByKey函数实现的wordcount功能就不需要这一步了，因为已经利用python文本处理进行了不区分大小写排序。pyspark传递函数那个版本和下面的spark python application的后续处理是一样的。<br /></li><li>对Java Application保存的文件可以用下面的命令进行排序 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat result.txt | sort -t&#39; &#39; -k 1,1df &gt; sorted_result.txt</span><br></pre></td></tr></table></figure></li><li>对python application保存的文件的处理有点麻烦，需要去掉括号还有key前面的u,利用linux的shell或者python脚本都可以实现，这里不再赘述。</li></ol><p>因为之前在代码中进行过滤操作时，如果去除特殊字符之后的字符串为空，我们返回("",0),所以在最后的sorted_result.txt文件中第一行为一个空格和０，把它删掉就行了。需要提出的是在spark中有sortByKey这个Transformation,其排序是按字典序排列的，区分大小写。先排大写字母然后排小写字母。不符合我们最后的不区分大小写的要求，也需要进行后续的处理。</p><h2 id="总结">3. 总结</h2><p>通过这次实验，配置好了本地的spark运行环境，在本地写完wordcount程序（pyspark版本，python application和java application版本），并在本机debug完，然后上传到服务器执行，在本地debug的一个好处就是便于查错。<br />本次实验中，主要做了以下的工作： 1. 在pyspark中自己写了一个map_filter函数，并放在文件中加载，这个函数的思路和第一次作业的思路相同，只不过这次这个函数是用python实现的。练习了向pyspark中传递函数以及常用的actions和transformation。并用实验指导书之外的rdd操作和python的一些排序特性进行wordcount的编写。 2. 编写了python application版本的wordcount,调用了map_filter函数。 3. 编写了Java application版本的wordcount。Java版本的application除了在map的时候进行特殊字符的过滤之外，还调用了hdfs的文件接口，以自己定义的格式将结果输出到hdfs文件中，便于后面进行进一步的分析处理。 4. 最后对文件进行合并。</p><p>网上关于spark的中文资料还是挺多的，英文的就是spark guide，篇幅确实不是特别长。</p>]]></content>
      
      
      <categories>
          
          <category> data mining </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bigdata system </tag>
            
            <tag> spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu14.04上hadoop2.7.1环境配置以及第一个MapReduce程序-WordCount</title>
      <link href="/2016/05/11/Ubuntu14-04%E4%B8%8Ahadoop2-7-1%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E7%AC%AC%E4%B8%80%E4%B8%AAMapReduce%E7%A8%8B%E5%BA%8F-WordCount/"/>
      <url>/2016/05/11/Ubuntu14-04%E4%B8%8Ahadoop2-7-1%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E7%AC%AC%E4%B8%80%E4%B8%AAMapReduce%E7%A8%8B%E5%BA%8F-WordCount/</url>
      
        <content type="html"><![CDATA[<h2 id="实验前准备工作">1. 实验前准备工作</h2><h3 id="安装hadoop伪分布式系统">1.1 安装hadoop伪分布式系统</h3><p>1.下载hadoop源文件，hadoop-2.7.1.tar.gz，将其解压在一个文件夹中，这里我解压到了我的电脑的主目录下面，配置参数，主要修改一下几个文件：<br />core-site.xml<br /><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://localhost:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">property</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/yanruibo/hadoop-2.7.1/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure> <a id="more"></a> hdfs-site.xml<br /><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/yanruibo/hadoop-2.7.1/dfs/name<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>/home/yanruibo/hadoop-2.7.1/dfs/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure> mapred-site.xml <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure> yarn-site.xml <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Site specific YARN configuration properties --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>localhost<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure> 最后在hadoop-env.sh文件的第25行，写入java的path， <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdk1.7.0_80</span><br></pre></td></tr></table></figure> 最后为了能在任何路径下都能启动hadoop，需要在path中加入hadoop的路径信息，这里我是为整个系统的用户添加的路径信息，可以在/etc/profile文件中加入如下内容： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export HADOOP_HOME&#x3D;&#x2F;home&#x2F;yanruibo&#x2F;hadoop-2.7.1</span><br><span class="line">export PATH&#x3D;$PATH:$&#123;HADOOP_HOME&#125;&#x2F;bin</span><br></pre></td></tr></table></figure> 配置完这些文件之后，需要安装一些软件。</p><p>2.安装ssh</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ssh</span><br></pre></td></tr></table></figure><p>设置ssh免登陆认证 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -P &#39;&#39; -f ~&#x2F;.ssh&#x2F;id_rsa</span><br><span class="line">cat ~&#x2F;.ssh&#x2F;id_rsa.pub &gt;&gt; ~&#x2F;.ssh&#x2F;authorized_keys</span><br></pre></td></tr></table></figure> 执行完这两条命令就可以免登陆了，可以用以下的命令进行测试： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh localhost</span><br></pre></td></tr></table></figure> 会出现下面的结果： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">yanruibo@yanruibo-PC:~$ ssh localhost</span><br><span class="line">The authenticity of host &#39;localhost (127.0.0.1)&#39; can&#39;t be established.</span><br><span class="line">ECDSA key fingerprint is 08:09:86:92:60:c2:62:09:21:3a:89:91:d5:8b:24:de.</span><br><span class="line">Are you sure you want to continue connecting (yes&#x2F;no)? yes</span><br><span class="line">Warning: Permanently added &#39;localhost&#39; (ECDSA) to the list of known hosts.</span><br><span class="line">Welcome to Ubuntu 14.04.3 LTS (GNU&#x2F;Linux 3.19.0-28-generic x86_64)</span><br><span class="line"></span><br><span class="line"> * Documentation:  https:&#x2F;&#x2F;help.ubuntu.com&#x2F;</span><br><span class="line">The programs included with the Ubuntu system are free software;</span><br><span class="line">the exact distribution terms for each program are described in the</span><br><span class="line">individual files in &#x2F;usr&#x2F;share&#x2F;doc&#x2F;*&#x2F;copyright.</span><br><span class="line"></span><br><span class="line">Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by</span><br><span class="line">applicable law.</span><br></pre></td></tr></table></figure></p><p>3.第一次启动hadoop时要格式化一下hdfs文件系统<br /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs namenode -format</span><br></pre></td></tr></table></figure> 然后通过在命令行执行，因为我们之前在/etc/profile中设置了hadoop的路径信息，所以在任何路径下执行一下命令都可以 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start-all.sh</span><br></pre></td></tr></table></figure> 可以测试一下能否启动成功： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">yanruibo@yanruibo-PC:~$ start-all.sh</span><br><span class="line">This script is![](http:&#x2F;&#x2F;) Deprecated. Instead use start-dfs.sh and start-yarn.sh</span><br><span class="line">Starting namenodes on [localhost]</span><br><span class="line">localhost: starting namenode, logging to &#x2F;home&#x2F;yanruibo&#x2F;hadoop-2.7.1&#x2F;logs&#x2F;hadoop-yanruibo-namenode-yanruibo-PC.out</span><br><span class="line">localhost: starting datanode, logging to &#x2F;home&#x2F;yanruibo&#x2F;hadoop-2.7.1&#x2F;logs&#x2F;hadoop-yanruibo-datanode-yanruibo-PC.out</span><br><span class="line">Starting secondary namenodes [0.0.0.0]</span><br><span class="line">0.0.0.0: starting secondarynamenode, logging to &#x2F;home&#x2F;yanruibo&#x2F;hadoop-2.7.1&#x2F;logs&#x2F;hadoop-yanruibo-secondarynamenode-yanruibo-PC.out</span><br><span class="line">starting yarn daemons</span><br><span class="line">starting resourcemanager, logging to &#x2F;home&#x2F;yanruibo&#x2F;hadoop-2.7.1&#x2F;logs&#x2F;yarn-yanruibo-resourcemanager-yanruibo-PC.out</span><br><span class="line">localhost: starting nodemanager, logging to &#x2F;home&#x2F;yanruibo&#x2F;hadoop-2.7.1&#x2F;logs&#x2F;yarn-yanruibo-nodemanager-yanruibo-PC.out</span><br></pre></td></tr></table></figure> 如果出现以上的信息，说明配置成功。或者执行jps命令 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">yanruibo@yanruibo-PC:~$ jps</span><br><span class="line">11149 SecondaryNameNode</span><br><span class="line">12989 Jps</span><br><span class="line">10941 DataNode</span><br><span class="line">10770 NameNode</span><br><span class="line">11315 ResourceManager</span><br><span class="line">11452 NodeManager</span><br></pre></td></tr></table></figure> 如果出现以上几个进程，也表示执行成功了。<br />关闭所有进程，相应的是stop-all.sh</p><h3 id="配置eclipse开发环境">1.2 配置eclipse开发环境</h3><p>首先下载hadoop的eclipse插件，从网上可以下载到，这个插件可以下载网上别人编译好的，也可以用eclipse自己编译，网上有教程，这里为了节省时间，我从网上自己下载了一个eclipse插件，hadoop-eclipse-plugin-2.7.1.jar，也是从csdn上下载的，可以自己搜索下载。下载下来之后放到eclipse安装文件夹下的plugins目录中，重启eclipse即可生效，然后在Window-&gt;Preferences-&gt;Hadoop Map/Reduce项中设置一下hadoop的home。<br /><img src="pic/Eclipse-Hadoop-Home-Configure.png" align="middle" width="70%" /> 然后切换到eclipse的Map/Reduce视图下面，<br /><img src="pic/map-reduce-locations.png" align="middle" width="70%" /> 右键 new hadoop location，按如下图所示进行配置，<br /><img src="pic/hadoop-location-conf.png" align="middle" width="70%" /></p><p>注意端口号要配置正确，配置完成这些之后，新建一个Map/Reduce的工程，eclipse就自动把相应依赖的hadoop包加载到工程的path中，你还可以在Project Explorer中的DFS Locations中查看你的hdfs中的文件，能观察到这一点的前提是前面hdfs的端口配置正确，还有就是你执行了start-all.sh，把hadoop的那几个进程都启动起来了。</p><p><img src="pic/all-view.png" align="middle" width="70%" /></p><p>这里准备工作，即开发环境就搭建好了，下面就开始编写mapreduce程序。</p><h2 id="实验过程">2. 实验过程</h2><h3 id="基本要求level-0-1">2.1 基本要求Level 0 1</h3><p>使用example里面的wordcount算法，统计每个词出现的次数，使用的命令为： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hadoop jar &#x2F;home&#x2F;yanruibo&#x2F;hadoop-2.7.1&#x2F;share&#x2F;hadoop&#x2F;mapreduce&#x2F;hadoop-mapreduce-examples-2.7.1.jar wordcount &#x2F;tmp&#x2F;bigdata&#x2F;2015&#x2F;english_novel&#x2F;* &#x2F;user&#x2F;2015210978&#x2F;hw1-output1</span><br></pre></td></tr></table></figure> 这里我在eclipse中创建了一个mapreduce工程，包名为：com.alvin.test,有三个类WordCount.java,StringTest.java,Test.java，WordCount.java是实现单词计数的mapreduce程序，其余两个是过滤字符串的标点符号写的测试类。我创建了一个WordCount程序，照着example中的敲过来，然后通过eclipse导出jar包为WordCount1.jar，然后通过如下命令将导出的jar上传到服务器home目录下 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sftp -P 2222 2015210978@thumedia.org</span><br><span class="line">put WordCount1.jar &#x2F;home&#x2F;2015210978</span><br></pre></td></tr></table></figure> 然后ssh登陆到服务器： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p 2222 2015210978@thumedia.org</span><br></pre></td></tr></table></figure> 在服务器的home目录也就是WordCount1.jar所在的目录，执行jar包，执行的命令为： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export HADOOP_CLASSPATH&#x3D;WordCount1.jar</span><br><span class="line">hadoop com.alvin.test.WordCount &#x2F;tmp&#x2F;bigdata&#x2F;2015&#x2F;english_novel&#x2F;* &#x2F;user&#x2F;2015210978&#x2F;hw1-output1</span><br></pre></td></tr></table></figure> 这里的执行命令参考了《Hadoop The Definitive Guide》。然后就会看到mapreduce任务开始执行了。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2015210978@cluster-3-0:~$ hadoop com.alvin.test.WordCount &#x2F;tmp&#x2F;bigdata&#x2F;2015&#x2F;english_novel&#x2F;* &#x2F;user&#x2F;2015210978&#x2F;hw1-output2</span><br><span class="line">15&#x2F;10&#x2F;15 11:07:28 INFO client.RMProxy: Connecting to ResourceManager at cluster29&#x2F;192.168.5.129:8032</span><br><span class="line">15&#x2F;10&#x2F;15 11:07:29 INFO input.FileInputFormat: Total input paths to process : 1464</span><br><span class="line">15&#x2F;10&#x2F;15 11:07:33 INFO mapreduce.JobSubmitter: number of splits:1464</span><br><span class="line">15&#x2F;10&#x2F;15 11:07:34 INFO mapreduce.JobSubmitter: Submitting tokens for job: job_1426037502156_0240</span><br><span class="line">15&#x2F;10&#x2F;15 11:07:34 INFO impl.YarnClientImpl: Submitted application application_1426037502156_0240</span><br><span class="line">15&#x2F;10&#x2F;15 11:07:34 INFO mapreduce.Job: The url to track the job: http:&#x2F;&#x2F;cluster29:8088&#x2F;proxy&#x2F;application_1426037502156_0240&#x2F;</span><br><span class="line">15&#x2F;10&#x2F;15 11:07:34 INFO mapreduce.Job: Running job: job_1426037502156_0240</span><br><span class="line">15&#x2F;10&#x2F;15 11:07:49 INFO mapreduce.Job: Job job_1426037502156_0240 running in uber mode : false</span><br><span class="line">15&#x2F;10&#x2F;15 11:09:52 INFO mapreduce.Job: Job job_1426037502156_0240 completed successfully</span><br></pre></td></tr></table></figure> 然后在服务器命令行中查看，并将结果拷贝到服务器的本地文件系统中， <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hadoop fs -ls &#x2F;user&#x2F;2015210978&#x2F;output1</span><br><span class="line">hadoop fs -copyToLocal &#x2F;user&#x2F;2015210978&#x2F;output1 .&#x2F;</span><br></pre></td></tr></table></figure> 最后在sftp中将结果拉到我的电脑中 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get output1&#x2F;* .&#x2F;</span><br></pre></td></tr></table></figure></p><h3 id="基本要求level-2">2.2 基本要求Level 2</h3><p>有了单词计数的基本功能，我们查看一下执行结果，发现会有一下的情况： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&quot;&#x2F;de&#x2F;1</span><br><span class="line">&quot;&#39;Alexander1</span><br><span class="line">&quot;&#39;Ample.&#39;1</span><br><span class="line">&quot;3&quot;1</span><br><span class="line">&quot;52.43!&quot;1</span><br><span class="line">&quot;&#39;&#39;Twon&#39;t1</span><br><span class="line">&quot;But--how2</span><br><span class="line">&quot;Bureaucracy,&quot;--if1</span><br></pre></td></tr></table></figure> 这样的单词识别效果不是特别好，我们要去掉标点符号和数字以及其他的非英语字符，首先想到的是用正则表达式，于是上网查正则表达式的知识，把最经典的《<a href="http://deerchao.net/tutorials/regex/regex.htm" target="_blank" rel="noopener">正则表达式30分钟入门教程</a>》看完了，同时由搜了一些资料，发现把整个单词中的标点符号全部去掉很容易，但是如果把整个单词的标点符号都去掉的话，上面的第六七八行就会有问题，因为<code>"''Twon't "But--how "Bureaucracy,"--if</code>这三个词两边的标点符号去掉是可以的，但是这三个词中间的标点符号去掉是不合理的，因此我实现的策略是只过滤每个单词两边的标点符号，对于中间的标点符号不进行过滤。具体见下面的代码： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(Object key, Text value, Context context)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">StringTokenizer itr = <span class="keyword">new</span> StringTokenizer(value.toString());</span><br><span class="line"><span class="keyword">while</span> (itr.hasMoreTokens()) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 此处进行一些优化 1.去掉单词首尾的空格 2.去掉单词首尾的标点符号和数字</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">String s = itr.nextToken();</span><br><span class="line"><span class="comment">// 去掉单词首尾的空格</span></span><br><span class="line">s = s.trim();</span><br><span class="line"><span class="comment">// 去除单词首部的标点符号</span></span><br><span class="line">s = s.replaceFirst(<span class="string">"(?i)^[^a-zA-Z]+"</span>, <span class="string">""</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 下面是去除单词尾部的标点符号，先把字符串反转，</span></span><br><span class="line"><span class="comment">* 然后再调用replaceFirst，</span></span><br><span class="line"><span class="comment">* 去除反转后的字符串首部的标点符号，再把字符串反转过来</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">s = <span class="keyword">new</span> StringBuilder(s).reverse().toString();</span><br><span class="line">s = s.replaceFirst(<span class="string">"(?i)^[^a-zA-Z]+"</span>, <span class="string">""</span>);</span><br><span class="line">s = <span class="keyword">new</span> StringBuilder(s).reverse().toString();</span><br><span class="line"><span class="comment">//过滤之后s的值可能为空，比如全为数字的就变为空</span></span><br><span class="line"><span class="keyword">if</span> (!s.isEmpty()) &#123;</span><br><span class="line">word.set(s);</span><br><span class="line">context.write(word, one);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = s.replaceFirst(<span class="string">"(?i)^[^a-zA-Z]+"</span>, <span class="string">""</span>);</span><br></pre></td></tr></table></figure><p>解释一下上面的正则表达式，小括号即里面的问好和i表示不去分大小写，紧接着的上角号标示单词的起始位置，中括号即中括号中的内容标示不是大小写字母，所以这句话的意思是不区分大小写把单词首部的不是大小写字母的都去掉。也就是说只要能匹配到哪个正则表达式的字符串都被替换为空字符串，匹配不上的保留。</p><h3 id="基本要求level-3">2.3 基本要求Level 3</h3><p>将得到的结果合并成一个txt文档，并对每个单词按照字典排序，其实可以通过设置reducer的个数为1，如果结果文件比较小的话，应该就输出到一个文件中了，这一点在实验中进行了验证，以下是设置方法： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;设置reducer的个数 通过设置reducer的个数为1，经过实验验证了输出结果全写在一个文件中了，结果文件也不大。</span><br><span class="line">job.setNumReduceTasks(1);</span><br></pre></td></tr></table></figure> 这样单词就按字典序拍好了，但是大写字母在前小写字母在后，为了不区分大小写，需要用sort命令： <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat output2&#x2F;* | sort -t&#39; &#39; -k 1,1df &gt; result.txt</span><br></pre></td></tr></table></figure> sort -t指定分隔符为空格，-k 指定按哪一列进行排序，1,1df标示按第一列进行排序，并且加上-d -f选项，-d按字典序排序，-f忽略大小写。</p><h3 id="基本要求level-4">2.4 基本要求Level 4</h3><p>要求：自己实现shuffle等函数。</p><p>1.查了一些资料，可以自己写combiner函数， 每一个map都可能会产生大量的本地输出，Combiner的作用就是对map端的输出先做一次合并，以减少在map和reduce节点之间的数据传输量，以提高网络IO性能，是MapReduce的一种优化手段之一。Combiner有本地reduce功能（其本质上就是一个<strong>提前的reducer</strong>），在WordCount程序中可以单独写一个Combiner类，也可以用Reducer类来代替，然后在job那儿设置一下： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Combiner类规定继承自Reducer</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCombiner</span> <span class="keyword">extends</span> <span class="title">Reducer</span>&lt;<span class="title">Text</span>, <span class="title">IntWritable</span>, <span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> IntWritable result = <span class="keyword">new</span> IntWritable();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">(Text key, Iterable&lt;IntWritable&gt; values, Context context)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (IntWritable val : values) &#123;</span><br><span class="line">sum += val.get();</span><br><span class="line">&#125;</span><br><span class="line">result.set(sum);</span><br><span class="line">context.write(key, result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 一定不要忘了设置一下 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">job.setCombinerClass(Combiner.class);</span><br></pre></td></tr></table></figure> 经过实验是可以的。<br />2.自己写Partitioner <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Partitioner 自己写的一个例子，算法也是突发奇想，随便写的，可能分类的效果不好</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPartitioner</span> <span class="keyword">extends</span> <span class="title">Partitioner</span>&lt;<span class="title">Text</span>, <span class="title">IntWritable</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getPartition</span><span class="params">(Text key,IntWritable value,<span class="keyword">int</span> numReduceTasks)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 自己随便想的一个hash函数，把一个单词的每个字符的ASCII码的和乘以一个数再跟reducer的数目取余。</span></span><br><span class="line"><span class="comment">* 乘以127是为了增加混杂度，取模之后分布更加均匀</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">String skey = key.toString();</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; skey.length(); ++i) &#123;</span><br><span class="line">sum += skey.charAt(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum * <span class="number">127</span> % numReduceTasks;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 同样也不要忘了在设置一下 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置Partitioner类</span></span><br><span class="line">job.setPartitionerClass(MyPartitioner.class);</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> data mining </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bigdata system </tag>
            
            <tag> hadoop </tag>
            
            <tag> spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>interview questions cpp</title>
      <link href="/2016/05/07/interview-questions-cpp/"/>
      <url>/2016/05/07/interview-questions-cpp/</url>
      
        <content type="html"><![CDATA[<ol type="1"><li>排序</li><li>线程和进程的区别，Linux中线程的实现（Linux内核的知识）http://www.ibm.com/developerworks/cn/linux/kernel/l-thread/</li><li>Linux如何进行线程间通信</li><li>如何查找二叉树上距离最远的两个节点</li><li>Linux下C++的开发环境，makefile和gdb</li><li>计算机网络OSI七层模型，TCP/IP模型（各层的功能，比如链路层的功能）</li><li>在C++程序中开辟1M的内存空间来存储数据有几种方法？（除了new和malloc之外还有没），new和malloc的区别，</li><li>一个程序的内存是怎么分配的？比如全局变量在什么地方http://www.cnblogs.com/daocaoren/archive/2011/06/29/2092957.html</li><li>C++类的内存分布（虚表） http://www.cnblogs.com/jerry19880126/p/3616999.html http://blog.csdn.net/weitian826/article/details/6913482</li><li>hash的冲突避免机制 http://www.cnblogs.com/jillzhang/archive/2006/11/03/548671.html</li><li>C和C++中static的作用</li><li>如果有一段代码比较短，但是经常用，C和C++中分别会怎么做（extern和inline）</li><li>C++中存在继承关系时，构造函数和析构函数的执行</li><li>拷贝构造函数的写法以及什么时候调用拷贝构造函数？http://blog.csdn.net/iceshirley/article/details/4152602</li><li>shallow copy &amp; deep copy</li><li>socket 创建过程</li><li>atoi函数自己实现算法</li><li>数组中存有1-1000个数，从中抽出一个数，设计一个算法，找出抽出的数是多少？</li><li>比如有一个1万个单词的词典，比如map是一个正规的词，amp也是一个正规的词，给一个词求出类此的词在词典中的个数。类似于map['map']=int求int值</li><li>有一个文件特别大，颠倒其中的内容，比如最后一行存到第一行，倒数第二行存到第二行</li><li>找出一个字符串中连着重复的字符的最大个数，比如aabbbcccddddd 输出5</li><li>有一个特别大的文件中存储一些整数值，比如有128G，你的电脑内存只有4G，如何找出文件中前十大的数（hash和min heap）</li><li>select和epoll</li></ol><p>notes:</p><ol type="1"><li>我们一般认为两个浮点数相等，当且当他们之间的误差不超过1e-8。</li><li>保留两位小数，C++用 printf("%.2lf",a);</li><li>cpp四舍五入到整数</li></ol><table><thead><tr class="header"><th></th><th>2.1</th><th>2.6</th><th>-2.1</th><th>-2.6</th></tr></thead><tbody><tr class="odd"><td>floor:不大于自变量的最大整数</td><td>2</td><td>2</td><td>-3</td><td>-3</td></tr><tr class="even"><td>ceil: 不小于自变量的最小整数</td><td>3</td><td>3</td><td>-2</td><td>-2</td></tr><tr class="odd"><td>round:四舍五入到最邻近的整数</td><td>2</td><td>3</td><td>-2</td><td>-3</td></tr></tbody></table><p>floor和ceil需要加math.h头文件。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">round</span><span class="params">(<span class="keyword">double</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (r &gt; <span class="number">0.0</span>)? <span class="built_in">floor</span>(r+<span class="number">0.5</span>):<span class="built_in">ceil</span>(r<span class="number">-0.5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">round</span><span class="params">(<span class="keyword">float</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">floor</span>(f * <span class="number">5</span> + <span class="number">0.5</span>) / <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// return std::round(f * 5) / 5; // C++11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> interview questions </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hmm</title>
      <link href="/2016/04/15/hmm/"/>
      <url>/2016/04/15/hmm/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/yanruibo/machine-learning/tree/master/hmm" target="_blank" rel="noopener">code:https://github.com/yanruibo/machine-learning/tree/master/hmm</a></p><h2 id="要求">1. 要求</h2><p>隐马尔科夫模型应用<br />实验要求:</p><ol type="1"><li>学习课件、课本和其它相关资料，掌握HMM的原理和应用方法。</li><li>既可以根据网络课堂给的参考文章，也可以自己选定问题，采用HMM方法进行应用。</li><li>实验相关资料包括：SAMARIA的文章，HMM编程示例，人脸库（yelefaces是上传的一个小实验库，有需要的同学可找助教要较大的人脸库，或自行搜索下载）。</li></ol><a id="more"></a><h2 id="相关知识">2. 相关知识</h2><p>　　这里把重点放在介绍论文的人脸识别方法上。</p><h3 id="hmm">2.1 HMM</h3><p>　　隐马尔科夫模型是关于时序的概率模型，描述由一个隐藏的马尔科夫链随机生成不可观测的状态的随机序列，再由各个状态生成一个观测而产生观测随机序列的过程，隐藏的马尔科夫链随机生成的状态的序列称为状态序列，每个状态生成一个观测，而由此产生的观测的随机序列，称为观测序列，序列的每一个位置又可以看做是一个时刻。<br />　　隐马尔科夫模型由初始概率分布，状态转移概率分布以及观测概率分布确定。其余内容还有概率的前向和后向计算算法，学习算法中的Baum-Welch算法和预测算法的维特比算法，这些知识在统计学习方法第10章中有详细的介绍。</p><h3 id="论文human-face-identification">2.2 论文Human Face Identification</h3><p>Parameterisation of a Stochastic Model for Human Face Identification</p><h4 id="采样">(1).采样</h4><p>　　将每一个人脸的图像从上到下进行分块，每个分块的像素层数（行数）为L，块与块之前需要重叠一下，重叠的像素层数（行数）为M，那么状态序列的长度用下面的公式来计算： <span class="math display">\[T=\phi(\frac{Y-L}{L-M})+1\]</span> 　　在代码中我对每一个块的图像进行了图像特征提取，一方面是为了降维，另一方面是为了突出主要特征，常见的图像特征提取方法有LBP(Local Binary Pattern)和HOG(Histogram of Oriented Gradients),由于在模式识别课上已经自己实现了LBP算法，在这里就直接把模式识别课上写过的LBP算法拿过来直接用了。而论文中的操作只是把每一块图像的每一行首尾连接拼成一个很长的向量，这里对论文中的方法做了改进。</p><p>具体代码如下所示： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">对每一张图片生成观测序列，该方法是把图片每一块的图像进行LBP提取特征之后变成36维的向量，然后按行放到一个矩阵中</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_observations_lbp</span><span class="params">(imagepath, L=<span class="number">10</span>, M=<span class="number">4</span>)</span>:</span></span><br><span class="line">    <span class="comment"># './att_faces/s1/1.pgm'</span></span><br><span class="line">    image = cv2.imread(imagepath)</span><br><span class="line">    <span class="comment"># (112,92)</span></span><br><span class="line">    <span class="comment"># print image.shape</span></span><br><span class="line">    gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    Y = gray_image.shape[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># L = 10</span></span><br><span class="line">    <span class="comment"># M = 4</span></span><br><span class="line">    obs_length = np.floor((Y - L) / (L - M)) + <span class="number">1</span></span><br><span class="line">    obs_list = []</span><br><span class="line">    counter = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(counter &lt; obs_length):</span><br><span class="line">        begin = counter * (L - M)</span><br><span class="line">        end = (counter + <span class="number">1</span>) * L - counter * M</span><br><span class="line">        sub_mat = gray_image[range(begin, end), :]</span><br><span class="line">        obsith = LBP(sub_mat)</span><br><span class="line">        <span class="comment"># print sub_mat.shape</span></span><br><span class="line">        <span class="comment"># obsith = sub_mat.reshape(sub_mat.shape[0] * sub_mat.shape[1])</span></span><br><span class="line">        <span class="comment"># obsith = obsith.reshape((obsith.shape[0], 1))</span></span><br><span class="line">        obs_list.append(obsith)</span><br><span class="line">        counter = counter + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> np.array(obs_list)</span><br></pre></td></tr></table></figure></p><h4 id="训练">(2).训练</h4><p>　　对每一张图片进行采样过后得到一个观测序列，这个观测序列中的一个值也是一个向量，这就和书上写的一般的HMM有所不同了，这里需要用到GaussianHMM，就是把每个观测序列的观测值训练为一个高斯模型。</p><p>具体代码如下所示： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">models = []</span><br><span class="line"><span class="keyword">print</span> <span class="string">"begin training models"</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(train_labels)):</span><br><span class="line">    <span class="keyword">if</span>(i % <span class="number">5</span> == <span class="number">0</span>):</span><br><span class="line">        <span class="comment"># 0 5 10 15 : 1 2 3 4</span></span><br><span class="line">        <span class="comment"># 选取同一个人的五张图片训练一个Model</span></span><br><span class="line">        X1 = generate_observations_lbp(train_imagepathes[i], L, M);</span><br><span class="line">        X2 = generate_observations_lbp(train_imagepathes[i + <span class="number">1</span>], L, M);</span><br><span class="line">        X3 = generate_observations_lbp(train_imagepathes[i + <span class="number">2</span>], L, M);</span><br><span class="line">        X4 = generate_observations_lbp(train_imagepathes[i + <span class="number">3</span>], L, M);</span><br><span class="line">        X5 = generate_observations_lbp(train_imagepathes[i + <span class="number">4</span>], L, M);</span><br><span class="line">        model = GaussianHMM(n_components, covariance_type=<span class="string">"diag"</span>, n_iter=<span class="number">1000</span>).fit([X1, X2, X3, X4, X5])</span><br><span class="line">        models.append(model)</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"training models %s%%"</span> % str(float(i+<span class="number">5</span>)/len(train_imagepathes)*<span class="number">100</span>)</span><br><span class="line">model_labels = range(<span class="number">1</span>, <span class="number">41</span>)</span><br></pre></td></tr></table></figure></p><h4 id="测试">(3).测试</h4><p>　　训练完成之后，进行测试，这里我们选用的是论文中的数据集。该数据集共有40个不同的人脸，每个人脸有10个，我们选用每个人脸的前五个作为训练，后五个作为测试，这样就得到了40个GaussianHMM的model，然后在测试的时候，对每一张待测试的图片先生成观测序列，然后计算一下<span class="math inline">\(P(O_{test}|\lambda^{(k)})\)</span>（调用一下model.score函数），然后找到最大概率的模型所对应的类别就是预测的类别。</p><p>具体代码如下所示： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">correct_count = <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> j <span class="keyword">in</span> range(len(test_imagepathes)):</span><br><span class="line">       test_one = generate_observations_lbp(test_imagepathes[j], L, M)</span><br><span class="line">       max_score = -sys.maxint</span><br><span class="line">       max_label = <span class="literal">None</span></span><br><span class="line">       <span class="keyword">for</span> k <span class="keyword">in</span> range(len(models)):</span><br><span class="line">           current_score = models[k].score(test_one)</span><br><span class="line">           <span class="keyword">if</span>(current_score &gt; max_score):</span><br><span class="line">               max_score = current_score</span><br><span class="line">               max_label = model_labels[k]</span><br><span class="line">       <span class="keyword">if</span>(max_label == test_labels[j]):</span><br><span class="line">           <span class="keyword">print</span> <span class="string">"correct: real"</span>,test_labels[j],<span class="string">"predict"</span>,max_label</span><br><span class="line">           correct_count += <span class="number">1</span></span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">           <span class="keyword">print</span> <span class="string">"error: real"</span>,test_labels[j],<span class="string">"predict"</span>,max_label</span><br><span class="line">   accracy = float(correct_count)/len(test_imagepathes)</span><br><span class="line">   <span class="keyword">print</span> <span class="string">"Accracy is"</span>,accracy</span><br><span class="line">   <span class="keyword">return</span> accracy</span><br></pre></td></tr></table></figure></p><h2 id="实验过程">3. 实验过程</h2><p>　　<font color="#FF7F50">注意跑本实验代码需要scikit-learn0.14版本。因为最新版本的scikit-learn库把hmm模块移除了。</font> 这里总结一下GaussianHMM的用法： 1.scikit-learn中的GaussianHMM(我的是scikit-learn 0.14.1版本) from sklearn.hmm import GaussianHMM model = GaussianHMM(n_components, covariance_type="diag", n_iter=1000).fit([X1, X2, X3, X4, X5]) 2.助教给的hmmlearn包 from hmmlearn.hmm import GaussianHMM model = GaussianHMM(n_components, covariance_type="diag", n_iter=1000).fit(X) 上面的X是五个图片矩阵按行堆叠形成的大矩阵。</p><p>代码目录结构说明：<br />att_faces论文中所用到的数据库<br />face-identification.py，选用每个类别的前五张作为训练集后五张作为测试集进行人脸识别代码。<br />face-indentification-random.py。从每个类别的10张图片中任意选择五张作为训练集，剩余的作为测试集进行人脸识别。<br />log的txt文件是调参过程中的输出的参数的准确率的信息。<br />mainLBP.py是提取图像特征的LBP算法。</p><p>固定L和M,观察states的影响：</p><table><thead><tr class="header"><th style="text-align: center;">states</th><th style="text-align: center;">L</th><th style="text-align: center;">M</th><th style="text-align: center;">Accuracy</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">4</td><td style="text-align: center;">14</td><td style="text-align: center;">7</td><td style="text-align: center;">0.695</td></tr><tr class="even"><td style="text-align: center;">5</td><td style="text-align: center;">14</td><td style="text-align: center;">7</td><td style="text-align: center;">0.695</td></tr><tr class="odd"><td style="text-align: center;">6</td><td style="text-align: center;">14</td><td style="text-align: center;">7</td><td style="text-align: center;">0.7</td></tr><tr class="even"><td style="text-align: center;">7</td><td style="text-align: center;">14</td><td style="text-align: center;">7</td><td style="text-align: center;">0.69</td></tr><tr class="odd"><td style="text-align: center;">8</td><td style="text-align: center;">14</td><td style="text-align: center;">7</td><td style="text-align: center;">0.58</td></tr><tr class="even"><td style="text-align: center;">9</td><td style="text-align: center;">14</td><td style="text-align: center;">7</td><td style="text-align: center;">0.605</td></tr></tbody></table><p>固定L和M,随着states个数的增大，效果先变好后变差，在6或7左右取最大值。</p><p>固定states和M,观察L的影响：</p><table><thead><tr class="header"><th style="text-align: center;">states</th><th style="text-align: center;">L</th><th style="text-align: center;">M</th><th style="text-align: center;">Accuracy</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">5</td><td style="text-align: center;">12</td><td style="text-align: center;">7</td><td style="text-align: center;">0.675</td></tr><tr class="even"><td style="text-align: center;">5</td><td style="text-align: center;">13</td><td style="text-align: center;">7</td><td style="text-align: center;">0.62</td></tr><tr class="odd"><td style="text-align: center;">5</td><td style="text-align: center;">14</td><td style="text-align: center;">7</td><td style="text-align: center;">0.685</td></tr><tr class="even"><td style="text-align: center;">5</td><td style="text-align: center;">15</td><td style="text-align: center;">7</td><td style="text-align: center;">0.67</td></tr><tr class="odd"><td style="text-align: center;">5</td><td style="text-align: center;">16</td><td style="text-align: center;">7</td><td style="text-align: center;">0.675</td></tr></tbody></table><p>固定states和M,随着L个数的增大，效果先变好后变差，在14或15左右取最大值。</p><p>固定states和L,观察M的影响：</p><table><thead><tr class="header"><th style="text-align: center;">states</th><th style="text-align: center;">L</th><th style="text-align: center;">M</th><th style="text-align: center;">Accuracy</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">5</td><td style="text-align: center;">14</td><td style="text-align: center;">5</td><td style="text-align: center;">0.585</td></tr><tr class="even"><td style="text-align: center;">5</td><td style="text-align: center;">14</td><td style="text-align: center;">6</td><td style="text-align: center;">0.59</td></tr><tr class="odd"><td style="text-align: center;">5</td><td style="text-align: center;">14</td><td style="text-align: center;">7</td><td style="text-align: center;">0.695</td></tr><tr class="even"><td style="text-align: center;">5</td><td style="text-align: center;">14</td><td style="text-align: center;">8</td><td style="text-align: center;">0.64</td></tr></tbody></table><p>固定states和L,随着M个数的增大，效果先变好后变差，在6或7或8左右取最大值。</p><p>比较好的运行结果：</p><table><thead><tr class="header"><th style="text-align: center;">states</th><th style="text-align: center;">L</th><th style="text-align: center;">M</th><th style="text-align: center;">Accuracy</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">4</td><td style="text-align: center;">9</td><td style="text-align: center;">5</td><td style="text-align: center;">0.73</td></tr><tr class="even"><td style="text-align: center;">4</td><td style="text-align: center;">12</td><td style="text-align: center;">8</td><td style="text-align: center;">0.765</td></tr><tr class="odd"><td style="text-align: center;">4</td><td style="text-align: center;">13</td><td style="text-align: center;">11</td><td style="text-align: center;">0.75</td></tr><tr class="even"><td style="text-align: center;">5</td><td style="text-align: center;">10</td><td style="text-align: center;">7</td><td style="text-align: center;">0.745</td></tr></tbody></table><p>虽然准确率比较低，但是和论文中是差不多的，论文中的错误率也是在0.2-0.3之间。另外精确率比较高，比较好的结果可以见log-random6.txt文件。</p><h2 id="总结">4. 总结</h2><p>　　通过这次实验对用HMM进行人脸识别有了比较深入的了解，有一个缺点就是所有的函数都是通过调用库函数实现的，由于自己实现HMM已经非常复杂，而且用于人脸识别的每个观测点又是一个向量，因此要实现GaussianHMM，而且对于同一个人的人脸要用五张进行训练得到一个GaussianHMM模型，还要实现接收multi observation sequences的GaussianHMM，需要有一个迭代更新GaussianHMM参数的过程，这个方法在下面参考文献的硕士论文中有提到，因为时间紧张而且还要写老师的论文，就没有自己编写算法。就采用了调库的方式。</p><h2 id="参考文献">5. 参考文献：</h2><p>1.Parameterisation of a Stochastic Model for Human Face Identification<br />2.基于隐马尔科夫模型的人脸识别　李增劲 哈哈哈哈</p>]]></content>
      
      
      <categories>
          
          <category> machine learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> machine learning </tag>
            
            <tag> hmm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>svm</title>
      <link href="/2016/04/10/svm/"/>
      <url>/2016/04/10/svm/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/yanruibo/machine-learning/tree/master/svm" target="_blank" rel="noopener">code:https://github.com/yanruibo/machine-learning/tree/master/svm</a></p><h2 id="要求">1. 要求</h2><p>SVM算法改进 1.实验目的</p><pre><code>1.1--掌握SVM基本原理和算法1.2--掌握基于SVM的实际问题建模和应用1.3--自学SVM的改进算法并应用</code></pre><p>2.实验内容</p><pre><code>2.1--对课本案例进行实验，调整SVM参数，如C和核函数参数等，对比实验结果并分析。2.2--编程实现SVM改进算法，分析实验结果，注意样本的Fussy的属性值加入。</code></pre><a id="more"></a><h2 id="相关知识">2. 相关知识</h2><h3 id="svm">2.1 SVM</h3><p>支持向量机是一种二分类模型，它的基本模型是定义在特征空间上的间隔最大的线性分类器，支持向量机的学习策略就是间隔最大化，可形式化理解为一个求解凸二次规划的问题。 假设给定一个特征空间上的训练数据集， <span class="math display">\[T=\{(x_1,y_1),(x_2,y_2),\cdots,(x_N,y_N) \} \]</span> 其中<span class="math inline">\(x_i\in \chi = R^n,y_i\in \{+1,-1\}, i=1,2,\cdots,N,x_i\)</span>为第i个特征向量，也称为实例，<span class="math inline">\(y_i\)</span>为<span class="math inline">\(x_i\)</span>的类标记，当<span class="math inline">\(y_i=+1\)</span>时，称<span class="math inline">\(x_i\)</span>为正例，反之为负例。假设训练数据集是线性可分的，学习的目标是在特征空间中找到一个分离超平面，能将实例分类到不同的类。分离超平面对应于方程<span class="math inline">\(\omega \cdot x+b=0\)</span>,它由法向量<span class="math inline">\(\omega\)</span>和截距<span class="math inline">\(b\)</span>决定。</p><p><strong>线性可分支持向量机</strong>:给定线性可分训练数据集，通过间隔最大化或等价的求解相应的凸二次规划问题学习得到的分离超平面为 <span class="math display">\[ \omega^* \cdot x+b^*=0\]</span> 以及对应的分类决策函数 <span class="math display">\[f(x)=sign(\omega^* \cdot x+b^*)\]</span> 称为线性可分支持向量机。线性可分支持向量机对应着将两类数据正确划分并且间隔最大的直线。 一般来说，一个点距离分类超平面的远近可以表示分类预测的确信程度。在超平面<span class="math inline">\(\omega \cdot x+b=0\)</span>确定的情况下，<span class="math inline">\(\|\omega \cdot x+b\|\)</span>能够相对的表示点x距离超平面的远近。而<span class="math inline">\(\omega \cdot x+b\)</span>的符号和类标记y的符号是否一致，能够表示分类是否正确。所以可以用<span class="math inline">\(y(\omega \cdot x+b)\)</span>来表示分类的正确性和确信度。这就是函数间隔的概念。对分离超平面的法向量<span class="math inline">\(\omega\)</span>加某些约束，如规范化，<span class="math inline">\(\|\omega\|=1\)</span>,使得函数间隔是确定的就变成了几何间隔。<br />这个问题可以表示为下面的约束最优化问题: <span class="math display">\[\max\limits_{w,b} \gamma \\s.t.\quad y_i(\frac{\omega}{\|\omega\|}\cdot x_i+\frac{b}{\|\omega\|})\geq\gamma,\quad i=1,2,\cdots,N\]</span> 考虑函数间隔和几何间隔的关系，可将问题改写为: <span class="math display">\[\max\limits_{w,b} \hat{\gamma} \\s.t.\quad y_i(\frac{\omega}{\|\omega\|}\cdot x_i+\frac{b}{\|\omega\|})\geq \hat{\gamma},\quad i=1,2,\cdots,N\]</span> 函数间隔<span class="math inline">\(\hat{\gamma}\)</span>的取值并不影响最优化问题的解。于是取<span class="math inline">\(\hat{\gamma}=1\)</span>,注意到最大化<span class="math inline">\(\frac{1}{\|\omega\|}\)</span>和最小化<span class="math inline">\(\frac{1}{2}\|\omega\|^2\)</span>是等价的。于是就得到了下面的线性可分支持向量机学习的最优化问题 <span class="math display">\[\min\limits_{\omega,b}\frac{1}{2}\|\omega\|^2 \\s.t. \quad y_i(\omega \cdot x_i+b)-1 \geq 0,i=1,2,\cdots,N\]</span> 为了求解线性可分支持向量机的最优化问题，通过应用拉格朗日对偶性，求解对偶问题得到原始问题的最优解。但是有些点可能不能满足函数间隔大于等于1的约束条件。为了解决这个问题，可以对每个样本点<span class="math inline">\((x_i,y_i)\)</span>引进一个松弛变量<span class="math inline">\(\xi_i\geq 0\)</span>，使得函数间隔加上松弛变量大于等于1。这样约束条件变为 <span class="math display">\[y_i(\omega\cdot x_i+b)\geq 1-\xi_i\]</span> 同时对每个松弛变量<span class="math inline">\(\xi_i\)</span>,支付一个代价<span class="math inline">\(\xi_i\)</span>，目标函数由原来的<span class="math inline">\(\frac{1}{2}\|\omega\|^2\)</span>变成 <span class="math display">\[\frac{1}{2}\|\omega\|^2+C\sum\limits_{i=1}\xi_i\]</span> 这里C&gt;0称为惩罚参数，一般由应用问题决定，C值大时，对误分类的惩罚增大，上面的最小化目标函数有两个含义，一是是使<span class="math inline">\(\frac{1}{2}\|\omega\|^2\)</span>尽量小即间隔尽量大，同时使误分类点的个数尽量少。 线性不可分的线性支持向量机的学习问题变成如下凸二次规划问题： <span class="math display">\[\min\limits_{\omega,b,\xi}\frac{1}{2}\|\omega\|^2+C\sum\limits_{i=1}^{N}\xi_i\\s.t. \quad y_i(\omega\cdot x_i+b)\geq 1-\xi_i,i=1,2,\cdots,N\\\xi_i \geq 0,i=1,2,\cdots,N\]</span> 上面问题的对偶问题是 <span class="math display">\[\min\limits_{\alpha}\frac{1}{2}\sum\limits_{i=1}^{N}\sum\limits_{j=1}^{N}\alpha_i\alpha_j y_i y_i(x_i\cdot x_j)-\sum\limits_{i=1}^{N}\alpha_i\\s.t. \sum\limits_{i=1}^{N}\alpha_iy_i=0\\0\geq \alpha_i \geq C,i=1,2,\cdots,N\]</span> 非线性问题往往不好求解，所以希望能用解线性分类问题的方法解决非线性问题，所采取的方法就是进行一个非线性变换，将非线性问题转换为线性问题，通过解变换后的线性问题的方法求解原来的非线性问题。核函数就可以通过一个非线性变换将输入空间对应于一个特征空间。应用核函数之后，对偶问题的目标函数的内积<span class="math inline">\(x_i\cdot x_j\)</span>可以用核函数<span class="math inline">\(K(x_i,x_j)=\phi(x_i)\phi(x_j)\)</span>来代替，对偶问题的目标函数变为： <span class="math display">\[W(\alpha)=\frac{1}{2}\sum\limits_{i=1}^{N}\sum\limits_{j=1}^{N}\alpha_i\alpha_j y_i y_jK(x_i,x_j)-\sum\limits_{i=1}^{N}\alpha_i\]</span></p><p>###　2.2 Fuzzy SVM</p><ol type="1"><li>Fuzzy SVM在每个训练数据上关联了一个模糊度<span class="math inline">\(s_i,0&lt; s_i\leq 1\)</span>，<span class="math inline">\(s_i\)</span>表示相应的训练数据属于一个类别的看法，即可以理解为权重。Since the fuzzy membership <span class="math inline">\(s_i\)</span> is the attitude of the corresponding point <span class="math inline">\(x_i\)</span> toward one class and the parameter <span class="math inline">\(\xi_i\)</span> is a measure of error in the SVM, the term <span class="math inline">\(s_i\xi_i\)</span>is a measure of error with different weighting.　所以最优超平面问题就归结为下面的约束问题： <span class="math display">\[\min\limits_{\omega,b,\xi}\frac{1}{2}\|\omega\|^2+C\sum\limits_{i=1}^{N}s_i\xi_i\\s.t. \quad y_i(\omega\cdot x_i+b)\geq 1-\xi_i,i=1,2,\cdots,N\\\xi_i \geq 0,i=1,2,\cdots,N\]</span> 应用拉格朗日乘数法得到： <span class="math display">\[\min W(\alpha)=\frac{1}{2}\sum\limits_{i=1}^{N}\sum\limits_{j=1}^{N}\alpha_i\alpha_j y_i y_jK(x_i,x_j)-\sum\limits_{i=1}^{N}\alpha_i \\s.t. \quad \sum\limits_{i=1}^{N}y_i\alpha_i=0,0\geq\alpha_i\geq s_iC,i=1,2,\cdots,N\]</span></li><li><strong><span class="math inline">\(s_i\)</span>的选取</strong> <span class="math inline">\(s_i\)</span>是通常是时间<span class="math inline">\(t_i\)</span>的函数，因为最近来的训练点的信息是最新的，因此提供的信息是最多的，因此<span class="math inline">\(s_i\)</span>应该越大。论文中选择<span class="math inline">\(\sigma&gt;0\)</span>来作为模糊度的下界，选择<span class="math inline">\(s_1=f(t_1)=\sigma\)</span>应用下界，得到模糊度是时间的线性函数时有 <span class="math display">\[s_i=f(t_i)=\frac{1-\sigma}{t_N-t_1}t_i+\frac{t_N\sigma-t_1}{t_N-t_1}\]</span> 如果模糊度是时间的二次函数得到： <span class="math display">\[s_i=f(t_i)=（1-\sigma）(\frac{t_i-t_1}{t_N-t_1})^2+\sigma\]</span> 在代码中实现的时候我们假设第一个来的训练数据的时间为1，第二个来的训练数据的时间为2，以此类推，最后一个来的训练数据的权重最大。</li></ol><h2 id="实验过程">3. 实验过程</h2><h3 id="机器学习实战上的svm">3.1 机器学习实战上的SVM</h3><p>1.弄懂书上的代码主要是弄懂SMO两层循环，书上代码的实现和李航的统计学习方法中的公式项吻合，看起来比较容易一些。<br />2.添加核函数，书上的代码只给出了两个核函数，即线性核函数和径向基核函数，自己补充了多项式核函数和sigmoid核函数。</p><p>SVM常用核函数:</p><ol type="1"><li>线性核函数:<span class="math inline">\(K(x,y)=x^Ty\)</span></li><li>多项式核函数:<span class="math inline">\(K(x,y)=((x^Ty)+1)^q\)</span></li><li>高斯核函数（径向基核函数）:<span class="math inline">\(K(x,y)=\exp^{\frac{\|x-y\|^2}{\sigma^2}}\)</span></li><li>sigmoid核函数:<span class="math inline">\(K(x,y)=\tanh(v(x^Ty)+c)\)</span></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">calc the kernel or transform data to a higher dimensional space</span></span><br><span class="line"><span class="string">比书上增加了两个核函数</span></span><br><span class="line"><span class="string">一个是多项式核函数，定义为polynomial，有一个参数q</span></span><br><span class="line"><span class="string">K(x,y) = ((x*y)+1)^q</span></span><br><span class="line"><span class="string">另一个是sigmoid函数，定义为sigmoid，有两个参数v,c</span></span><br><span class="line"><span class="string">K(x,y) = tanh(v(x*y)+c)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kernelTrans</span><span class="params">(X, A, kTup)</span>:</span>  <span class="comment"># calc the kernel or transform data to a higher dimensional space</span></span><br><span class="line">    m, n = shape(X)</span><br><span class="line">    K = mat(zeros((m, <span class="number">1</span>)))</span><br><span class="line">    <span class="keyword">if</span> kTup[<span class="number">0</span>] == <span class="string">'lin'</span>:</span><br><span class="line">        K = X * A.T  <span class="comment"># linear kernel</span></span><br><span class="line">    <span class="keyword">elif</span> kTup[<span class="number">0</span>] == <span class="string">'rbf'</span>:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">            deltaRow = X[j, :] - A</span><br><span class="line">            K[j] = deltaRow * deltaRow.T</span><br><span class="line">        K = exp(K / (<span class="number">-1</span> * kTup[<span class="number">1</span>] ** <span class="number">2</span>))  <span class="comment"># divide in NumPy is element-wise not matrix like Matlab</span></span><br><span class="line">    <span class="keyword">elif</span> kTup[<span class="number">0</span>] == <span class="string">'polynomial'</span>:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">            tmp = X[j, :] * A.T</span><br><span class="line">            K[j] = pow(tmp+<span class="number">1</span>, kTup[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">elif</span> kTup[<span class="number">0</span>] == <span class="string">'sigmoid'</span>:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(m):</span><br><span class="line">            tmp = kTup[<span class="number">1</span>]*(X[j,:]*A.T)+kTup[<span class="number">2</span>]</span><br><span class="line">            K[j] = tanh(tmp)</span><br><span class="line">    <span class="keyword">else</span>: <span class="keyword">raise</span> NameError(<span class="string">'That Kernel is not recognized'</span>)</span><br><span class="line">    <span class="keyword">return</span> K</span><br></pre></td></tr></table></figure><p>3.对课本案例进行实验，调整SVM参数，如C和核函数参数等，对比实验结果并分析。<br />实验结果如下 　 (1)当C=200时</p><table><thead><tr class="header"><th>内核，设置</th><th>训练正确率</th><th>测试正确率</th><th>支持向量数</th></tr></thead><tbody><tr class="odd"><td>linear</td><td>0.905473</td><td>0.924731</td><td>51</td></tr><tr class="even"><td>rbf,0.1</td><td>1.000000</td><td>0.478495</td><td>402</td></tr><tr class="odd"><td>rbf,5</td><td>1.000000</td><td>0.967742</td><td>402</td></tr><tr class="even"><td>rbf,10,best</td><td>1.000000</td><td>0.989247</td><td>108</td></tr><tr class="odd"><td>rbf,50</td><td>0.997512</td><td>0.983871</td><td>49</td></tr><tr class="even"><td>rbf,100</td><td>0.980100</td><td>0.946237</td><td>52</td></tr><tr class="odd"><td>polynomial,1</td><td>0.905473</td><td>0.924731</td><td>51</td></tr><tr class="even"><td>polynomial,2</td><td>0.985075</td><td>0.983871</td><td>43</td></tr><tr class="odd"><td>polynomial,5,best</td><td>0.980100</td><td>0.946237</td><td>52</td></tr><tr class="even"><td>polynomial,10</td><td>0.788557</td><td>0.854839</td><td>51</td></tr><tr class="odd"><td>polynomial,50</td><td>1.000000</td><td>0.989247</td><td>164</td></tr><tr class="even"><td>polynomial,100</td><td>1.000000</td><td>0.994624</td><td>173</td></tr><tr class="odd"><td>polynomial,150</td><td>0.000000</td><td>0.000000</td><td>0</td></tr><tr class="even"><td>sigmoid,0.00125,0.4</td><td>1.000000</td><td>0.994624</td><td>172</td></tr></tbody></table><p><strong>分析:</strong><br />当C值一定时，线性核函数的分类效果是不错的，但是没有调整好参数之后的径向基核函数和多项式和sigmoid核函数的分类效果好。<br />rbf核函数，随着参数的增大，分类效果逐渐变好，但是达到最好值10再增大，分类效果变差。<br />polynomial核函数，随着q值的增大，分类效果变好，达到最好值5之后再增大，分类效果变差。<br />sigmoid函数调整出来的最优的参数是v=0.00125,c=0.4。（这里只列出了最优分类效果的参数）sigmoid核函数调参数的时候可以固定一个成倍数的增加或者减少另外一个找最好的参数值。</p><p>(2)改变C的取值时，进行测试得到下面的结论:</p><table><thead><tr class="header"><th>内核，C</th><th>训练正确率</th><th>测试正确率</th><th>支持向量数</th></tr></thead><tbody><tr class="odd"><td>linear,1</td><td>0.905473</td><td>0.924731</td><td>51</td></tr><tr class="even"><td>linear,2</td><td>0.990050</td><td>0.967742 48</td><td></td></tr><tr class="odd"><td>linear,5</td><td>0.905473</td><td>0.924731</td><td>51</td></tr><tr class="even"><td>linear,10</td><td>0.992537</td><td>0.978495</td><td>52</td></tr><tr class="odd"><td>linear,200 or 50 or 25</td><td>0.905473</td><td>0.924731</td><td>51</td></tr><tr class="even"><td>linear,400</td><td>0.992537</td><td>0.973118</td><td>53</td></tr><tr class="odd"><td>linear,800</td><td>0.997512</td><td>0.983871</td><td>45</td></tr><tr class="even"><td>linear,1600</td><td>0.905473</td><td>0.924731</td><td>51</td></tr></tbody></table><p><strong>分析:</strong><br />当采用线性核函数时，随着C值的增大，分类效果循环变化，时好时坏。当然这些参数都需要根据具体样本集具体调整出最优的参数。</p><h3 id="fuzzy-svm">3.2 Fuzzy SVM</h3><p>1.修改代码将SVM改为FSVM<br />主要改动是在optStruct中添加一个成员变量，s,即模糊度，是一个向量。默认按时间进行初始化，时间就是每个训练集的下标。在SMO内层循环函数的终止条件和确定<span class="math inline">\(\alpha\)</span>上下界地方进行修改，主要是修改成<span class="math inline">\(C*s_i\)</span>或者<span class="math inline">\(C*s_j\)</span><br />2.构造模糊数据，从knn的代码中拷贝了30个手写值为0的文件，加入训练数据中，单独命名为fuzzyTrainDigits文件夹（主要是为了和SVM的测试数据集分开，避免混淆）。并把这30个0的label记为1,但是将他们对应的<span class="math inline">\(s_i\)</span>设置为<span class="math inline">\(10^-8\)</span>，因为他们的真实类别为0，这里为了构造模糊数据，将他们归为1类，并将其模糊度设置的非常小。<br />3.实验结果</p><table><thead><tr class="header"><th>内核，设置</th><th>训练正确率</th><th>测试正确率</th><th>支持向量数</th></tr></thead><tbody><tr class="odd"><td>linear</td><td>0.770833</td><td>0.876344</td><td>16</td></tr><tr class="even"><td>rbf,2</td><td>0.898148</td><td>0.521505</td><td>428</td></tr><tr class="odd"><td>rbf,5</td><td>0.865741</td><td>0.967742</td><td>28</td></tr><tr class="even"><td>rbf,10</td><td>0.821759</td><td>0.913978</td><td>23</td></tr><tr class="odd"><td>rbf,50</td><td>0.458333</td><td>0.521505</td><td>12</td></tr><tr class="even"><td>polynomial,1</td><td>0.472222</td><td>0.478495</td><td>8</td></tr><tr class="odd"><td>polynomial,2</td><td>0.768519</td><td>0.822581</td><td>29</td></tr><tr class="even"><td>polynomial,10</td><td>0.828704</td><td>0.940860</td><td>69</td></tr><tr class="odd"><td>polynomial,50</td><td>1.000000</td><td>0.989247</td><td>164</td></tr><tr class="even"><td>polynomial,100</td><td>0.930556</td><td>0.989247</td><td>186</td></tr><tr class="odd"><td>sigmoid,0.00125,0.4</td><td>0.458333</td><td>0.521505</td><td>18</td></tr></tbody></table><p><strong>分析:</strong><br />FSVM的参数变化时分类效果的好坏和SVM是大致相同的。也需要调整参数，还有就是要将每一个训练样本的模糊度设置好，将不太相关的模糊度设置很低，将相关的模糊度设置高一些，分类效果会好一些。其余代码详见提交文件的代码文件。</p><h2 id="总结">4. 总结</h2><p>通过这次实验熟悉了SVM的原理和SMO的算法实现，同时对模糊度有了一定的了解，通过自己编程实现，印象更加深刻。</p>]]></content>
      
      
      <categories>
          
          <category> machine learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> machine learning </tag>
            
            <tag> svm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bayes</title>
      <link href="/2016/04/10/bayes/"/>
      <url>/2016/04/10/bayes/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/yanruibo/machine-learning/tree/master/bayes" target="_blank" rel="noopener">code : https://github.com/yanruibo/machine-learning/tree/master/bayes</a></p><h2 id="要求">1. 要求</h2><p>实验目的：<br />　　掌握朴素贝叶斯分类方法的原理和应用<br />　　学会RSS数据集获取和数据解析<br />　　学习朴素贝叶斯分类方法的改进方法并应用<br />实验要求<br />　　1、课堂讲授的改进方法和paper方法，任一种即可<br />　　2、算法对比时以测试误差即错误率衡量，随机选取测试集时：或者a）固定随机选择的测试样本进行测试比较；或者b）随机选择多次，算出平均误差进行对比。<br />　　3、数据集：采用RSS方法获取数据集完成文本分类及书中所描述的应用；进行决策树算法对比时，建议采用前一章节数据集测试比对。<br />　　4、RSS下载英文高频词文件时，参考RSS应用教程。<br /><a id="more"></a></p><h2 id="相关知识">2. 相关知识</h2><h3 id="naive-bayesian-classifier">2.1 Naive Bayesian Classifier</h3><p>　　朴素贝叶斯法是基于贝叶斯定理与特征条件独立假设的分类方法。对于给定的数据集，首先基于特征条件独立假设学习输入的联合概率分布，然后基于此模型，对给定的输入x,利用贝叶斯定理求出后验概率最大的输出y。<br />　　朴素贝叶斯是一个条件概率模型：给定一个需要分类的实例x，用一个向量来表示<span class="math inline">\(\mathbf{x} = (x_1, \dots, x_n)\)</span>,并且假设这n个特征之间是相互独立的变量，然后对k个可能的类别计算下面的概率 <span class="math display">\[p(C_k \vert x_1, \dots, x_n)\,\]</span> <span class="math inline">\(C_k\)</span>代表是k个类别<br />接下来是尝试对上面的式子进行变形。用贝叶斯定理，条件概率可以被描述为： <span class="math display">\[p(C_k \vert \mathbf{x}) = \frac{p(C_k) \ p(\mathbf{x} \vert C_k)}{p(\mathbf{x})}. \,\]</span> 用贝叶斯概率的术语，上面的等式可以被重写为： <span class="math display">\[\mbox{posterior} = \frac{\mbox{prior} \times \mbox{likelihood}}{\mbox{evidence}}. \,\]</span> 在实际中，我们只对上述式子的分子感兴趣，因为分母并不依赖于类别，是一个常数，所以分子等价于一个联合概率模型： <span class="math display">\[p(C_k, x_1, \dots, x_n)\,\]</span> 这个联合概率模型利用链式规则可以被重写为下面的式子： <span class="math display">\[\begin{align}p(C_k, x_1, \dots, x_n) &amp; = p(C_k) \ p(x_1, \dots, x_n \vert C_k) \\                        &amp; = p(C_k) \ p(x_1 \vert C_k) \ p(x_2, \dots, x_n \vert C_k, x_1) \\                        &amp; = p(C_k) \ p(x_1 \vert C_k) \ p(x_2 \vert C_k, x_1) \ p(x_3, \dots, x_n \vert C_k, x_1, x_2) \\                        &amp; = p(C_k) \ p(x_1 \vert C_k) \ p(x_2 \vert C_k, x_1) \ \dots p(x_n \vert C_k, x_1, x_2, x_3, \dots, x_{n-1})\end{align}\]</span> 朴素贝叶斯假设各个特征之间相互独立的，假定第j个特征和第i个特征是相互独立的，则有下面的等式成立： <span class="math display">\[p(x_i \vert C_k, x_j) = p(x_i \vert C_k)\,\]</span> <span class="math display">\[p(x_i \vert C_k, x_j, x_q) = p(x_i \vert C_k)\,\]</span> <span class="math display">\[p(x_i \vert C_k, x_j, x_q, x_l) = p(x_i \vert C_k)\,\]</span>, 因此联合概率模型可以被描述为： <span class="math display">\[\begin{align}p(C_k \vert x_1, \dots, x_n) &amp; \varpropto p(C_k, x_1, \dots, x_n) \\                             &amp; \varpropto p(C_k) \ p(x_1 \vert C_k) \ p(x_2\vert C_k) \ p(x_3\vert C_k) \ \cdots \\                             &amp; \varpropto p(C_k) \prod_{i=1}^n p(x_i \vert C_k)\,.\end{align}\]</span> 这意味着基于以上的独立假设，在类C上的条件分布可以标示为： <span class="math display">\[p(C_k \vert x_1, \dots, x_n) = \frac{1}{Z} p(C_k) \prod\limits_{i=1}^n p(x_i \vert C_k)\]</span> 其中<span class="math inline">\(Z = p(\mathbf{x})\)</span>是一个比例因子只依赖于<span class="math inline">\(x_1, \dots, x_n\)</span>，只要特征的取值是已知的它就是一个常数。<br />利用上面的概率模型构建一个分类器，就是对每个类别都计算后验概率，哪个类别的后验概率大就判定为哪个类。 <span class="math display">\[\hat{y} = \underset{k \in \{1, \dots, K\}}{\operatorname{argmax}} \ p(C_k) \displaystyle\prod_{i=1}^n p(x_i \vert C_k).\]</span></p><p>参考：<a href="https://en.wikipedia.org/wiki/Naive_Bayes_classifier" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Naive_Bayes_classifier</a></p><h3 id="selective-bayesian-classifier">2.2 Selective Bayesian Classifier</h3><p>　　以下讲的方法来自于论文：Induction of Selective Bayesian Classifiers 　　选择贝叶斯分类器，其设计目标是为了提高朴素贝叶斯在属性冗余的情况下的分类精度。</p><ol type="1"><li>考虑前向搜索还是后向搜索，前向搜索从空集往里添加属性，后向搜索从所有特征种移除属性，后向搜索的一个潜在的问题是当多个属性是有关系时移除他们中的一个并不会提高分类效果，因为还存在冗余信息。所以选择前向搜索，这样当一个冗余属性添加进来时就能立即发现属性之间的依赖关系。<br /></li><li>考虑搜索过程，遍历搜索是不切实际的，因为在n个属性的有<span class="math inline">\(2^n\)</span>个子集。一个比较切实际的方法就是在机器学习中普遍应用的算法就是用一种贪婪的搜索算法。序列前向选择(SFS,Sequential Forward Selection)算法描述：特征子集X从空集开始，每次选择一个特征x加入特征子集X，使得特征函数J(X)最优。简单说就是，每次都选择一个使得评价函数的取值达到最优的特征加入，其实就是一种简单的贪心算法。<br /></li><li>在评估属性的可选子集时，我们采用了leave-one-out的交叉验证方法来估计训练集的精确度，因为这是最准确地交叉验证的方法。<br /></li><li>最后考虑两个规则来终止搜索过程，第一，所有的待选子集都没有提高分类精度，第二，采用一个保守的策略，只要不减少精确度就继续添加特征。最后要考虑所有特征的情况，论文中有提到。</li></ol><p>然后论文中采用的是UCI的数据(UCI reopsitory of machine learning datasets)。本文采用的是699个实例的breast cancer的数据。因为这个数据是最简单的。别的 Congressional voting records，mushroom domain都比较复杂。</p><h3 id="learning-an-optimal-naive-bayes-classifier">2.3 Learning an optimal Naive Bayes Classifier</h3><p>　　以下内容均来自论文：Learning an optimal Naive Bayes Classifier<br />　　朴素贝叶斯方法有两个缺点，第一个是当属性之间是不独立的时候分类精度就会下降，第二，不能解决非参数连续的问题。这篇论文提出了一个方法，该方法包含两个过程:Discretization based on minimum description length principle and Structural improvement based on mutual and conditional inforamtion measures.即基于MDL的离散化过程和去除冗余属性的结构提升过程。<br />1. 初始化。进行一个二分类<br />2. 离散化。对每个特征递归的进行二分类，对每一个划分计算MDL，直到一个新的划分的MDL不再提高。MDL表示保存一个特定信息的所需花费的比特数。然后它给出了一个评价指标，对每一次划分都要计算一下论文中的quality。quality的值越大越好。Net-Length正比于参数个数，这里可以取划分的个数（或者加上ｙ的种类数），Net-Weight是每个属性和类别之间的互信息的和。Max-Length，Max-Weight是每个属性取最大切分时的值。<br />3. 结构提升：1)计算每个属性和类别之间的互信息，互信息的值低于人工设定的阀值时，将这些属性删掉，因为这些属性没有提供有用的分类信息。2)经过第一步之后剩下的属性通过两两之间计算条件互信息，如果互信息的值比较高，说明这两个属性之间不独立，是相关的。3)对通过第二步检测出的条件互信息比较高的两个属性a)去掉一个属性，去掉和类别互信息小的那个属性；b)合并成一个属性。通过这两种方法哪个得到的分类准确率高，选择哪个方法。</p><p><strong>分析</strong>：<br />　　这个方法没有代码实现，但是认真了看了好长时间，就把编程的思路写出来了，就算写出来了，还存在一个问题就是数据集得自己找比较麻烦。<strong>其实编程实现很容易，难的是之前的理解过程，只要你把一个过程理解透了，程序自然也就写出来了</strong>，最大的一个感受就是做大数据机器学习的作业写代码往往只占比较少的时间。</p><h3 id="决策树id3和c4.5">2.4 决策树(ID3和C4.5)</h3><p>　　ID3算法的核心是在决策树的各个节点上应用信息增益选择特征，递归的构建决策树，具体方法是从根结点开始对结点计算所有可能的特征的信息增益，选择信息增益最大的特征作为结点的特征，由该特征的不同取值建立子节点，再对子节点递归的调用以上方法，构建决策树。<br />　　按照李航的《统计学习方法》中介绍的算法，C4.5与ID3算法的区别就是用信息增益比来选取特征。</p><h2 id="实验过程">3.实验过程</h2><h3 id="数据集选择">3.1 数据集选择</h3><p>　　本试验采用了两个数据集，一个是抓取的rss文档的数据集，另一个是UCI的breast cancer数据集。第二个数据集有很多版本，本试验下载了一个没有缺失值的版本，名称为unformatted-data.txt,经过preprocess_data.py处理之后变为前十列是属性值，第十一列是标签值，原来标签为2和4，处理之后变成了0和1。</p><h3 id="实验过程-1">3.2 实验过程</h3><p>　　根据前面相关知识的理解，进行编程，然后运行，得出结果。<br />　　主要的代码： SBC: <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Selective Bayesian Classifier</span></span><br><span class="line"><span class="string">从空集到全集搜索</span></span><br><span class="line"><span class="string">最主要的算法</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SBC</span><span class="params">(trainMat, trainClasses, testMat, testClasses)</span>:</span></span><br><span class="line">    <span class="comment"># 属性就是vocabList 训练集：trainMat trainClasses 测试集: testMat testClasses</span></span><br><span class="line">    <span class="comment"># 以第一个特征计算　目的是初始化值</span></span><br><span class="line">    <span class="comment">#totalFeatureNum记录共有多少列</span></span><br><span class="line">    <span class="comment">#remainedIndexes记录选取之后剩下的列的索引</span></span><br><span class="line">    <span class="comment">#bestIndex记录每一次要添加的最好的特征的列索引也就是第几列</span></span><br><span class="line">    <span class="comment">#选取一个属性时测试第一列之后的列，选取最好的那一列，这个没有放入循环中，主要是做一些初始化工作</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(remainedIndexes)):</span><br><span class="line">        errorRate, p0V, p1V, pSpam = cross_validation(trainMat[:, i].reshape((len(trainMat[:, i]), <span class="number">1</span>)), trainClasses)</span><br><span class="line">        <span class="keyword">if</span>(errorRate &lt; bestErrorRate):</span><br><span class="line">            bestErrorRate = errorRate</span><br><span class="line">            bestIndex = remainedIndexes[i]</span><br><span class="line">    <span class="comment">#将当前矩阵初始化为最好的那一列的值，这里需要将矩阵变成2维的，因为trainMat[:, bestIndex]是一维的。</span></span><br><span class="line">    currentMatrix = trainMat[:, bestIndex].reshape(len(trainMat[:, bestIndex]), <span class="number">1</span>)</span><br><span class="line">    <span class="comment">#selectedColumnIndexes记录当前所有的最好的特征的列索引</span></span><br><span class="line">    selectedColumnIndexes = [bestIndex]</span><br><span class="line">    remainedIndexes = list(set(fullIndexes) - set(selectedColumnIndexes))</span><br><span class="line">    <span class="comment">#decisionRemainedIndexes记录最终确定的剩余的特征的索引，这个需要返回，因为测试向量中相应的列要删掉</span></span><br><span class="line">    decisionRemainedIndexes = remainedIndexes</span><br><span class="line">    decisionP0V = p0V</span><br><span class="line">    decisionP1V = p1V</span><br><span class="line">    decisionPSpam = pSpam</span><br><span class="line">    <span class="comment">#算法的核心两重循环</span></span><br><span class="line">    <span class="keyword">while</span>(len(selectedColumnIndexes) &lt; totalFeatureNum):</span><br><span class="line">        isChanged = <span class="literal">False</span></span><br><span class="line">        bestIndex = remainedIndexes[<span class="number">0</span>]</span><br><span class="line">        <span class="comment">#测试剩余的列与当前已选则列的所有组合的准确率，选出最好的</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(remainedIndexes)):</span><br><span class="line">            errorRate, p0V, p1V, pSpam = cross_validation(</span><br><span class="line">            np.append(currentMatrix, trainMat[:, remainedIndexes[i]].reshape(len(trainMat[:, remainedIndexes[i]]), <span class="number">1</span>), axis=<span class="number">1</span>),</span><br><span class="line">            trainClasses)</span><br><span class="line">            <span class="comment">#只要准确率没有降低就继续添加特征</span></span><br><span class="line">            <span class="keyword">if</span>(errorRate &lt;= bestErrorRate):</span><br><span class="line">                isChanged = <span class="literal">True</span></span><br><span class="line">                bestErrorRate = errorRate</span><br><span class="line">                bestIndex = remainedIndexes[i]</span><br><span class="line">                <span class="keyword">print</span> <span class="string">"iterate bestErrorRate"</span>,bestErrorRate</span><br><span class="line">        <span class="comment">#如果当前准确率有提高，就更新记录变量的值，如果没有提高就停止添加特征跳出循环</span></span><br><span class="line">        <span class="keyword">if</span>(isChanged):</span><br><span class="line">            currentMatrix = np.append(currentMatrix, trainMat[:, bestIndex].reshape(len(trainMat[:, bestIndex]), <span class="number">1</span>), axis=<span class="number">1</span>)</span><br><span class="line">            selectedColumnIndexes.append(bestIndex)</span><br><span class="line">            remainedIndexes = list(set(fullIndexes) - set(selectedColumnIndexes))</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"selectedColumnIndexes"</span>, selectedColumnIndexes</span><br><span class="line">            decisionRemainedIndexes = remainedIndexes</span><br><span class="line">            decisionP0V = p0V</span><br><span class="line">            decisionP1V = p1V</span><br><span class="line">            decisionPSpam = pSpam</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 计算所有的特征集，文章中提到了要计算一下所有的特征集</span></span><br><span class="line">    errorRate, p0V, p1V, pSpam = cross_validation(trainMat, trainClasses)</span><br><span class="line">    <span class="keyword">if</span>(errorRate &lt; bestErrorRate):</span><br><span class="line">        decisionRemainedIndexes = []</span><br><span class="line">        decisionP0V = p0V</span><br><span class="line">        decisionP1V = p1V</span><br><span class="line">        decisionPSpam = pSpam</span><br></pre></td></tr></table></figure> 上面的代码进行了部分删除，只保留了核心代码。 下面是留一法验证的代码： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">leave-one-out　cross validation</span></span><br><span class="line"><span class="string">留一法验证</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cross_validation</span><span class="params">(trainMat, trainClasses)</span>:</span></span><br><span class="line">    errorCount = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 如果不是ndarray转化为ndarray</span></span><br><span class="line">    trainMat = np.asarray(trainMat)</span><br><span class="line">    trainClasses = np.asarray(trainClasses)</span><br><span class="line">    p0V = <span class="literal">None</span></span><br><span class="line">    p1V = <span class="literal">None</span></span><br><span class="line">    pSpam = <span class="literal">None</span></span><br><span class="line">    <span class="comment">#每次用第i行做测试向量</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(trainMat)):</span><br><span class="line">        <span class="comment"># 0是行 1是列</span></span><br><span class="line">        remainedTrainMat = np.delete(trainMat, [i], <span class="number">0</span>)</span><br><span class="line">        remainedTrainClasses = np.delete(trainClasses, [i], <span class="number">0</span>)</span><br><span class="line">        p0V, p1V, pSpam = trainNB0(remainedTrainMat, remainedTrainClasses)</span><br><span class="line">        <span class="keyword">if</span> classifyNB(trainMat[i], p0V, p1V, pSpam) != trainClasses[i]:</span><br><span class="line">            errorCount += <span class="number">1</span></span><br><span class="line">    errorRate = float(errorCount) / len(trainMat)</span><br><span class="line">    <span class="keyword">return</span> errorRate, p0V, p1V, pSpam</span><br></pre></td></tr></table></figure> C4.5建树： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">创建决策树，这里对代码进行了一些改动，不改变传入的labels的值。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createTree</span><span class="params">(dataSet, labels, threshhold=<span class="number">0</span>)</span>:</span></span><br><span class="line">    classList = [example[<span class="number">-1</span>] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br><span class="line">    <span class="keyword">if</span> classList.count(classList[<span class="number">0</span>]) == len(classList):</span><br><span class="line">        <span class="keyword">return</span> classList[<span class="number">0</span>]  <span class="comment"># stop splitting when all of the classes are equal</span></span><br><span class="line">    <span class="keyword">if</span> len(dataSet[<span class="number">0</span>]) == <span class="number">1</span>:  <span class="comment"># stop splitting when there are no more features in dataSet</span></span><br><span class="line">        <span class="keyword">return</span> majorityCnt(classList)</span><br><span class="line">    bestFeat = chooseBestFeatureToSplit(dataSet, threshhold)</span><br><span class="line">    <span class="comment">#低于阀值最好的feature返回-1，投票</span></span><br><span class="line">    <span class="keyword">if</span>(bestFeat == <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">return</span> majorityCnt(classList)</span><br><span class="line">    bestFeatLabel = labels[bestFeat]</span><br><span class="line">    myTree = &#123;bestFeatLabel:&#123;&#125;&#125;</span><br><span class="line">    remainedLabels = list(set(labels) - set(labels[bestFeat]))</span><br><span class="line">    <span class="comment"># del(labels[bestFeat])</span></span><br><span class="line">    featValues = [example[bestFeat] <span class="keyword">for</span> example <span class="keyword">in</span> dataSet]</span><br><span class="line">    uniqueVals = set(featValues)</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> uniqueVals:</span><br><span class="line">        <span class="comment"># subLabels = labels[:]  # copy all of labels, so trees don't mess up existing labels</span></span><br><span class="line">        subLabels = remainedLabels[:]  <span class="comment"># copy all of labels, so trees don't mess up existing labels</span></span><br><span class="line">        myTree[bestFeatLabel][value] = createTree(splitDataSet(dataSet, bestFeat, value), subLabels)</span><br><span class="line">    <span class="keyword">return</span> myTree</span><br></pre></td></tr></table></figure> c4.5分类： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">测试分类过程和ID3的思路类似</span></span><br><span class="line"><span class="string">输入创建好的决策树，类别标签和测试向量，对书中的代码进行改进</span></span><br><span class="line"><span class="string">如果在决策树中，在某一层没有测试数据的值，就在该层的任意一个分支往下找，这里取的是第一个分支，也就是最左边的分支。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">classify1</span><span class="params">(inputTree, featLabels, testVec)</span>:</span></span><br><span class="line">    firstStr = inputTree.keys()[<span class="number">0</span>]</span><br><span class="line">    secondDict = inputTree[firstStr]</span><br><span class="line">    featIndex = featLabels.index(firstStr)</span><br><span class="line">    classLabel = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">if</span> testVec[featIndex] <span class="keyword">in</span> secondDict.keys():</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> secondDict.keys():</span><br><span class="line">            <span class="keyword">if</span> testVec[featIndex] == key:</span><br><span class="line">                <span class="keyword">if</span> type(secondDict[key]).__name__ == <span class="string">'dict'</span>:</span><br><span class="line">                    classLabel = classify1(secondDict[key], featLabels, testVec)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    classLabel = secondDict[key]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        key = secondDict.keys()[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span>(type(secondDict[key]).__name__ == <span class="string">'dict'</span>):</span><br><span class="line">            classLabel = classify1(secondDict[key], featLabels, testVec)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            classLabel = secondDict[key]</span><br><span class="line">    <span class="keyword">return</span> classLabel</span><br></pre></td></tr></table></figure> 下面对代码文件进行一下说明： bayes.py是随书代码的源代码，对其进行了一些改进，并添加了一些函数，如写了SBC的算法，写了用rss数据测试SBC和NBC算法的函数。 bayes_uci.py是对应uci breast cancer数据的bayes算法，绝大部分内容和bayes.py中的代码相同，不同的是写了用UCI breast cancer数据测试SBC和NBC算法的函数。 ID3.py是随书代码的决策树那一章的代码，对其进行了改进，修复了创建树时改变传入参数labels的bug还有classify中的一些特殊情况。 C45.py的内容与ID3.py中的内容差不多，就是改成了利用信息增益比来 TestC45UCI.py　TestID3UCI.py TestNbcUci.py TestSbcUci.py分别使用UCI的breast cancer数据集来测试C4.5,ID3,Nbc和Sbc算法的。 TestNbcRss.pyTestSbcRss.py分别使用rss文档来测试Nbc和Sbc算法的。 还有一些对决策树代码的改进以及C4.5算法的编写详见代码。</p><h3 id="实验结果">3.3 实验结果</h3><table><thead><tr class="header"><th style="text-align: center;">classifier</th><th style="text-align: center;">NBC</th><th style="text-align: center;">SBC</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">accuracy(rss)</td><td style="text-align: center;">0.75</td><td style="text-align: center;">0.78</td></tr></tbody></table><p>分析：rss-NBC:每一次测试随机选取样本，计算多次求平均值<br />rss-SBC:每一次测试随机选取样本，由于运行时间长，只运行了一次。<br />因为rss的特征较多，有500多个单词，所以运行时间比较长。在SBC中，每做一次选择都要对训练集做留一法交叉验证计算平均精确度，在属性数目较多时，所花费的时间比较长。<br />而且像RSS这个数据集特征特别多，用ID3和C4.5的效果也不会特别好，虽然ID3和C4.5可以限制树的深度，但是对于这个数据集来说效果不是特别好。下面选用了一个比较好一点的数据集进行测试。就是UCI的breast cancer那个数据集。</p><table><thead><tr class="header"><th style="text-align: center;">classifier</th><th style="text-align: center;">NBC</th><th style="text-align: center;">SBC</th><th style="text-align: center;">ID3</th><th style="text-align: center;">C4.5</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">accuracy(UCI)</td><td style="text-align: center;">0.902857142857</td><td style="text-align: center;">0.935714285714</td><td style="text-align: center;">0.918678571429</td><td style="text-align: center;">0.920571428571</td></tr></tbody></table><p>从结果可以看出，SBC的精确度肯定比NBC的精确度好，按我们的算法至少和SBC的精确度相同，因为我们的算法在考虑完所有的添加特征之外，还计算了所有特征的情况，所以保证SBC算法是一定比NBC算法好的。<br />C4.5算法比ID3算法的精度要好，因为C4.5采用信息增益比来选取特征。ID3和C4.5算法都可以通过设置建树时选择合适的阀值threshold，可以控制树的深度。<br />从算法复杂度来讲：SBC要比NBC，ID3和C4.5高的多，所需时间也特别长，特别是对于特征多的情况。而NBC，ID3,C4.5则相对来说复杂度比较低，运行时间比较短。这里没有列出运行时间。但是很明显的感觉就是SBC的运行时间特别长。第一是因为选择特征的过程，第二是因为每次选择完特征都要进行留一法验证，这两个过程都很费时。</p><h2 id="总结">4.总结</h2><p>　　通过这次实验熟悉了NBC,SBC,ID3和C4.5算法，还看了一篇论文（Learning an optimal Naive Bayes Classifier）的算法，这篇论文的算法虽然没有实现，但是基本的思想以及一些公式计算已经搞懂了，因为时间原因没有进行代码实现。每一次作业还是收获挺多的，之前没有接触过机器学习的知识，在做的过程中也有向一些同学请教和讨论，但是代码都是自己独立写的，就是写之前的思路跟同学讨论过，还有就是感觉思路弄懂了，程序就能写出来，只是花费时间长短的问题。</p><h2 id="参考">5.参考</h2><ol type="1"><li>http://www.cs.ccsu.edu/~markov/ccsu_courses/mdl.pdf</li><li>A Tutorial Introduction to the Minimum Description Length Principle</li><li>Induction of selective Bayesian classifiers</li><li>Semi-naive Bayesian classifier</li><li>Learning an optimal Naive Bayes Classifier</li></ol>]]></content>
      
      
      <categories>
          
          <category> machine learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bayes </tag>
            
            <tag> machine learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kNN</title>
      <link href="/2016/04/10/kNN/"/>
      <url>/2016/04/10/kNN/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/yanruibo/machine-learning/tree/master/knn" target="_blank" rel="noopener">code:https://github.com/yanruibo/machine-learning/tree/master/knn</a></p><ol type="1"><li>距离度量用马氏距离</li><li>查找算法采用kd-tree. <a id="more"></a></li></ol><p>参考：<br />Mahalanobis Distance<br />http://kldavenport.com/mahalanobis-distance-and-outliers/<br />http://www.36dsj.com/archives/24325<br />kd tree<br />http://blog.csdn.net/v_july_v/article/details/8203674<br />kd tree pseudocode<br />http://web.stanford.edu/class/cs106l/handouts/assignment-3-kdtree.pdf<br />https://en.wikipedia.org/wiki/K-d_tree<br />(这几个参考资料非常好，清楚明白)</p>]]></content>
      
      
      <categories>
          
          <category> machine learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> machine learning </tag>
            
            <tag> kNN </tag>
            
            <tag> python </tag>
            
            <tag> kd-tree </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
